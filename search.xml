<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>API接口站</title>
    <url>/2023/11/12/API%E6%8E%A5%E5%8F%A3%E7%AB%99/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, 密码错了，检查一下好吗～" data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="e6f4a20aae8619baf74d41a93a2b52fd59f1c4776bb14f12334fcdf138e9f1d1">677ef50d06e2c4715af7b1d2b21c7aeb00785a4c843c37d08b9320c4431ea3b8798a3fbe6276fafcde6b3510168349a792b94ad5e7a8834b8b75dedcf5f3eefdd22d7945ae6d59dc11d83cf644ae9784779205ee107dbf3b261a226b600c75a7b2f1f3a0c49302286360cff91af2ad90b7e535d619ad77fa802036f3552ddcd6965e1b0cf4cb86402836249af1f56c3dec26f5c78569be1672704d07b5f507b4b4606a5baeb714fca12a19b56310537480bdc7d349fb840df68a00631a9c29a7273b0f82e4961c81cdbe01b4ed9de500b7ed0cf59864763bf24d258e47d607a00eb391f11b0353e70c49ad9fc1de6893f4165f8b0cd29cafe909fdc1019873d64841c2262772c563f51c22cb04a9c16132dae45b8f895fef73274f2ca543fd77bc9e36cb450c78536755972f1d9c549c75fb779d354d2703dc6ee202957a5224052287d88de7381bc30fa0b57ddd52ddad1bbe89ed94ac8591c710845db6e55294c0c10d78cbae9294023df348c290d2eb33a9316034ef04a67f8cd1724694f138ded1168bbb657796741563b82abf5fcc7b24d672ea9ec1cdbcca2b0665c3761a1875d9ddf668ca1a677428506318e2b3d1f0f3d18f430301bb0c244887c522cee6c6044d76f6cc40364c9573383ba1461f7c34a933f2592fd2956c8ea4b94e6a97f9a375a3462d8415388f28bb9d4eead66c456b3ff135049b2e4bb23ddf2604a5069456b0af21884361fb27196468a420d254729de5c499101633e00767d78e437abb87614360d389f68482d8d3a215e5358a78ce27a4dce1db54b1d0f0f08e8b73222aab240b8e3c1a85da6d92ad8057fe3f989a5d3033d1cfcaff9267cbe472780f2186441fc97f41426118bcfa6b5ae6fb6f24f5567101cf0e4c01afac2ba32b97a782f154fcdd5e7ccebe7e17465329b4144e3f878f8c0f2ff5d33cedae31c61db7d57b9e4dbf09266e3ad0bfec2e32c543fbf5c471512648e5abc8942b80d85521ceac7f068a18a8589e9a3b1fe6c8966b0bf8c070e95a02c5ce4ec3ee17623cd87414f29f268b2e2fea2bc37e253ababaf9ea64dfb58ec51dd6127ad6bc9103a9aff90d3ee9fa222f24cd810aff1ac3351fc7150eb6180656b64ec26e45cdc625b5294e504ab344ea32c73a351ea5f3380cfd0c46847f8edbbb65cdfd9786312eb36e000c15f7413e3fce1223395c71f0f9f4d38d0bd0629f23c8d68007a7594efcc419207353f53a3f418d4b2a717ff6cb84ff38ba7c7fb2778ec2cb42e12386a5da341bcca36188e753dc2f319ff628d125ee47497ef8f91de3cb2431b44341c0e4bd4a7e9a9d84b99ba9b3a205f9b93ad59dda42b7546c7acb1a6caa1178d57f48824621a7c4e7179597c46725e65725d893b5eea5c29679a6af4d219aad621790f9f30ffcf56095e04e8708b64e5074a29b3ccbe27b51c53bcadcbac8d77f7ec1bd138f5bd46f55365ffc47de61901b61380c21913def736e866fc2972baf6b7b4f0d5df836863bbe701e0f7ced61caa9c305ddb1674bf765be8b6e354e21f1cf5ded2d537b70a58cc99e8875514594cf63cb5850af9414d00e2d3ef860dd08296382b7f200662b42558998598e8798e673f456c0e71d0054b17c77ee63557544ee934fd0625b20c21630313d98c6c1b6527d6dcdd4edc58dca1619934f63c250059e063f2a121742ce199177a6494ed3df33981a453ba47785d5f17e11f5e88415f5438cc9e52da4795b1663e7d850c1f7f6e1235a3ca024fded1f9679f52f5517a22f0fbea570fd0cbeb9f774ecccc98ac0c3b821d57902288da17d69fb24ad815f1d0a287db9a584f1e0a81d53a4e792f70abf0ef7bf24e1ea2ae8a22e006311dd0ec44a0cd4fee6257946793ddf228df79c3336ed952827037362f0d3960a2dbd993c7c00e3924e1a32912dc36d28869b406cb0fb3a271885a17cced25ae7d7d226f71243dbe18cccadbc89b6c454b3dbfaa54eb3578f65b215c3f169910b74ad8241c0fdf9d448d4baca9e4abe026e9ebb3b633be2c7e9337a0c2a1344c0b0a3e7c94ae3fbf6434b8e5a8e53c4d1c4eb9c71e1faea0a04a3de547851ab087ff2aad91c9c86d3c6d78809906645f247247c86632e0e8576810dbb048d1376a19ee0cbe1db7afa32575841fc63b681007c4f6da033d6c23333c35ffdc88b48a2602c1808a337656ea6b2235c68c02d868189703c320296bcc54e09178e01db943406f9b89fe6af5fc147304a5da441225cc90a1499815d0a7d841ec76457ca8d0bdf0e3d41aa00caddda459c42286ac87f4cbb264d46be2d55b5d28d641afe9dfadb8a79c0f8fd9f49ac94a4d52aca24d2e6851a3030697d903cf4a974e53d26881303cbea88176200af02715b66c4c126377d7d34249caa404776ca195d2cacccc4c3af989b90211cfddf3a09d9e4f681eb1f73e842b0b137ada9fb14d735407e5edd63093d564f1486d111d118a7e53e691e40fd4495cad430aa891f75b3ae35ccde868a34b900f5c134593949946ffdf635bc73a1b66cc67e3f803d0e3ead803dafc3a9829fff50c7ff5a6c89dc88475ecca2bdd795fd53c35a16f0f301c2c902228b64c73e17f8944b8488cd6cf067908db8b9d4626faa2dd615a68164e95fc2c9862e95ba29895b8f864f839c60ea2d59769a6ba4589d5996659f0e42fee26d88377b479ee991af603edd11bc51ac354bbba95f8ca257056cbfbc728101e2f95b28930aef79eca40594f9159f66df77c07b98fbf6b6bca650b9b97c627bea042999eed078d7e7d21b63ce6080969aef3860e2b83be3116d12bb1b4a23cd7e7451ec450f2d8edc2b64f938f1bfd8e38f705e7590842162fe37ecab3a90c2cc734b2ca5e13569cfb7ce907c7b45b4eb0ad2d7ce5e549fa0dfacfa4ac4bce7f3f0aece4920ead2e7eb4223199a0c68f885aa5f3fe8be39f4fd0dd101da27280792addd993faf23be12bd4c42facb7b14b7e1f547234e48fa21b932c8dd56b0322345e7cfc1f3df5df7f912a1dd70969749f92db71dc9de23cd26e3f65f55cf27c2d32eeb3bbf80d2cc1f4765a519a5e9f302e622db3099ff8685ff4c02e47d09b6ddd78c395b5a3e09522f2589354feb615b2f8f61d45c6a280e7c8431e672d77cfb174538cb89122daec0a8fc55e45ef75babfd9c146ad7396270da21df1f3f418190e0809ba2281974f776203e993c090a4a8a771ced7a907ce12df422aff9c936954c8d2ab5552f86bdadf290ee61ff689d608acaebec497d82e2938c736eb3db639b0839861cab055dacf864225964e8dba0336a17f4d16ff3618be17717372e4d103b12971e6c911cd59fe8d67910d5ba57f3902befae0ddc94661fbae7791f63006f552483940a38d902134afb83b1d55f8b89f49995003f1137ff2c2972cc09218062088e882c986ac9351f207687bd11f014472b0187b3434f48a5a29b1228301d987a1b5b0bcfc9b57c72b2de553061fbd8624d718524a51633abc99729179c0ffe6791bf11ecada502b720822b173d7d7e383c7fde32f4eba7aba34c35e7e1a86a8a718fee085968c6f9aa61fc10db166cd57051893bc41bcc9ac2cc1a8e2ad776b966e788844eafea7136092603d4c2f0f9a28e060c1089e4bf3efab828538058dcc64f2ca505386e76a6270e6b1900e73d1908c5a5f16f3aeb8ebb6b96b1512dd86d24625b22247812a40cd659d57cdb4c8a200cb83df2e3703266b53c23c070a74b02b8dc6f84974735516ff9bc4e5711245e2afe689c106e2d6df64bb20412b7d25a0a1dd40ac071935a4232b09c34f9336ee1a3facbb1966b91332fd54eec7e54c5459777871aff40d758a3cdd63a5ab9a9e730ea72214bbe313770392daf6842d73578e8a76647fa322c581a4e89d2d79beb076a3a09fc8a037eeeb37a201ccf7f4f22752be5a9fd9c245d520697de82595a41b093f19a1368a33cf35aa5c8b85e739e5b500c2996dc0dbadf222b720bf31ae8087d1617050f4407edea25f6e9eb373aaa0f4639f3159f76383a1325c0538502dcfcadc6b8b01b5e4eaf9f0d3a53e5e02ae90236b173bc5fe119524d0facca99d47e84c1ac2f7f3b0afcac26e6d920283eac605491e51465ccfbee9323b97953ce2cc420daab13d57362a072ea03a5ab7edfc2af1e2ffddeb3e36d8581df89c971473bce9bb3e0b6dbae9123bc96337e34a5eecbe3e1b219c70494adad42656c1787cc3e2a7d4dcb3b7ec24a13cb8bb767130bbd46d034dec5c070153f317a3db001e8ffeb242b02ff4e88be00509680443929d5d12b61ad698d10e4b34939a1c83387b048b2d8a50e87179555ddea5844abdc66bc1fc5d56d920e677b22dd4c288028411fb552b65dc4b878945b5891aed79771e7e75d4390905b8522e5c8249ab918a49c77289d584b0ea502c8c59b041f31093d82245cba94214c64898c477fd9e4f54089be8b22dc76c49cbdc3f13c73af6e44c088f52fddf589a9e743c0a260961d3904c203c5235a9f6f2fb336879b8dc6db980e0ef06475ca034ee5e932a73a72a5b73eb58bf26f7cea59c3b6bee7a02746462ea6d0606ccfe03f2a29033289f47cb960dd0dd0cf590b6178cfd93abe2c5b427482c241c62766ac292787a348cb413a8d91833edd900cf464a79ede71e54fd03e5b06e863eb65d8f094bf746ba01e17a7aec044a2012356987dd497bc635c0607c1c80708dacd9b7bde7111f779fd9dfdbafd306f504981d9c4359f38c37d626062570dfcafb67d5137310e28090852ec56ee6306351596a0fafb56fdcacc6d168bdabfa5c841985022c2000d22d6ceeb91ab8e4d17d5c1f4d07464f4a1b6c559bc94c6f7c38ed2ad7c74583ebee3083304b99876a38a1f817522a31d64007d7dfa8cabb10f9d64b71420949035c98e485248b26302173dc0e181d31a5c8e1aeb8dbfa97e715e89a3109e35e797e230ee022ac446f24ea6d9489fcd711a516fd173a4e3f6decfd04925738c38e2060928f8e03648dd18cd83741f7525d7e8d04c0910a5235a79ac3024d7a53bf73a905d9eb15efaa2fece7dd4182a6dd12fe97d6d5b2e751638e8d3519f2c2bfd63e8d5f5d0e948993a1850b3a1d69c6fbba0fb7c8bf74fd9459c831180f5917491637680dcfbc0a2e79de8cb921b10671e23b15c2c9ba170c1064b14c486426f270b798bfefb82a3</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, 这篇文章被加密了，请输入密码！</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>笔记</category>
        <category>记录</category>
      </categories>
      <tags>
        <tag>API</tag>
      </tags>
  </entry>
  <entry>
    <title>Cloudflare Tunnels 免费内网穿透</title>
    <url>/2023/11/17/Cloudflare%20Tunnels%20%E5%85%8D%E8%B4%B9%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/</url>
    <content><![CDATA[<h2 id="方法一">方法一</h2>
<p>官网绑卡选择免费计划：<a href="https://one.dash.cloudflare.com/">https://one.dash.cloudflare.com/</a><br>
然后直接面板操作，比方法二简单，缺点就是要绑卡（虽然是免费计划，但需要先绑卡）</p>
<h2 id="方法二">方法二</h2>
<blockquote>
<p>本地编写配置文件，不需要去cf绑卡选计划</p>
</blockquote>
<ol>
<li>
<p>下载程序</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//amd架构</span><br><span class="line">wget https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-amd64 -O /usr/bin/cloudflared</span><br><span class="line"></span><br><span class="line">//arm64、aarch64架构</span><br><span class="line">wget https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-arm64 -O /usr/bin/cloudflared</span><br><span class="line"></span><br><span class="line">//其他</span><br><span class="line">自行官方下载：https://github.com/cloudflare/cloudflared/releases</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>设置权限</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod +x /usr/bin/cloudflared   #给可执行权限</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>登录</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cloudflared tunnel login</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>终端会给出一个链接，浏览器打开选择域名进行授权，下面授权完成后终端会显示<code>cert.pem</code>地址，保存好，丢失了重新<code>login</code>一次</p>
</li>
<li>
<p>如果是有二步验证的，需要登录了以后，再次黏贴该地址，因为二步验证结束后并不会自动跳转到该 cloudflared 验证登录页面。</p>
</li>
<li>
<p>授权的话，每次只能选择一个网站，当然，一个网站也就够用了，我们可以解析很多三级域名啥的。当然如果需要授权多个网站，授权完成后不要关闭网页！依次点击其他需要授权的域名，进行多次授权。</p>
</li>
</ul>
</li>
<li>
<p>创建隧道</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//web是隧道名</span><br><span class="line">cloudflared tunnel create web</span><br></pre></td></tr></table></figure>
<blockquote>
<p>会显示出隧道UUID，也可使用 <code>cloudflared tunnel list</code> 查看</p>
</blockquote>
<p>123是隧道名，名字是可以自定义的，但是不能重复。如果想要查看已经创建的隧道的话，可以输入</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cloudflared tunnel list</span><br></pre></td></tr></table></figure>
<p>如果要删除，可以输入以下命令删除</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cloudflared tunnel delete web</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>配置DNS记录，给隧道分配域名</p>
<p><code>cloudflared tunnel route dns &lt;tunnel-name&gt; &lt;domain&gt;</code>，其中的 <code>&lt;tunnel-name&gt;</code>是创建Tunnel时指定的名称，<code>&lt;domain&gt;</code>是自定义的域名，比如 <code>web.example.com</code>:</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//例如：</span><br><span class="line">cloudflared tunnel route dns web web.example.com</span><br></pre></td></tr></table></figure>
<ul>
<li>然后 cloudflare 就会在你的域名下自动生成一个 CNAME，把 <a href="http://web.example.com">web.example.com</a> 指向 &lt;隧道 UUID&gt;.cfargotunnel.com</li>
<li>如果还有其他域名需要配置，可以继续执行上面的命令（别忘了改域名）。配置完成后可以前往Cloudflare控制台查看到CNAME记录。</li>
</ul>
<blockquote>
<p>注意：如果之前添加的有多个不同的二级域名，比如 <a href="http://example1.com">example1.com</a> 和 <a href="http://example2.com">example2.com</a>，只会对第一个添加的 <a href="http://example1.com">example1.com</a> 生效，后面的 <a href="http://example2.com">example2.com</a> 域名下的 CNAME 记录需要自行去网站上手动添加了。当然如果只有 <a href="http://example1.com">example1.com</a> 一个域名就不影响了，可以依旧使用类似以下的命令来创建更多需要的域名解析。<br>
<code>cloudflared tunnel route dns ednovas ssh.example1.com</code></p>
</blockquote>
</li>
<li>
<p>编写配置文件<br>
创建配置文件config.yml</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim ~/.cloudflared/config.yml</span><br></pre></td></tr></table></figure>
<p>然后输入 i ,进入编辑模式，黏贴修改后的配置文件，如下（自行按需修改）<br>
把<font color="#ff0000">第四步创建隧道这一步骤</font>的隧道UUID复制下来粘贴到下面的对应的两个位置，并复制粘贴</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Tunnel UUID，即隧道UUID，就是同目录下的json文件的文件名</span><br><span class="line">tunnel: &lt;隧道UUID&gt;</span><br><span class="line"></span><br><span class="line"># 鉴权文件路径，注意根据自己的路径修改，下面的例子是Linux的路径</span><br><span class="line">credentials-file: /root/.cloudflared/&lt;隧道UUID&gt;.json</span><br><span class="line">protocol: h2mux</span><br><span class="line"></span><br><span class="line"># 服务配置</span><br><span class="line">ingress:</span><br><span class="line">  # 第一个网站，连接到本地的80端口</span><br><span class="line">  - hostname: &lt;域名1.com&gt;</span><br><span class="line">    service: http://localhost:80</span><br><span class="line">  # 第二个网站，https协议，连接到本地的443端口，禁用证书校验（用于自签名SSL证书）</span><br><span class="line">  - hostname: &lt;域名2.com&gt;</span><br><span class="line">    service: https://127.0.0.1:443</span><br><span class="line">    originRequest:</span><br><span class="line">      noTLSVerify: true</span><br><span class="line">      originServerName: &lt;域名2.com&gt;</span><br><span class="line">  # 第三个网站，8012端口，泛域名</span><br><span class="line">  - hostname: &lt;*.域名3.com&gt;</span><br><span class="line">    service: http://localhost:8012</span><br><span class="line">  # 第四个，反代MySQL sock服务</span><br><span class="line">  - hostname: &lt;mysql.域名4.com&gt;</span><br><span class="line">    service: unix:/tmp/mysql.sock</span><br><span class="line">  # 第五个，反代SSH服务</span><br><span class="line">  - hostname: &lt;ssh.域名5.com&gt;</span><br><span class="line">    service: ssh://localhost:22</span><br><span class="line"># 最后记得添加一个默认404</span><br><span class="line">  - service: http_status:404</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>配置完成后，验证一下配置文件是否正确：<br>
<code>cloudflared tunnel ingress validate</code></p>
</li>
<li>
<p>还可以再测试下规则是否命中：<br>
<code>cloudflared tunnel ingress rule https://&lt;域名1.com&gt;</code></p>
</li>
<li>
<p>如果需要更多的端口 / 协议支持，可以查看 cloudflare 官方文档：<br>
<a href="https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/install-and-setup/tunnel-guide/local/local-management/ingress/#supported-protocols">https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/install-and-setup/tunnel-guide/local/local-management/ingress/#supported-protocols</a></p>
</li>
</ul>
<p>其中<code>ingress</code>字段可以创建多个服务，支持的服务类型如下表，新建其他服务前需要到 Cloudflare 控制台对其他子域名进行解析。</p>
<table>
<thead>
<tr>
<th style="text-align:left">服务名称</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">service 示例值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">HTTP/S</td>
<td style="text-align:left">常规网页服务</td>
<td style="text-align:left"><code>https://localhost:8000</code></td>
</tr>
<tr>
<td style="text-align:left">TCP</td>
<td style="text-align:left">TCP 连接</td>
<td style="text-align:left"><code>tcp://localhost:25565</code></td>
</tr>
<tr>
<td style="text-align:left">SSH</td>
<td style="text-align:left">SSH 连接</td>
<td style="text-align:left"><code>ssh://localhost:22</code></td>
</tr>
<tr>
<td style="text-align:left">RDP</td>
<td style="text-align:left">远程桌面（RDP）</td>
<td style="text-align:left"><code>rdp://localhost</code></td>
</tr>
</tbody>
</table>
<blockquote>
<p>上表转自 Cloudflare 官方文档，仅节选常用协议，若需要完整版请至 <a href="https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/configuration/local-management/ingress/">Ingress rules</a> 页面查看。</p>
</blockquote>
</li>
<li>
<p>注册为系统服务（自动安装）</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cloudflared service install</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>设置自启动</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl start cloudflared</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>查看状态</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl status cloudflared</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://lxnchan.cn/cf-tunnel.html">https://lxnchan.cn/cf-tunnel.html</a></li>
<li><a href="https://ednovas.xyz/2023/02/24/cloudflaretunnel/">https://ednovas.xyz/2023/02/24/cloudflaretunnel/</a></li>
<li><a href="https://www.cnblogs.com/HeiDaotu/p/17283757.html">https://www.cnblogs.com/HeiDaotu/p/17283757.html</a></li>
<li><a href="https://blog.zapic.moe/archives/tutorial-176.html">https://blog.zapic.moe/archives/tutorial-176.html</a></li>
<li><a href="https://blog.imoeq.com/cloudflare-argo-tunnel/">cloudflare tunnel 详细介绍 —— 面向cloudflare的网站搭建,1分钟快速启动一个有ssl证书的wordpress博客 - 私は萌いQ(˘•ω•˘) (imoeq.com)</a></li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
        <category>Cloudflare</category>
      </categories>
      <tags>
        <tag>Cloudflare</tag>
        <tag>内网穿透</tag>
        <tag>Tunnels</tag>
      </tags>
  </entry>
  <entry>
    <title>Cloudflare Workers反代系列</title>
    <url>/2023/11/17/Cloudflare-Workers%E5%8F%8D%E4%BB%A3%E7%B3%BB%E5%88%97/</url>
    <content><![CDATA[<blockquote>
<p>未验证，待整理中</p>
</blockquote>
<h2 id="gh-proxy">gh-proxy</h2>
<ul>
<li><a href="https://github.com/hunshcn/gh-proxy">GitHub - hunshcn/gh-proxy: github release、archive以及项目文件的加速项目</a></li>
</ul>
<h2 id="jsdelivr">jsdelivr</h2>
<ul>
<li><a href="https://blog.moeworld.tech/2022/06/18/%e4%bd%bf%e7%94%a8works%e6%90%ad%e5%bb%bajsdelivr%e9%95%9c%e5%83%8f%e7%ab%99/">使用Works搭建Jsdelivr镜像站 - 晓空blog</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1987458">使用Cloudflare Worker为jsDelivr搭建反向代理服务-腾讯云开发者社区-腾讯云</a></li>
</ul>
<p>bili33：</p>
<ul>
<li><a href="https://bili33.top/posts/vercel-reverse-proxy/">Vercel搭建反向代理 | GamerNoTitle</a></li>
<li><a href="https://github.com/biliCDN/bilicdn.github.io">GitHub - biliCDN/bilicdn.github.io: 哔哩CDN：公益性的jsdelivr镜像源</a></li>
<li><a href="https://bili33.top/posts/jsDelivr-Usage/">jsDelivr的正确打开方式 | GamerNoTitle</a></li>
<li><a href="https://bili33.top/posts/Migrate-jsdelivr-mirror-to-Gcore/#%E6%88%98%E5%89%8D%E5%87%86%E5%A4%87">将jsdelivr镜像源迁移到Gcore —— Gcore CDN使用 | GamerNoTitle</a></li>
</ul>
<h2 id="tg-bot-api">tg bot api</h2>
<ul>
<li><a href="https://anerg.com/2022/07/25/reverse-proxy-telegram-bot-api-using-cloudflare-worker.html">使用Cloudflare Worker代理Telegram Bot Api – 废墟</a></li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
        <category>Cloudflare</category>
      </categories>
      <tags>
        <tag>Cloudflare</tag>
        <tag>反代</tag>
      </tags>
  </entry>
  <entry>
    <title>Butterfly 一些魔改美化</title>
    <url>/2023/10/17/Butterfly-%E4%B8%80%E4%BA%9B%E9%AD%94%E6%94%B9%E7%BE%8E%E5%8C%96/</url>
    <content><![CDATA[<div class="note orange icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p>简单记录一下我Butterfly主题的美化和魔改</p>
</div>
<h2 id="站点动态-title">站点动态 title</h2>
<p>站点动态 title 是通过 js 监测是否聚焦于当前页面，从而替换标签显示内容。</p>
<details class="toggle" ><summary class="toggle-button" style="">查看步骤</summary><div class="toggle-content"><ol>
<li>
<p>在 [Blogroot]\themes\butterfly\source\js\ 目录下新建 title.js:</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//动态标题</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">OriginTitile</span> = <span class="variable language_">document</span>.<span class="property">title</span>;</span><br><span class="line"><span class="keyword">var</span> titleTime;</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;visibilitychange&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">document</span>.<span class="property">hidden</span>) &#123;</span><br><span class="line">        <span class="comment">//离开当前页面时标签显示内容</span></span><br><span class="line">        <span class="variable language_">document</span>.<span class="property">title</span> = <span class="string">&#x27;w(ﾟДﾟ)w 不要走！再看看嘛！&#x27;</span>;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(titleTime);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//返回当前页面时标签显示内容</span></span><br><span class="line">        <span class="variable language_">document</span>.<span class="property">title</span> = <span class="string">&#x27;♪(^∇^*)欢迎回来！&#x27;</span> + <span class="title class_">OriginTitile</span>;</span><br><span class="line">        <span class="comment">//两秒后变回正常标题</span></span><br><span class="line">        titleTime = <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">document</span>.<span class="property">title</span> = <span class="title class_">OriginTitile</span>;</span><br><span class="line">        &#125;, <span class="number">2000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>在 [Blogroot]_config.butterfly.yml 的 inject 配置项添加引入，此处因为这是个独立的 js，而且体量极小，所以可以添加 async 异步加载标签：</p>
 <figure class="highlight text"><table><tr><td class="code"><pre><span class="line">inject:</span><br><span class="line">head:</span><br><span class="line">  # - &lt;link rel=&quot;stylesheet&quot; href=&quot;/xxx.css&quot;&gt;</span><br><span class="line">bottom:</span><br><span class="line">  # - &lt;script src=&quot;xxxx&quot;&gt;&lt;/script&gt;</span><br><span class="line">  - &lt;script async src=&quot;/js/title.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</div></details>
<h2 id="修改标题样式">修改标题样式</h2>
<details class="toggle" ><summary class="toggle-button" style="">查看步骤</summary><div class="toggle-content"><ul>
<li>
<p>在 Blog/themes/butterfly/source/css 文件下新建 css 文件，并命名为 custom.css (命名按照自己喜好去命名，只需在主题配置文件_config.butterfly.yml 中引入对应的 css 文件即可)，将以下代码复制到新建的 custom.css 中。</p>
</li>
<li>
<p>如果想自行修改标题样式的话，将 content: ‘\f0c1’; 中的内容换成自己想要的即可，如要添加动画，参考 animation: avatar_turn_around 1s linear infinite;。</p>
</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#article-container</span> <span class="selector-tag">h1</span><span class="selector-pseudo">:before</span>,</span><br><span class="line"><span class="selector-id">#article-container</span> <span class="selector-tag">h2</span><span class="selector-pseudo">:before</span>,</span><br><span class="line"><span class="selector-id">#article-container</span> <span class="selector-tag">h3</span><span class="selector-pseudo">:before</span>,</span><br><span class="line"><span class="selector-id">#article-container</span> <span class="selector-tag">h4</span><span class="selector-pseudo">:before</span>,</span><br><span class="line"><span class="selector-id">#article-container</span> <span class="selector-tag">h5</span><span class="selector-pseudo">:before</span>,</span><br><span class="line"><span class="selector-id">#article-container</span> <span class="selector-tag">h6</span><span class="selector-pseudo">:before</span>,</span><br><span class="line"><span class="selector-id">#post</span> <span class="selector-class">.post-outdate-notice</span><span class="selector-pseudo">:before</span>,</span><br><span class="line"><span class="selector-class">.fontawesomeIcon</span>,</span><br><span class="line"><span class="selector-class">.note</span><span class="selector-pseudo">:not</span>(<span class="selector-class">.no-icon</span>)<span class="selector-pseudo">::before</span>,</span><br><span class="line">hr<span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">    <span class="attribute">font-weight</span>: <span class="number">600</span>;</span><br><span class="line">    <span class="attribute">font-style</span>: normal;</span><br><span class="line">    <span class="attribute">font-variant</span>: normal;</span><br><span class="line">    <span class="attribute">font-family</span>: <span class="string">&#x27;Font Awesome 5 Free&#x27;</span>;</span><br><span class="line">    <span class="attribute">text-rendering</span>: auto;</span><br><span class="line">    -webkit-<span class="attribute">font-smoothing</span>: antialiased</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#article-container</span> <span class="selector-tag">h1</span><span class="selector-pseudo">:before</span>,</span><br><span class="line"><span class="selector-id">#article-container</span> <span class="selector-tag">h2</span><span class="selector-pseudo">:before</span>,</span><br><span class="line"><span class="selector-id">#article-container</span> <span class="selector-tag">h3</span><span class="selector-pseudo">:before</span>,</span><br><span class="line"><span class="selector-id">#article-container</span> <span class="selector-tag">h4</span><span class="selector-pseudo">:before</span>,</span><br><span class="line"><span class="selector-id">#article-container</span> <span class="selector-tag">h5</span><span class="selector-pseudo">:before</span>,</span><br><span class="line"><span class="selector-id">#article-container</span> <span class="selector-tag">h6</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#f47466</span>;</span><br><span class="line">    <span class="comment">/* 回形针 */</span></span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&#x27;\f0c1&#x27;</span>;  <span class="comment">/* 若要使用风车效果，请注释这一行 */</span></span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">1</span>;</span><br><span class="line">    -webkit-<span class="attribute">transition</span>: all .<span class="number">2s</span> ease-out;</span><br><span class="line">    -moz-<span class="attribute">transition</span>: all .<span class="number">2s</span> ease-out;</span><br><span class="line">    -o-<span class="attribute">transition</span>: all .<span class="number">2s</span> ease-out;</span><br><span class="line">    -ms-<span class="attribute">transition</span>: all .<span class="number">2s</span> ease-out;</span><br><span class="line">    <span class="attribute">transition</span>: all .<span class="number">2s</span> ease-out;</span><br><span class="line">    <span class="comment">/* 若要使用风车效果，请去掉下面的注释 */</span></span><br><span class="line">    <span class="comment">/* content: &#x27;\f863&#x27;; </span></span><br><span class="line"><span class="comment">    animation: avatar_turn_around 1s linear infinite; */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#article-container</span> <span class="selector-tag">h1</span> &#123;</span><br><span class="line">    <span class="attribute">padding-left</span>: <span class="number">1.4rem</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#article-container</span> <span class="selector-tag">h1</span> <span class="selector-tag">code</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">1rem</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#article-container</span> <span class="selector-tag">h1</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">1.3rem</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="built_in">calc</span>(<span class="number">50%</span> - .<span class="number">5rem</span>);</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">1rem</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#article-container</span> <span class="selector-tag">h1</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="attribute">padding-left</span>: <span class="number">1.6rem</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#article-container</span> <span class="selector-tag">h2</span> &#123;</span><br><span class="line">    <span class="attribute">padding-left</span>: <span class="number">1.3rem</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#article-container</span> <span class="selector-tag">h2</span> <span class="selector-tag">code</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: .<span class="number">9rem</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#article-container</span> <span class="selector-tag">h2</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">1.4rem</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="built_in">calc</span>(<span class="number">50%</span> - .<span class="number">45rem</span>);</span><br><span class="line">    <span class="attribute">font-size</span>: .<span class="number">9rem</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#article-container</span> <span class="selector-tag">h2</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="attribute">padding-left</span>: <span class="number">1.5rem</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#article-container</span> <span class="selector-tag">h3</span> &#123;</span><br><span class="line">    <span class="attribute">padding-left</span>: <span class="number">1.2rem</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#article-container</span> <span class="selector-tag">h3</span> <span class="selector-tag">code</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: .<span class="number">8rem</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="built_in">calc</span>(<span class="number">50%</span> - .<span class="number">4rem</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#article-container</span> <span class="selector-tag">h3</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">1.2rem</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="built_in">calc</span>(<span class="number">50%</span> - .<span class="number">4rem</span>);</span><br><span class="line">    <span class="attribute">font-size</span>: .<span class="number">8rem</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#article-container</span> <span class="selector-tag">h3</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="attribute">padding-left</span>: <span class="number">1.4rem</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#article-container</span> <span class="selector-tag">h4</span> &#123;</span><br><span class="line">    <span class="attribute">padding-left</span>: <span class="number">1.1rem</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#article-container</span> <span class="selector-tag">h4</span> <span class="selector-tag">code</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: .<span class="number">7rem</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#article-container</span> <span class="selector-tag">h4</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">1rem</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="built_in">calc</span>(<span class="number">50%</span> - .<span class="number">35rem</span>);</span><br><span class="line">    <span class="attribute">font-size</span>: .<span class="number">7rem</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#article-container</span> <span class="selector-tag">h4</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="attribute">padding-left</span>: <span class="number">1.3rem</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#article-container</span> <span class="selector-tag">h5</span> &#123;</span><br><span class="line">    <span class="attribute">padding-left</span>: <span class="number">1rem</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#article-container</span> <span class="selector-tag">h5</span> <span class="selector-tag">code</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: .<span class="number">6rem</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#article-container</span> <span class="selector-tag">h5</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">    <span class="attribute">margin-left</span>: -.<span class="number">8rem</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="built_in">calc</span>(<span class="number">50%</span> - .<span class="number">3rem</span>);</span><br><span class="line">    <span class="attribute">font-size</span>: .<span class="number">6rem</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#article-container</span> <span class="selector-tag">h5</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="attribute">padding-left</span>: <span class="number">1.2rem</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#article-container</span> <span class="selector-tag">h6</span> &#123;</span><br><span class="line">    <span class="attribute">padding-left</span>: <span class="number">1rem</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#article-container</span> <span class="selector-tag">h6</span> <span class="selector-tag">code</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: .<span class="number">6rem</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#article-container</span> <span class="selector-tag">h6</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">    <span class="attribute">margin-left</span>: -.<span class="number">8rem</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="built_in">calc</span>(<span class="number">50%</span> - .<span class="number">3rem</span>);</span><br><span class="line">    <span class="attribute">font-size</span>: .<span class="number">6rem</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#article-container</span> <span class="selector-tag">h6</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="attribute">padding-left</span>: <span class="number">1.2rem</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
<h2 id="添加卡通人物（加强版看板娘）">添加卡通人物（加强版看板娘）</h2>
<details class="toggle" ><summary class="toggle-button" style="">查看步骤</summary><div class="toggle-content"><div class="note info simple"><ul>
<li>参考教程：<a href="https://blog.csdn.net/csdn__cpp/article/details/110007453">在butterfly主题下如何配置加强版看板娘？<em>kali</em>._的博客-CSDN博客</a></li>
<li>相关链接 ：<br>
①张书樵大神魔改后的项目：<a href="https://github.com/stevenjoezhang/live2d-widget">GitHub - stevenjoezhang/live2d-widget: 把萌萌哒的看板娘抱回家 (ノ≧∇≦)ノ | Live2D widget for web platform</a><br>
②可自建后端 API<a href="https://github.com/fghrsh/live2d_api">GitHub - fghrsh/live2d_api: Live2D 看板娘插件 (https://www.fghrsh.net/post/123.html) 上使用的后端 API</a></li>
</ul>
</div>
<ol>
<li>
<p>下载</p>
<p><strong>如果已经安装过官方提供的live2d，需要先卸载！</strong></p>
<p><code>npm uninstall hexo-helper-live2d</code></p>
<p>然后下载经过张书樵大神魔改后的项目：<a href="https://github.com/stevenjoezhang/live2d-widget">GitHub - stevenjoezhang/live2d-widget: 把萌萌哒的看板娘抱回家 (ノ≧∇≦)ノ | Live2D widget for web platform</a></p>
<p>下载解压到：<code>themes\butterfly\source\</code>文件夹下</p>
</li>
<li>
<p>设置绝对路径</p>
<p><strong>打开项目目录进入修改autoload.js文件，将live2d_path设为自己的路径，一般没什么太大变化都为</strong>：</p>
<p><code>/live2d-widget/</code></p>
</li>
<li>
<p>引入</p>
<p>打开butterfly下的layout下的includes目录，点击修改head.pug文件，在文件末尾粘贴：</p>
<p><code>script(src='/live2d-widget/autoload.js')</code></p>
<p>最后在主题配置文件下即butterfly下的_config.yml（如果配置了 _config.butterfly.yml，则使用这个配置文件）中开启看板娘：</p>
 <figure class="highlight text"><table><tr><td class="code"><pre><span class="line"># 看板娘</span><br><span class="line">live2d:</span><br><span class="line">  enable: true</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>自定义配置（随意）</p>
</li>
</ol>
<ul>
<li>修改看板娘的位置<br>
在live2d-widget目录下的waifu.css中可以修改画布位置使得看板娘显示在你指定的位置，具体在#waifu选择器下修改</li>
<li>修改聊天内容<br>
可以在live2d-widget文件夹下的waifu-tips.json文件中修改，进去就可以看到大量的文本内容</li>
<li>修改首次加载的模型<br>
如果你不喜欢默认的第一个模型，可以指定首次加载的模型，具体配置在live2d-widget文件夹下的src/index.js中的大约133行，原作者也在这里注释了模型的ID，默认为1，后面的模型依次递增(待补充)</li>
</ul>
</div></details>
<h2 id="鼠标样式">鼠标样式</h2>
<h2 id="鼠标-字跟随掉落效果">鼠标 * 字跟随掉落效果</h2>
<h2 id="星空背景和流星特效">星空背景和流星特效</h2>
<h2 id="樱花飘落效果">樱花飘落效果</h2>
<h2 id="背景一图流">背景一图流</h2>
<details class="toggle" ><summary class="toggle-button" style="">查看步骤</summary><div class="toggle-content"><div class="note info simple"><p>参考教程：<a href="https://yuqi.fun/posts/f7d3fad8.html">Butterfly主题 一图流背景与顶部图修改 | 与亓のBlog (yuqi.fun)</a></p>
</div>
<ol>
<li>
<p>设置背景</p>
<p>这个是 <a href="https://butterfly.js.org/">Butterfly</a> 自带的功能，修改主题的配置文件 <code>_config.butterfly.yml</code>。</p>
<p>编辑 <code>index_img</code>、<code>background</code>、<code>footer_bg</code> 选项。</p>
<p>设置网站背景，并将主页顶部图和页脚背景改为透明。(需要将以下示例地址替换为自己的图片地址。可以用一张具体的图片，也可以用随机图api，随机显示图片)</p>
 <figure class="highlight text"><table><tr><td class="code"><pre><span class="line"># Image (圖片設置)</span><br><span class="line"># --------------------------------------</span><br><span class="line"></span><br><span class="line"># The banner image of home page</span><br><span class="line">index_img: transparent</span><br><span class="line"></span><br><span class="line"># Beautify/Effect (美化/效果)</span><br><span class="line"># --------------------------------------</span><br><span class="line"></span><br><span class="line"># Website Background (設置網站背景)</span><br><span class="line"># can set it to color or image (可設置圖片 或者 顔色)</span><br><span class="line"># The formal of image: url(http://xxxxxx.com/xxx.jpg)</span><br><span class="line">background: url(http://xxxxxx.com/xxx.jpg)</span><br><span class="line"></span><br><span class="line"># Footer Background</span><br><span class="line">footer_bg: transparent</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>引入相关样式</p>
<p>新建一个文件，位于 <code>source/css/modify.styl</code>，并增加以下内容。</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@import &#x27;nib&#x27;</span><br><span class="line"></span><br><span class="line">// 顶部图</span><br><span class="line">#page-header</span><br><span class="line">  &amp;, &amp;:before</span><br><span class="line">    background: transparent !important</span><br><span class="line">  &amp;.post-bg, &amp;.not-home-page</span><br><span class="line">    height: 280px !important</span><br><span class="line">  #post-info</span><br><span class="line">    bottom: 40px !important</span><br><span class="line">  #page-site-info</span><br><span class="line">    top: 140px !important</span><br><span class="line"></span><br><span class="line">  @media screen and (max-width: 768px)</span><br><span class="line">    &amp;.not-home-page</span><br><span class="line">      height: 200px !important</span><br><span class="line">    #post-info</span><br><span class="line">      bottom: 10px !important</span><br><span class="line">    #page-site-info</span><br><span class="line">      top: 100px !important</span><br><span class="line"></span><br><span class="line">.top-img</span><br><span class="line">  height: 250px</span><br><span class="line">  margin: -50px -40px 50px</span><br><span class="line">  border-top-left-radius: inherit</span><br><span class="line">  border-top-right-radius: inherit</span><br><span class="line">  background-position: center center</span><br><span class="line">  background-size: cover</span><br><span class="line">  transition: all 0.3s</span><br><span class="line"></span><br><span class="line">  @media screen and (max-width: 768px)</span><br><span class="line">    height: 230px</span><br><span class="line">    margin: -36px -14px 36px</span><br><span class="line"></span><br><span class="line">  [data-theme=&#x27;dark&#x27;] &amp;</span><br><span class="line">    filter: brightness(0.8)</span><br><span class="line"></span><br><span class="line">// 页脚</span><br><span class="line">#footer:before</span><br><span class="line">  background-color: alpha(#FFF, .5)</span><br><span class="line"></span><br><span class="line">  [data-theme=&#x27;dark&#x27;] &amp;</span><br><span class="line">    background-color: alpha(#000, .5)</span><br><span class="line"></span><br><span class="line">#footer-wrap, #footer-wrap a</span><br><span class="line">  color: #111</span><br><span class="line">  transition: unset</span><br><span class="line"></span><br><span class="line">  [data-theme=&#x27;dark&#x27;] &amp;</span><br><span class="line">    color: var(--light-grey)</span><br></pre></td></tr></table></figure>
<p>在主题配置文件 <code>_config.butterfly.yml</code> 的 <code>inject.head</code> 引入样式。</p>
 <figure class="highlight text"><table><tr><td class="code"><pre><span class="line"># Inject</span><br><span class="line"># Insert the code to head (before &#x27;&lt;/head&gt;&#x27; tag) and the bottom (before &#x27;&lt;/body&gt;&#x27; tag)</span><br><span class="line"># 插入代码到头部 &lt;/head&gt; 之前 和 底部 &lt;/body&gt; 之前</span><br><span class="line">inject:</span><br><span class="line">  head:</span><br><span class="line">    - &lt;link rel=&quot;stylesheet&quot; href=&quot;/css/modify.css&quot;&gt;</span><br></pre></td></tr></table></figure>
<p><code>modify.styl</code> 会被 Hexo 渲染成 <code>modify.css</code> 文件，所以此处应为 <code>modify.css</code>。</p>
</li>
<li>
<p>增加插件脚本</p>
<p>因为使用了 <code>cheerio</code> 来解析 HTML，所以需要先安装此依赖。</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install cheerio</span><br></pre></td></tr></table></figure>
<p>新建一个文件，位于 <code>scripts/modify.js</code>，并增加以下内容。</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> cheerio = <span class="built_in">require</span>(<span class="string">&quot;cheerio&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在页面插入新顶部图</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">cheerio.Root</span>&#125; $ Root</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">insertTopImg</span>(<span class="params">$</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> header = $(<span class="string">&quot;#page-header&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (header.<span class="property">length</span> === <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">let</span> background = header.<span class="title function_">css</span>(<span class="string">&quot;background-image&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (!background) <span class="keyword">return</span>;</span><br><span class="line">  $(<span class="string">&quot;#post, #page, #archive, #tag, #category&quot;</span>).<span class="title function_">prepend</span>(</span><br><span class="line">    <span class="string">`&lt;div class=&quot;top-img&quot; style=&quot;background-image: <span class="subst">$&#123;background&#125;</span>;&quot;&gt;&lt;/div&gt;`</span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hexo.<span class="property">extend</span>.<span class="property">filter</span>.<span class="title function_">register</span>(<span class="string">&quot;after_render:html&quot;</span>, <span class="keyword">function</span> (<span class="params">str, data</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> $ = cheerio.<span class="title function_">load</span>(str, &#123;</span><br><span class="line">    <span class="attr">decodeEntities</span>: <span class="literal">false</span>,</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="title function_">insertTopImg</span>($);</span><br><span class="line">  <span class="keyword">return</span> $.<span class="title function_">html</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ol>
</div></details>
<h2 id="顶部导航栏美化">顶部导航栏美化</h2>
<h2 id="基于-Butterfly-的外挂标签引入">基于 Butterfly 的外挂标签引入</h2>
<h2 id="添加贡献日历">添加贡献日历</h2>
<h2 id="键入在线聊天功能">键入在线聊天功能</h2>
<h2 id="留言板信封">留言板信封</h2>
<h2 id="文章加密">文章加密</h2>
<details class="toggle" ><summary class="toggle-button" style="">查看步骤</summary><div class="toggle-content"><ol>
<li>
<p>安装插件</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install --save hexo-blog-encrypt</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>启用</p>
<p>在<code>/blog/_config.yml</code>文件中添加以下内容:</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#文字加密</span><br><span class="line">encrypt:</span><br><span class="line">    enable: true</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用（仅单篇文章加密）</p>
<blockquote>
<p>在想要使用加密功能的文字头部加上对应文字：</p>
</blockquote>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">password: 123456 </span><br><span class="line">abstract: 欢迎来到我的博客，输入密码阅读</span><br><span class="line">message: Hey, 这篇文章被加密了，请输入密码！</span><br><span class="line">wrong_pass_message: Oh, 密码错了，检查一下好吗～</span><br></pre></td></tr></table></figure>
<ul>
<li>password: 该篇文章使用的密码</li>
<li>abstract: 摘要文字（少量）</li>
<li>message: 密码框上的描述性文字</li>
</ul>
</li>
</ol>
</div></details>
<h2 id="添加评论">添加评论</h2>
<details class="toggle" ><summary class="toggle-button" style="">查看步骤</summary><div class="toggle-content"><blockquote>
<p>本教程采用<code>waline</code>评论系统</p>
</blockquote>
<ol>
<li>
<p>介绍</p>
</li>
<li>
<p>配置<code>waline</code></p>
<p>直接查看官方教程：<a href="https://waline.js.org/guide/get-started/">快速上手 | Waline</a></p>
<p>简单来说就是：注册LeanCloud并创建应用，Vercel 部署 (服务端)，主题配置文件启用</p>
</li>
<li>
<p>在Butterfly主题中启用<code>waline</code></p>
<blockquote>
<p><a href="https://butterfly.js.org/posts/ceeb73f/?highlight=waline#%E8%A9%95%E8%AB%96">Butterfly 安裝文檔(四) 主題配置-2 | Butterfly</a></p>
</blockquote>
<p>更改<code>comments</code>和<code>waline</code>部分</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">comments:</span><br><span class="line">  # 最多两个注释系统，第一个将显示为默认值</span><br><span class="line">  # 选择：Disqus/Disqusjs/Livere/Gitalk/Valine/Waline/Utterances/Facebook Comments/Twikoo/Giscus/Remark42/Artalk</span><br><span class="line">  use: Waline # Valine,Disqus</span><br><span class="line">  text: true # 在按钮旁边显示注释名称</span><br><span class="line">  # lazyload: 注释系统将在注释元素进入浏览器视口时加载。</span><br><span class="line">  # 如果将其设置为true，则注释计数将无效</span><br><span class="line">  lazyload: false</span><br><span class="line">  count: true # 在文章的top_img中显示评论计数</span><br><span class="line">  card_post_count: false # 在主页中显示评论计数</span><br><span class="line"></span><br><span class="line">waline:</span><br><span class="line">  serverURL: # Waline服务器地址url,比如https://example.yourdomain.com，后面不要加`/`</span><br><span class="line">  bg: # waline 背景</span><br><span class="line">  pageview: false</span><br><span class="line">  option:</span><br><span class="line">    locale:</span><br><span class="line">      placeholder: 小站已开启评论审核，可匿名评论，但评论需要通过审核后才能够出现在评论区哦~</span><br><span class="line">    emoji: [</span><br><span class="line">      &#x27;https://unpkg.com/@waline/emojis@1.2.0/alus&#x27;,</span><br><span class="line">      &#x27;https://unpkg.com/@waline/emojis@1.2.0/weibo&#x27;,</span><br><span class="line">    ]</span><br><span class="line">    pageSize: 10 # 评论每页显示数量</span><br><span class="line">    highlight: true</span><br></pre></td></tr></table></figure>
<p><code>emoji</code>自行寻找，官方提供的有一些：<a href="https://waline.js.org/guide/features/emoji.html">表情选项卡 | Waline</a></p>
<p>网上发现的表情库：</p>
<ul>
<li><a href="https://github.com/zhaoolee/ChineseBQB">GitHub - zhaoolee/ChineseBQB: 🇨🇳 Chinese sticker pack,More joy / 表情包的博物馆, Github最有毒的仓库, 中国表情包大集合, 聚欢乐~</a></li>
<li><a href="https://github.com/GamerNoTitle/Valine-Magic">GitHub - GamerNoTitle/Valine-Magic: ✨Valine/MiniValine/Waline（已兼容新版写法，直接使用MiniValine同样的链接即可）自定义表情列表，为你的表情库“喜加亿”</a></li>
</ul>
</li>
</ol>
</div></details>
<h2 id="页脚美化">页脚美化</h2>
<details class="toggle" ><summary class="toggle-button" style="">查看步骤</summary><div class="toggle-content"><ol>
<li>
<p>添加各种小徽标</p>
<p>找到<code>_config.butterfly.yml</code>文件的<code>footer</code>部分，更改<code>custom_text</code></p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">custom_text: |</span><br><span class="line"> I wish you to become your own sun, no need to rely on who&#x27;s light.</span><br><span class="line"> &lt;p&gt;</span><br><span class="line"> &lt;a target=&quot;_blank&quot; href=&quot;https://hexo.io/&quot;&gt;&lt;img src=&quot;https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo&quot; title=&quot;博客框架为Hexo&quot;&gt;&lt;/a&gt;&amp;nbsp;</span><br><span class="line"> &lt;a target=&quot;_blank&quot; href=&quot;https://butterfly.js.org/&quot;&gt;&lt;img src=&quot;https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender&quot; title=&quot;主题采用butterfly&quot;&gt;&lt;/a&gt;&amp;nbsp;</span><br><span class="line"> &lt;a target=&quot;_blank&quot; href=&quot;https://www.cloudflare.com/&quot;&gt;&lt;img src=&quot;https://img.shields.io/badge/CDN-Cloudflare-orange?style=flat&amp;logo=Cloudflare&quot; title=&quot;本站使用Cloudflare为静态资源提供CDN加速&quot;&gt;&lt;/a&gt;&amp;nbsp;</span><br><span class="line"> &lt;a target=&quot;_blank&quot; href=&quot;https://github.com/&quot;&gt;&lt;img src=&quot;https://img.shields.io/badge/Source-Github-d021d6?style=flat&amp;logo=GitHub&quot; title=&quot;本站项目由Gtihub托管&quot;&gt;&lt;/a&gt;&amp;nbsp;</span><br><span class="line"> &lt;a target=&quot;_blank&quot; href=&quot;http://creativecommons.org/licenses/by-nc-sa/4.0/&quot;&gt;&lt;img src=&quot;https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris&quot; title=&quot;本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可&quot;&gt;&lt;/a&gt;</span><br><span class="line"> &lt;/p&gt;</span><br><span class="line"> 当前CDN节点: &lt;span id=&quot;cdn&quot;&gt;&lt;/span&gt;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>页脚显示当前Cloudflare CDN节点</p>
<p>原理：Cloudflare为所有客户加上了/cdn-cgi/端点，<a href="http://xn--Cloudflareexample-ps50a2wz9ce2duwcx74i6l8ifwwa2r0azm8evuzc.com/cdn-cgi/trace">任何一个套了Cloudflare的网站访问example.com/cdn-cgi/trace</a> 后都会返回用户现在的信息，如ip地址、CDN节点、是否开启WARP、tls协议版本等。那么就可以在前端访问这个端点，再进行解析，将内容写入前段对应id的标签内，就可以呈现出目前的用户与Cloudflare CDN间的关系了。</p>
<p>由于使用了jQuery来访问cdn-cgi，所以使用这个脚本需要先引入这个库。已经引用了此库的博客无需再次引用。</p>
<p>在<code>_config.butterfly.yml</code>文件的<code>inject</code>部分，修改bottom，添加<code>- &lt;script src=&quot;https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js&quot;&gt;&lt;/script&gt;</code></p>
<p>在 <code>\blog\themes\butterfly\source\js</code> 目录创建cfcdn.js，填入以下内容</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(document).ready($.ajax(&#123;url: &quot;/cdn-cgi/trace&quot;,success: function(data, status) &#123;let areas=[&#x27;&#123;&quot;s&quot;:&quot;TNR&quot;,&quot;l&quot;:&quot;Antananarivo, Madagascar&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;CPT&quot;,&quot;l&quot;:&quot;Cape Town, South Africa&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;CMN&quot;,&quot;l&quot;:&quot;Casablanca, Morocco&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;DAR&quot;,&quot;l&quot;:&quot;Dar Es Salaam, Tanzania&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;JIB&quot;,&quot;l&quot;:&quot;Djibouti City, Djibouti&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;DUR&quot;,&quot;l&quot;:&quot;Durban, South Africa&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;JNB&quot;,&quot;l&quot;:&quot;Johannesburg, South Africa&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;KGL&quot;,&quot;l&quot;:&quot;Kigali, Rwanda&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;LOS&quot;,&quot;l&quot;:&quot;Lagos, Nigeria&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;LAD&quot;,&quot;l&quot;:&quot;Luanda, Angola&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;MPM&quot;,&quot;l&quot;:&quot;Maputo, MZ&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;MBA&quot;,&quot;l&quot;:&quot;Mombasa, Kenya&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;MRU&quot;,&quot;l&quot;:&quot;Port Louis, Mauritius&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;RUN&quot;,&quot;l&quot;:&quot;Réunion, France&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;BLR&quot;,&quot;l&quot;:&quot;Bangalore, India&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;BKK&quot;,&quot;l&quot;:&quot;Bangkok, Thailand&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;BWN&quot;,&quot;l&quot;:&quot;Bandar Seri Begawan, Brunei&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;CEB&quot;,&quot;l&quot;:&quot;Cebu, Philippines&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;CTU&quot;,&quot;l&quot;:&quot;成都, 🇨🇳 中国大陆&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;MAA&quot;,&quot;l&quot;:&quot;Chennai, India&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;CGP&quot;,&quot;l&quot;:&quot;Chittagong, Bangladesh&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;CKG&quot;,&quot;l&quot;:&quot;重庆, 🇨🇳 中国大陆&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;CMB&quot;,&quot;l&quot;:&quot;Colombo, Sri Lanka&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;DAC&quot;,&quot;l&quot;:&quot;Dhaka, Bangladesh&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;SZX&quot;,&quot;l&quot;:&quot;东莞, 🇨🇳 中国大陆&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;FUO&quot;,&quot;l&quot;:&quot;佛山, 🇨🇳 中国大陆&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;FOC&quot;,&quot;l&quot;:&quot;福州, 🇨🇳 中国大陆&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;CAN&quot;,&quot;l&quot;:&quot;广州, 🇨🇳 中国大陆&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;HGH&quot;,&quot;l&quot;:&quot;杭州, 🇨🇳 中国大陆&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;HAN&quot;,&quot;l&quot;:&quot;Hanoi, Vietnam&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;HNY&quot;,&quot;l&quot;:&quot;衡阳, 🇨🇳 中国大陆&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;SGN&quot;,&quot;l&quot;:&quot;Ho Chi Minh City, Vietnam&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;HKG&quot;,&quot;l&quot;:&quot;🇭🇰 香港&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;HYD&quot;,&quot;l&quot;:&quot;Hyderabad, India&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;ISB&quot;,&quot;l&quot;:&quot;Islamabad, Pakistan&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;CGK&quot;,&quot;l&quot;:&quot;Jakarta, Indonesia&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;TNA&quot;,&quot;l&quot;:&quot;济南, 🇨🇳 中国大陆&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;KHI&quot;,&quot;l&quot;:&quot;Karachi, Pakistan&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;KTM&quot;,&quot;l&quot;:&quot;Kathmandu, Nepal&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;CCU&quot;,&quot;l&quot;:&quot;Kolkata, India&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;KUL&quot;,&quot;l&quot;:&quot;Kuala Lumpur, Malaysia&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;LHE&quot;,&quot;l&quot;:&quot;Lahore, Pakistan&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;NAY&quot;,&quot;l&quot;:&quot;廊坊, 🇨🇳 中国大陆&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;LYA&quot;,&quot;l&quot;:&quot;洛阳, 🇨🇳 中国大陆&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;MFM&quot;,&quot;l&quot;:&quot;🇲🇴 澳门&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;MLE&quot;,&quot;l&quot;:&quot;Malé, Maldives&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;MNL&quot;,&quot;l&quot;:&quot;Manila, Philippines&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;BOM&quot;,&quot;l&quot;:&quot;Mumbai, India&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;NAG&quot;,&quot;l&quot;:&quot;Nagpur, India&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;NNG&quot;,&quot;l&quot;:&quot;南宁, 🇨🇳 中国大陆&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;DEL&quot;,&quot;l&quot;:&quot;New Delhi, India&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;KIX&quot;,&quot;l&quot;:&quot;Osaka, Japan&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;PNH&quot;,&quot;l&quot;:&quot;Phnom Penh, Cambodia&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;TAO&quot;,&quot;l&quot;:&quot;青岛, 🇨🇳 中国大陆&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;ICN&quot;,&quot;l&quot;:&quot;Seoul, South Korea&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;SHA&quot;,&quot;l&quot;:&quot;上海, 🇨🇳 中国大陆&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;SHE&quot;,&quot;l&quot;:&quot;沈阳, 🇨🇳 中国大陆&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;SJW&quot;,&quot;l&quot;:&quot;石家庄, 🇨🇳 中国大陆&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;SIN&quot;,&quot;l&quot;:&quot;Singapore, Singapore&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;SZV&quot;,&quot;l&quot;:&quot;苏州, 🇨🇳 中国大陆&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;TPE&quot;,&quot;l&quot;:&quot;台北, 🇨🇳 台湾&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;PBH&quot;,&quot;l&quot;:&quot;Thimphu, Bhutan&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;TSN&quot;,&quot;l&quot;:&quot;天津, 🇨🇳 中国大陆&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;NRT&quot;,&quot;l&quot;:&quot;Tokyo, Japan&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;ULN&quot;,&quot;l&quot;:&quot;Ulaanbaatar, Mongolia&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;VTE&quot;,&quot;l&quot;:&quot;Vientiane, Laos&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;WUH&quot;,&quot;l&quot;:&quot;武汉, 🇨🇳 中国大陆&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;WUX&quot;,&quot;l&quot;:&quot;无锡, 🇨🇳 中国大陆&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;XIY&quot;,&quot;l&quot;:&quot;西安, 🇨🇳 中国大陆&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;EVN&quot;,&quot;l&quot;:&quot;Yerevan, Armenia&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;CGO&quot;,&quot;l&quot;:&quot;郑州, 🇨🇳 中国大陆&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;CSX&quot;,&quot;l&quot;:&quot;株洲, 🇨🇳 中国大陆&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;AMS&quot;,&quot;l&quot;:&quot;Amsterdam, Netherlands&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;ATH&quot;,&quot;l&quot;:&quot;Athens, Greece&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;BCN&quot;,&quot;l&quot;:&quot;Barcelona, Spain&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;BEG&quot;,&quot;l&quot;:&quot;Belgrade, Serbia&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;TXL&quot;,&quot;l&quot;:&quot;Berlin, Germany&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;BRU&quot;,&quot;l&quot;:&quot;Brussels, Belgium&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;OTP&quot;,&quot;l&quot;:&quot;Bucharest, Romania&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;BUD&quot;,&quot;l&quot;:&quot;Budapest, Hungary&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;KIV&quot;,&quot;l&quot;:&quot;Chișinău, Moldova&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;CPH&quot;,&quot;l&quot;:&quot;Copenhagen, Denmark&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;ORK&quot;,&quot;l&quot;:&quot;Cork, Ireland&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;DUB&quot;,&quot;l&quot;:&quot;Dublin, Ireland&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;DUS&quot;,&quot;l&quot;:&quot;Düsseldorf, Germany&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;EDI&quot;,&quot;l&quot;:&quot;Edinburgh, United Kingdom&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;FRA&quot;,&quot;l&quot;:&quot;Frankfurt, Germany&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;GVA&quot;,&quot;l&quot;:&quot;Geneva, Switzerland&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;GOT&quot;,&quot;l&quot;:&quot;Gothenburg, Sweden&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;HAM&quot;,&quot;l&quot;:&quot;Hamburg, Germany&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;HEL&quot;,&quot;l&quot;:&quot;Helsinki, Finland&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;IST&quot;,&quot;l&quot;:&quot;Istanbul, Turkey&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;KBP&quot;,&quot;l&quot;:&quot;Kyiv, Ukraine&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;LIS&quot;,&quot;l&quot;:&quot;Lisbon, Portugal&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;LHR&quot;,&quot;l&quot;:&quot;London, United Kingdom&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;LUX&quot;,&quot;l&quot;:&quot;Luxembourg City, Luxembourg&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;MAD&quot;,&quot;l&quot;:&quot;Madrid, Spain&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;MAN&quot;,&quot;l&quot;:&quot;Manchester, United Kingdom&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;MRS&quot;,&quot;l&quot;:&quot;Marseille, France&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;MXP&quot;,&quot;l&quot;:&quot;Milan, Italy&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;DME&quot;,&quot;l&quot;:&quot;Moscow, Russia&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;MUC&quot;,&quot;l&quot;:&quot;Munich, Germany&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;LCA&quot;,&quot;l&quot;:&quot;Nicosia, Cyprus&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;OSL&quot;,&quot;l&quot;:&quot;Oslo, Norway&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;CDG&quot;,&quot;l&quot;:&quot;Paris, France&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;PRG&quot;,&quot;l&quot;:&quot;Prague, Czech Republic&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;KEF&quot;,&quot;l&quot;:&quot;Reykjavík, Iceland&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;RIX&quot;,&quot;l&quot;:&quot;Riga, Latvia&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;FCO&quot;,&quot;l&quot;:&quot;Rome, Italy&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;LED&quot;,&quot;l&quot;:&quot;Saint Petersburg, Russia&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;SOF&quot;,&quot;l&quot;:&quot;Sofia, Bulgaria&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;ARN&quot;,&quot;l&quot;:&quot;Stockholm, Sweden&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;TLL&quot;,&quot;l&quot;:&quot;Tallinn, Estonia&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;SKG&quot;,&quot;l&quot;:&quot;Thessaloniki, Greece&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;VIE&quot;,&quot;l&quot;:&quot;Vienna, Austria&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;VNO&quot;,&quot;l&quot;:&quot;Vilnius, Lithuania&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;WAW&quot;,&quot;l&quot;:&quot;Warsaw, Poland&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;ZAG&quot;,&quot;l&quot;:&quot;Zagreb, Croatia&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;ZRH&quot;,&quot;l&quot;:&quot;Zürich, Switzerland&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;ARI&quot;,&quot;l&quot;:&quot;Arica, Chile&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;ASU&quot;,&quot;l&quot;:&quot;Asunción, Paraguay&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;BOG&quot;,&quot;l&quot;:&quot;Bogotá, Colombia&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;EZE&quot;,&quot;l&quot;:&quot;Buenos Aires, Argentina&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;CWB&quot;,&quot;l&quot;:&quot;Curitiba, Brazil&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;FOR&quot;,&quot;l&quot;:&quot;Fortaleza, Brazil&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;GUA&quot;,&quot;l&quot;:&quot;Guatemala City, Guatemala&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;LIM&quot;,&quot;l&quot;:&quot;Lima, Peru&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;MDE&quot;,&quot;l&quot;:&quot;Medellín, Colombia&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;PTY&quot;,&quot;l&quot;:&quot;Panama City, Panama&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;POA&quot;,&quot;l&quot;:&quot;Porto Alegre, Brazil&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;UIO&quot;,&quot;l&quot;:&quot;Quito, Ecuador&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;GIG&quot;,&quot;l&quot;:&quot;Rio de Janeiro, Brazil&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;GRU&quot;,&quot;l&quot;:&quot;São Paulo, Brazil&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;SCL&quot;,&quot;l&quot;:&quot;Santiago, Chile&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;CUR&quot;,&quot;l&quot;:&quot;Willemstad, Curaçao&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;GND&quot;,&quot;l&quot;:&quot;St. George‘s, Grenada&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;AMM&quot;,&quot;l&quot;:&quot;Amman, Jordan&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;BGW&quot;,&quot;l&quot;:&quot;Baghdad, Iraq&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;GYD&quot;,&quot;l&quot;:&quot;Baku, Azerbaijan&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;BEY&quot;,&quot;l&quot;:&quot;Beirut, Lebanon&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;DOH&quot;,&quot;l&quot;:&quot;Doha, Qatar&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;DXB&quot;,&quot;l&quot;:&quot;Dubai, United Arab Emirates&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;KWI&quot;,&quot;l&quot;:&quot;Kuwait City, Kuwait&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;BAH&quot;,&quot;l&quot;:&quot;Manama, Bahrain&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;MCT&quot;,&quot;l&quot;:&quot;Muscat, Oman&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;ZDM&quot;,&quot;l&quot;:&quot;Ramallah&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;RUH&quot;,&quot;l&quot;:&quot;Riyadh, Saudi Arabia&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;TLV&quot;,&quot;l&quot;:&quot;Tel Aviv, Israel&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;IAD&quot;,&quot;l&quot;:&quot;Ashburn, VA, United States&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;ATL&quot;,&quot;l&quot;:&quot;Atlanta, GA, United States&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;BOS&quot;,&quot;l&quot;:&quot;Boston, MA, United States&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;BUF&quot;,&quot;l&quot;:&quot;Buffalo, NY, United States&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;YYC&quot;,&quot;l&quot;:&quot;Calgary, AB, Canada&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;CLT&quot;,&quot;l&quot;:&quot;Charlotte, NC, United States&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;ORD&quot;,&quot;l&quot;:&quot;Chicago, IL, United States&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;CMH&quot;,&quot;l&quot;:&quot;Columbus, OH, United States&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;DFW&quot;,&quot;l&quot;:&quot;Dallas, TX, United States&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;DEN&quot;,&quot;l&quot;:&quot;Denver, CO, United States&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;DTW&quot;,&quot;l&quot;:&quot;Detroit, MI, United States&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;HNL&quot;,&quot;l&quot;:&quot;Honolulu, HI, United States&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;IAH&quot;,&quot;l&quot;:&quot;Houston, TX, United States&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;IND&quot;,&quot;l&quot;:&quot;Indianapolis, IN, United States&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;JAX&quot;,&quot;l&quot;:&quot;Jacksonville, FL, United States&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;MCI&quot;,&quot;l&quot;:&quot;Kansas City, MO, United States&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;LAS&quot;,&quot;l&quot;:&quot;Las Vegas, NV, United States&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;LAX&quot;,&quot;l&quot;:&quot;Los Angeles, CA, United States&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;MFE&quot;,&quot;l&quot;:&quot;McAllen, TX, United States&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;MEM&quot;,&quot;l&quot;:&quot;Memphis, TN, United States&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;MEX&quot;,&quot;l&quot;:&quot;Mexico City, Mexico&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;MIA&quot;,&quot;l&quot;:&quot;Miami, FL, United States&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;MSP&quot;,&quot;l&quot;:&quot;Minneapolis, MN, United States&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;MGM&quot;,&quot;l&quot;:&quot;Montgomery, AL, United States&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;YUL&quot;,&quot;l&quot;:&quot;Montréal, QC, Canada&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;BNA&quot;,&quot;l&quot;:&quot;Nashville, TN, United States&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;EWR&quot;,&quot;l&quot;:&quot;Newark, NJ, United States&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;ORF&quot;,&quot;l&quot;:&quot;Norfolk, VA, United States&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;OMA&quot;,&quot;l&quot;:&quot;Omaha, NE, United States&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;PHL&quot;,&quot;l&quot;:&quot;Philadelphia, United States&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;PHX&quot;,&quot;l&quot;:&quot;Phoenix, AZ, United States&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;PIT&quot;,&quot;l&quot;:&quot;Pittsburgh, PA, United States&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;PAP&quot;,&quot;l&quot;:&quot;Port-Au-Prince, Haiti&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;PDX&quot;,&quot;l&quot;:&quot;Portland, OR, United States&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;QRO&quot;,&quot;l&quot;:&quot;Queretaro, MX, Mexico&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;RIC&quot;,&quot;l&quot;:&quot;Richmond, Virginia&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;SMF&quot;,&quot;l&quot;:&quot;Sacramento, CA, United States&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;SLC&quot;,&quot;l&quot;:&quot;Salt Lake City, UT, United States&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;SAN&quot;,&quot;l&quot;:&quot;San Diego, CA, United States&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;SJC&quot;,&quot;l&quot;:&quot;San Jose, CA, United States&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;YXE&quot;,&quot;l&quot;:&quot;Saskatoon, SK, Canada&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;SEA&quot;,&quot;l&quot;:&quot;Seattle, WA, United States&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;STL&quot;,&quot;l&quot;:&quot;St. Louis, MO, United States&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;TPA&quot;,&quot;l&quot;:&quot;Tampa, FL, United States&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;YYZ&quot;,&quot;l&quot;:&quot;Toronto, ON, Canada&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;YVR&quot;,&quot;l&quot;:&quot;Vancouver, BC, Canada&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;TLH&quot;,&quot;l&quot;:&quot;Tallahassee, FL, United States&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;YWG&quot;,&quot;l&quot;:&quot;Winnipeg, MB, Canada&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;ADL&quot;,&quot;l&quot;:&quot;Adelaide, SA, Australia&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;AKL&quot;,&quot;l&quot;:&quot;Auckland, New Zealand&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;BNE&quot;,&quot;l&quot;:&quot;Brisbane, QLD, Australia&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;MEL&quot;,&quot;l&quot;:&quot;Melbourne, VIC, Australia&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;NOU&quot;,&quot;l&quot;:&quot;Noumea, New caledonia&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;PER&quot;,&quot;l&quot;:&quot;Perth, WA, Australia&quot;&#125;&#x27;,&#x27;&#123;&quot;s&quot;:&quot;SYD&quot;,&quot;l&quot;:&quot;Sydney, NSW, Australia&quot;&#125;&#x27;];let area = data.split(&quot;colo=&quot;)[1].split(&quot;\n&quot;)[0];for (var i = 0; i &lt; areas.length; i++) &#123;const as = JSON.parse(areas[i]);if (as.s == area) &#123;document.getElementById(&quot;cdn&quot;).innerHTML = as.l;break;&#125;&#125;&#125;&#125;));</span><br></pre></td></tr></table></figure>
<p>在想要呈现节点信息的地方添加<code>&lt;span id=&quot;cdn&quot;&gt;&lt;/span&gt;</code>即可，比如上方第一步<code>添加各种小徽标</code>中</p>
</li>
<li>
<p>参考</p>
<ul>
<li><a href="https://blog.moraxyc.com/post/ad876c0e/">博客显示当前Cloudflare CDN节点，让界面更炫酷 - Moraxyc’s Rhapsody</a></li>
</ul>
</li>
</ol>
</div></details>
]]></content>
      <categories>
        <category>教程</category>
        <category>Hexo</category>
        <category>Butterfly</category>
      </categories>
      <tags>
        <tag>Butterfly</tag>
        <tag>美化</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言学习二：运算符</title>
    <url>/2023/10/22/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E4%BA%8C%EF%BC%9A%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    <content><![CDATA[<h2 id="算术运算符">算术运算符</h2>
<p><code>+</code>                加法运算，一目取正<br>
<code>-</code>                减法运算，一目取负<br>
<code>*</code>                乘法运算<br>
<code>/</code>                除法运算<br>
<code>%</code>                取模（求余）<br>
<code>++</code>              自加 1                             a++（再参与表达式的运算，在自加） , ++a （先自加）<br>
<code>--</code>              自减 1</p>
<p><mark>注意：</mark></p>
<ul>
<li>减号也是一个负号表示取反， a = -100 , -a -&gt; 100</li>
<li>取模运算的左右两个操作数必须是<font color="#ff0000">整型的</font>  （5%3）</li>
<li>自加，自减既可以操作<font color="#ff0000">整型</font>也可以操作<font color="#ff0000">浮点</font>，也可以操作<font color="#ff0000">指针</font></li>
<li>前缀（++a） ： 先进行自加/自减的运算，然后再参与表达式的运算</li>
<li>后缀（a++）： 先参与表达式的运算，然后再进行自加/自减的运算</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int a = 5 ;</span><br><span class="line">int c = 3 ;</span><br><span class="line"></span><br><span class="line">printf(&quot;5/3 = %d , 5%%3 = %d \n &quot; ,a/c , a%c);     //两个%%---&gt;防止识别为格式控制符</span><br><span class="line"></span><br><span class="line">printf(&quot;a++:%d\n&quot;, a++); // 5 --&gt;先打印5，在加一为6</span><br><span class="line">printf(&quot;++a:%d\n&quot;, ++a); // 7 --&gt;经过上面a++后a已经变成了6，这一步先加一变成7，在打印</span><br></pre></td></tr></table></figure>
<h2 id="关系运算符">关系运算符</h2>
<p><code>&gt;</code>           大于                     a&gt; b 判断 a 是否大于 b ，该表达式的值为布尔值<br>
<code>&lt;</code>           小于<br>
<code>&gt;=</code>         大于等于              a &gt;= b 判断 a 是否大于或者等于 b , 该表达式的值为布尔值（表达式中<font color="#ff0000">只要</font>a 是大于<font color="#ff0000">或者</font>等于b 表达式都为真）<br>
<code>&lt;=</code>         小于等于<br>
<code>==</code>         等于                     a == b 判断是否相等<br>
<code>！=</code>        不等于                 a != b 判断是否不相等</p>
<p><mark>注意：</mark></p>
<ul>
<li>判断两个数是否相等使用的<code>==</code>, 是两个等号，而不是一个</li>
<li>关系运算符的表达式值为布尔值</li>
<li>在数学中 100&lt; a &lt;200 , 在代码中需要拆开 ， a &gt; 100 &amp;&amp; a &lt; 200</li>
</ul>
<h2 id="逻辑运算符">逻辑运算符</h2>
<p><code>！</code>           <font color="#ff0000">逻辑反</font>                !(x&gt;9) 如果 x 确实大于 9 则整个表达式为假，反之为真<br>
<code>&amp;&amp;</code>          逻辑与              （ a &gt; 100 &amp;&amp; a &lt; 200 ） 该表达式两边同时为真则为真， 如果其中一个为假则整个表达式为 假<br>
<code>||</code>            逻辑或            （ a &gt; 100 || a &lt; 200 ） 该表达式中<font color="#ff0000">其中一个</font>为真则整个表达式为真</p>
<p><mark>注意：</mark></p>
<ul>
<li>
<p>在<font color="#ff0000">逻辑与</font>的运算中，如果左边为假则直接判断为假，右边的表达式将不会执行</p>
</li>
<li>
<p>在<font color="#ff0000">逻辑或</font>的运算中，如果左边为真则表达式直接判断为真，右边的表达式将不会执行</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int a = 100 ;</span><br><span class="line">int b = 200;</span><br><span class="line"></span><br><span class="line">if (a &lt; 50 &amp;&amp; (b = b + 300)); // 左边为假， 右边不被执行</span><br><span class="line">printf(&quot;a=%d , b=%d\n&quot; , a , b ); // a = 100 , b = 200</span><br><span class="line"></span><br><span class="line">if (a &gt; 50 || (b = b + 300)); //左边为真 ，右边不被执行</span><br><span class="line">printf(&quot;a=%d , b=%d\n&quot; , a , b ); // a = 100 , b = 200</span><br></pre></td></tr></table></figure>
<h2 id="位运算符">位运算符</h2>
<p><code>~</code>             位逻辑反</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int a = 3 ;</span><br><span class="line"></span><br><span class="line">a ‐&gt; 0000 0000 0000 0000 0000 0000 0000 0011     //3的二进制数</span><br><span class="line">~a ‐&gt; 1111 1111 1111 1111 1111 1111 1111 1100    //取反</span><br></pre></td></tr></table></figure>
<p><code>&amp;</code>             位逻辑与            <font color="#ff0000">有零得零 --&gt; 清零操作</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int a = 3 ;</span><br><span class="line">int b = 5 ;</span><br><span class="line"></span><br><span class="line">a:0011    //没写全，实际为：a ‐&gt; 0000 0000 0000 0000 0000 0000 0000 0011</span><br><span class="line">b:0101    //没写全，实际为：b ‐&gt; 0000 0000 0000 0000 0000 0000 0000 0101</span><br><span class="line">a&amp;b : 0001    //没写全，实际为：a&amp;b ‐&gt; 0000 0000 0000 0000 0000 0000 0000 0001</span><br></pre></td></tr></table></figure>
<p><code>|</code>             位逻辑或             <font color="#ff0000">有一得一  --&gt; 置1 操作</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int a = 3 ;</span><br><span class="line">int b = 5 ;</span><br><span class="line"></span><br><span class="line">a:0011</span><br><span class="line">b:0101</span><br><span class="line">a|b : 0111</span><br></pre></td></tr></table></figure>
<p><code>^</code>             位逻辑异或        <font color="#ff0000"> 相同得0 ，不同得1</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int a = 3 ;</span><br><span class="line">int b = 5 ;</span><br><span class="line"></span><br><span class="line">a:0011</span><br><span class="line">b:0101</span><br><span class="line">a^b : 0110</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int a = 5 ;</span><br><span class="line">int b = 3 ;</span><br><span class="line">int c = a ^ b ;</span><br><span class="line"></span><br><span class="line">printf(&quot;c:%d\n&quot; , c ); // 6</span><br><span class="line">printf(&quot;c^a:%d\n&quot; , c^a ); // 3 ‐‐&gt; b</span><br><span class="line">printf(&quot;c^b:%d\n&quot; , c^b ); // 5 ‐‐&gt; a</span><br></pre></td></tr></table></figure>
<p><code>&lt;&lt;</code>            左移</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int a = 3 ;</span><br><span class="line"></span><br><span class="line">a ‐&gt; 0000 0000 0000 0000 0000 0000 0000 0011</span><br><span class="line">a&lt;&lt;4 ‐&gt;0000 0000 0000 0000 0000 0000 0011 0000</span><br></pre></td></tr></table></figure>
<p><img src="https://v3.wmnzsx.eu.org/i/1/2023/11/24/114t8jw-1.webp" alt="C-count1"></p>
<p><code>&gt;&gt;</code>            右移</p>
<p><img src="https://v3.wmnzsx.eu.org/i/1/2023/11/24/114t5qm-1.webp" alt="C-count2"></p>
<p><mark>注意：</mark></p>
<ul>
<li>
<p>位运算符操作的是操作数的每一个二进制位</p>
</li>
<li>
<p>位逻辑反，实际上是对操作数的每一个二进制位进行取反， 0与1之间对调</p>
</li>
<li>
<p>异或运算，相同得 0 ，不同得1</p>
</li>
<li>
<p>位移，移出去的丢弃，空出来的补0<br>
如果移动是一个有符号的数据（正负），并右移运算时，移出去丢弃，空出来补符号位</p>
</li>
</ul>
<h2 id="特殊运算符">特殊运算符</h2>
<h3 id="赋值运算符-（左值-右值）">赋值运算符 <code>=</code> （左值=右值）</h3>
<ul>
<li>
<p>左值不能是常量 ,比如100 = a ；</p>
</li>
<li>
<p>不能直接对数组赋值</p>
</li>
<li>
<p>可以使用连续赋值 a = b = c = d = 100 ;</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int a , b ;</span><br><span class="line">int x[5] ;</span><br><span class="line"></span><br><span class="line">100 = a ;// 错， 左值不能是常量</span><br><span class="line">a = 100 ; // 正确， 对变量a进行赋值</span><br><span class="line">x = 123 ; // 错， 数组不可以这么赋值</span><br><span class="line">a = b = 100 ; // 正确 ， 连续赋值， 先把100 赋值给 b , 然后再把 b 赋值给a</span><br></pre></td></tr></table></figure>
<h3 id="复合运算符">复合运算符</h3>
<p>当左右两边有相同的操作数时，可以使用符合运算符，使得代码看起来更加简明，且可以在一定程度上提高效率。</p>
<p>只有以下<font color="#ff0000">十种</font>复合运算符：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 加减乘除</span><br><span class="line">a += b ;// 相当于 a = a + b ;</span><br><span class="line">a ‐= b ;</span><br><span class="line">a *= b ;</span><br><span class="line">a /= b ;</span><br><span class="line"></span><br><span class="line">// 求余</span><br><span class="line">a %= b ; // 相当于 a = a % b ;</span><br><span class="line"></span><br><span class="line">// 位运算</span><br><span class="line">a &amp;= b ; // 相当于 a = a &amp; b ;</span><br><span class="line">a |= b ;</span><br><span class="line">a ^= b ;</span><br><span class="line">a &gt;&gt;= b ;</span><br><span class="line">a &lt;&lt;= b ;</span><br></pre></td></tr></table></figure>
<h3 id="条件运算符（三目运算符）">条件运算符（三目运算符）</h3>
<ul>
<li>唯一一个需要三个操作数的运算符（表达式）</li>
<li>语法： <code>表达式1 ？ 表达式2 : 表达式3</code></li>
<li>如果表达式1的值为真，则整个表达式的值为表达式2 ，冒号左边</li>
<li>如果表达式1的值为假，则整个表达式的值为表达式3 ，冒号右边</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int a = 100 ;</span><br><span class="line">int b = 250 ;</span><br><span class="line"></span><br><span class="line">int max = a &gt; b ? a : b ;  //为假，整个表达式的值为表达式3，即b</span><br></pre></td></tr></table></figure>
<h3 id="sizeof-运算符">sizeof 运算符</h3>
<blockquote>
<p>该运算符看起来很像一个函数，不要忘记它实际只是一个运算符，用来计算指定的变量或变量类型从而得到他在内存中所需要占用的字节</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 求变量类型</span><br><span class="line">printf (&quot;sizof(long):%ld\n&quot; , sizof(long) ); // 计算long 类型的大小 （得知系统的字长）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 求变量</span><br><span class="line">int a ;</span><br><span class="line">printf (&quot;sizof(a):%ld\n&quot; , sizof(a) ); // 计算变量 a 的大小</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 计算数组的大小</span><br><span class="line">int buf [5];</span><br><span class="line">printf (&quot;sizof(buf):%ld\n&quot; , sizof(buf) ); //计算数组 buf 的大小，5乘以int类型的字节4，即为20</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 计算结构体大小</span><br><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line">int a ; //4</span><br><span class="line">char b ; // 1</span><br><span class="line">double c ; // 8</span><br><span class="line">&#125;;</span><br><span class="line">printf(&quot;sizeof(struct node):%ld\n&quot; ,sizeof(struct node) );// 16</span><br></pre></td></tr></table></figure>
<h3 id="return-运算符">return 运算符</h3>
<p>含义：退出某一个函数（如果是在主函数遇到 return，则退出程序，进程结束；如果不是主函数，则返回到被调用的位置）</p>
<p>语法：必须出现在函数体内部，可以携带对应类型的值，进行返回</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line"> return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="优先级与结合性">优先级与结合性</h3>
<p>当一个表达式中同时出现了多个运算符时，根据优先级以及结合性进行运算，比如先乘除后加减</p>
<p>优先级：<code>man operator</code><br>
<img src="https://v3.wmnzsx.eu.org/i/1/2023/11/24/114sw2m-1.webp" alt="C-count3"></p>
<h3 id="逗号表达式">逗号表达式</h3>
<blockquote>
<p>语法 ： 表达式1 = （表达式2 ，表达式3 ，表达式4 ， … , 表达式 n ）；</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int a = 10 ;</span><br><span class="line">int c = 250 ;</span><br><span class="line"></span><br><span class="line">//对应下面 11  261= 11+250 261</span><br><span class="line">int b = (a++ , a = a + c , a , 300 );</span><br><span class="line"></span><br><span class="line">printf(&quot;b:%d\n&quot; , b );</span><br><span class="line">printf(&quot;a:%d\n&quot; , a );</span><br><span class="line"></span><br><span class="line">//输出结果：</span><br><span class="line">b:300</span><br><span class="line">a:261</span><br></pre></td></tr></table></figure>
<p><mark>注意：</mark></p>
<ul>
<li>逗号表达式中，会从左往右依次运算每一一个表达式</li>
<li>整个表达式的值取决于最后一个表达式的值</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言学习三：控制流</title>
    <url>/2023/10/22/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E4%B8%89%EF%BC%9A%E6%8E%A7%E5%88%B6%E6%B5%81/</url>
    <content><![CDATA[<h2 id="二路分支-：if-语句">二路分支 ：if 语句</h2>
<ul>
<li>逻辑： 程序中某一段代码需要满足一定的条件才会被执行</li>
<li>语法：
<ul>
<li>if 语句： 表达一种，如果条件满足则执行某个代码块</li>
<li>if-else 语句： 表达一种，如果条件将满足则执行某个代码块否则执行另外一个代码块</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//if 语句：</span><br><span class="line">int a = 100 ;</span><br><span class="line">if ( a &gt; 100 )//判断条件</span><br><span class="line">&#123;</span><br><span class="line">/* 如果满足则执行该代码块 */</span><br><span class="line">printf(&quot;啊啊啊！\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// if ‐ else 语句</span><br><span class="line">if (a &lt; 99 )</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;哦哦哦！！\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;噢噢噢！！\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// if‐ esle if ‐ esle if ‐ else</span><br><span class="line">if (a &lt; 99 )</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;啊啊啊！！！\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">else if (a &gt; 99 )</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;哦哦哦！！！\n&quot;);</span><br><span class="line">&#125;else</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;噢噢噢！！！\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><mark>注意：</mark><br>
if 语句可以单独使用，但是 else 不可以单独使用，必须在 if 后面配套使用，不管是 if 还是 else ，都建议给他们配一对大括号 { } ，否则需要注意，只能识别 if / esle 后面的第一个逻辑行的语句</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (a &gt; 1)</span><br><span class="line">printf(&quot;Hello\n&quot;); // if的第一个逻辑行，能识别</span><br><span class="line">else</span><br><span class="line">printf(&quot;hi\n&quot;);// else 的第一个逻辑行，能识别</span><br><span class="line">printf(&quot;abc\n&quot;); // 注意此行代码已经不在else的管辖范围内，不能识别</span><br></pre></td></tr></table></figure>
<h2 id="多路分支：switch-case">多路分支：switch-case</h2>
<ul>
<li>逻辑： 根据不同的条件来执行不同的代码块</li>
<li>语法：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">switch (表达式&lt;判断的条件&gt;)</span><br><span class="line">&#123;</span><br><span class="line">case &lt;常量1&gt; :</span><br><span class="line">// 代码块 1</span><br><span class="line">break ;</span><br><span class="line"></span><br><span class="line">case &lt;常量2&gt; :</span><br><span class="line">// 代码块 2</span><br><span class="line">break ;</span><br><span class="line"></span><br><span class="line">case &lt;常量3&gt; :</span><br><span class="line">// 代码块 3</span><br><span class="line">break ;</span><br><span class="line"></span><br><span class="line">default :</span><br><span class="line">// 代码块 N</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int num = 0;</span><br><span class="line">printf(&quot;请输入数字\n&quot;);</span><br><span class="line">scanf(&quot;%d&quot;, &amp;num);</span><br><span class="line">while (getchar() != &#x27;\n&#x27;); // 清空标准输入缓冲区</span><br><span class="line"></span><br><span class="line">switch (num)</span><br><span class="line">&#123;</span><br><span class="line">case 1:</span><br><span class="line">    printf(&quot;啊\n&quot;);</span><br><span class="line">    break;</span><br><span class="line">  </span><br><span class="line">case 2:</span><br><span class="line">    printf(&quot;哦\n&quot;);</span><br><span class="line">    break;</span><br><span class="line"></span><br><span class="line">case 3:</span><br><span class="line">    printf(&quot;噢\n&quot;);</span><br><span class="line">    break;</span><br><span class="line">  </span><br><span class="line">default:</span><br><span class="line">    printf(&quot;咦\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><mark>注意：</mark></p>
<ul>
<li>switch(num )语句中的 num , 它必须是一个整型的表达式，也就是所switch 只能判断整型的数据</li>
<li>case 语句中的必须是整型常量，包括普通的<font color="#ff0000">字符</font>。不包括被 const 修改的整型数据</li>
<li>break 用来中断/跳出当前的循环。如果没有则会从条件满足的语句开始一条一条的往下执行，直到整个switch - case 结束或者遇到其它代码块中的break</li>
<li>default 并不是必须存在，它一般放在最后面，用来提示用户表示都不满足以上条件。由于在最后面可以不添加 break</li>
</ul>
<h2 id="const">const</h2>
<p>用来修饰一个变量使之不可被修改</p>
<ul>
<li>
<p>作用：</p>
<ul>
<li>修饰变量： 使得变量不能被修改</li>
<li>修饰指针：使得指针的指向不能改变或者指针所指向的内容不得改变</li>
</ul>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int const a = 100 ; // 定义了一个不可被修改的变量a</span><br><span class="line">const int b = 200;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = 300 ; // 错误 assignment of read‐only variable ‘a’</span><br><span class="line">b = 250 ; // 错误 assignment of read‐only variable ‘a’</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="while-和-do…while-循环">while 和 do…while 循环</h2>
<h3 id="while">while</h3>
<p>逻辑： 使得程序中某一端代码块重复循环执行。<br>
语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while( 表达式 )</span><br><span class="line">&#123;</span><br><span class="line">// 代码块</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://v3.wmnzsx.eu.org/i/1/2023/11/24/115vgff-1.webp" alt="C-control1"></p>
<p>例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while(num) // 非零则真 （布尔值）</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;num:%d\n&quot; , num‐‐ );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="do-…-while">do … while</h3>
<p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">do</span><br><span class="line">&#123;</span><br><span class="line">// 代码块</span><br><span class="line">&#125;while(表达式);</span><br></pre></td></tr></table></figure>
<p><img src="https://v3.wmnzsx.eu.org/i/1/2023/11/24/115uyng-1.webp" alt="C-control2"></p>
<p>例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">do</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;num:%d\n&quot; , num-- );</span><br><span class="line">&#125; while (num);</span><br></pre></td></tr></table></figure>
<h3 id="注意">注意</h3>
<ul>
<li>wehile 循环先进行判断而且条件为真，然后再执行代码块（有可能一次都不执行）</li>
<li>do … while 则是先执行一次代码块，然后再判断条件是否成立（最少会执行一次代码块）</li>
<li>while(num); --&gt; 空循环这个分号要慎重</li>
<li>do… While (num) ; 这个分号不能丢</li>
</ul>
<h2 id="for-循环">for 循环</h2>
<p>逻辑： 与 while 类似，都是让程序中某一段代码块重复运行，但是 for 相对与 while 来说更加紧凑。把所有的循环控制都集中到一行代码中</p>
<p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for(初始化语句 ; 判断语句 ; 表达式 (一般用于自加/自减))</span><br><span class="line">&#123;</span><br><span class="line">// 代码块</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (size_t i = 0; i &lt; num ; ++i)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;i:%ld\n&quot; , i );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (;;) // 相当与 while(1)死循环</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;i:%d\n&quot; , i );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><mark>注意：</mark></p>
<ul>
<li>初始化语句只会被执行一次</li>
<li>第三个表达式 <code>++i</code> 再第一次循环的时候并没有被执行</li>
<li>第三个表达式中前缀/后缀并不影响 <code>i</code> 再循环中取值的先后</li>
<li>for 循环语句中，三个表达式都可以省略，但是分号<font color="#ff0000">必须</font>留下</li>
<li>for 循环语句中，三个表达式中间用分号来隔开 ;</li>
<li>在 for 循环中直接定义并初始化只在 C99的编译规则下可以这么干，所以可以添加 <code>-std=c 99</code> 或者 <code>-std=gnu 99</code></li>
</ul>
<h2 id="break-与-continue">break 与 continue</h2>
<ul>
<li>break: 跳出循环结构 / 跳出当前层的循环</li>
<li>continue : 结束当前这一次循环，重新进入下一次的循环</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (int i = 0; i &lt; num; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    while (1) // 在循环体内部可以嵌套其它的循环</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;啊！\n&quot;);</span><br><span class="line">        break; // 跳出while这一层循环， 并不影响外面的for循环</span><br><span class="line">    &#125;</span><br><span class="line">    if (i == 5)</span><br><span class="line">    &#123;</span><br><span class="line">        continue; // 跳过当前这一次循环， 导致后面的代码在当次循环中不执行</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;i:%d\n&quot;, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="goto-语句">goto 语句</h2>
<p>逻辑： 无条件跳转<br>
语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">标签：</span><br><span class="line">//代码块</span><br><span class="line"></span><br><span class="line">goto 标签;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    int num = 0;</span><br><span class="line">    printf(&quot;请输入数字\n&quot;);</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;num);</span><br><span class="line">    while (getchar() != &#x27;\n&#x27;); // 清空标准输入缓冲区</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">    for (int i = 0; i &lt; num; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        goto baioqian; // 无条件跳转到标签为 baioqian 的位置</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">baioqian:</span><br><span class="line">    printf(&quot;这里是标签的位置!!!\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><mark>注意：</mark></p>
<ul>
<li>标签后面有个冒号 <code>:</code></li>
<li>goto 语句是一个无条件跳转的语句，不利于程序的可读性，一般不建议使用</li>
<li>goto 语句一般出现在驱动比较多，用来处理严重的错误，并退出</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言学习五：指针</title>
    <url>/2023/10/22/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E4%BA%94%EF%BC%9A%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<h2 id="指针入门">指针入门</h2>
<h3 id="基础知识">基础知识</h3>
<h4 id="内存地址">内存地址</h4>
<ul>
<li>字节： 字节是内存容量的一个单位， <code>byte</code> ，一个字节 <code>byte</code> 有 <code>8</code>个位 <code>bit</code></li>
<li>地址： 系统为了方便区分每一个字节的数据，而对内存进行了逐一编号，而该编号就是内存地址。</li>
</ul>
<p><img src="https://v3.wmnzsx.eu.org/i/1/2023/11/24/117cf2l-1.webp" alt="C-pointer1"></p>
<h4 id="基地址">基地址</h4>
<ul>
<li>单字节的数据： <code>char</code> 它所在地址的编号就是该数据的地址</li>
<li>多字节的数据：<code>int</code> 它拥有<code>4</code>个连续的地址的编号 ，其中地址值最小的称为该量的地址</li>
</ul>
<p><img src="https://v3.wmnzsx.eu.org/i/1/2023/11/24/117cdqg-1.webp" alt="C-pointer2"></p>
<h4 id="取地址符号">取地址符号</h4>
<p>每一个变量其实都对应了一片内存，因此都可以通过 &amp; 取地址符号将其地址获得。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int i ;</span><br><span class="line">double d;</span><br><span class="line">float f ;</span><br><span class="line">char c ;</span><br><span class="line">    </span><br><span class="line">printf(&quot;i的地址为:%p\n&quot; , &amp;i);</span><br><span class="line">printf(&quot;d的地址为:%p\n&quot; , &amp;d);</span><br><span class="line">printf(&quot;f的地址为:%p\n&quot; , &amp;f);</span><br><span class="line">printf(&quot;c的地址为:%p\n&quot; , &amp;c);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//运行结果：</span><br><span class="line">i的地址为:0x7ffec726bc58</span><br><span class="line">d的地址为:0x7ffec726bc60</span><br><span class="line">f的地址为:0x7ffec726bc5c</span><br><span class="line">c的地址为:0x7ffec726bc57</span><br></pre></td></tr></table></figure>
<p><img src="https://v3.wmnzsx.eu.org/i/1/2023/11/24/117cm8y-1.webp" alt="C-pointer3"></p>
<p><mark>注意：</mark></p>
<ul>
<li>虽然不同的数据类型所占用的内存空间不同，但是他们的地址所占用的内存空间（地址的大小= 指针的大小）是恒定的，由系统的位数来决定 32位 / 64位</li>
<li>不同的地址他从表面上看似乎没有什么差别，但是由他们所代表的内存的尺寸是不一样的（由内存中所存放的数据类型相关），因此我们在访问这些地址的时候需要严格区分它们的逻辑关系。</li>
</ul>
<h3 id="指针的基础">指针的基础</h3>
<ol>
<li>
<p>概念：<code>&amp;a</code> 就是 <code>a</code> 的地址，实质上也可以理解为他是一个指针，用来指向 <code>a</code> 的地址。专门用来存放地址的一个变量，因此指针的大小是恒定的，由系统的<font color="#ff0000">位数</font>来决定。</p>
</li>
<li>
<p>指针的定义语法</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int a ; // 定义一片内存名字叫 a ， 约定好该内存用来存放 整型数据</span><br><span class="line">int * p ; // 定义一片内存名字叫 p ， 约定好该内存用来存放 整型数据的地址</span><br><span class="line">char * p1 ; // 定义一片内存名字叫 p1 ， 约定好该内存用来存放 字符数据的地址</span><br><span class="line">double * p2 ; // 定义一片内存名字叫 p2 ， 约定好该内存用来存放 双精度数据的地址</span><br></pre></td></tr></table></figure>
<p><mark>注意：</mark></p>
<p>指针的类型，并不是用来决定该指针的大小,而是用来告诉编译器如果我们通过该指针来访问内存时需要访问的<font color="#ff0000">内存的大小尺寸</font>。</p>
</li>
<li>
<p>指针的赋值以及初始化</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int a = 100 ;</span><br><span class="line">int * p = &amp;a ; // 定义并初始化</span><br><span class="line">  </span><br><span class="line">double d = 1024.1234 ;</span><br><span class="line">double * p1 = &amp;d ;// 定义并初始化</span><br><span class="line">  </span><br><span class="line">float f ;</span><br><span class="line">float * p2 ;// 只定义，没有初始化</span><br><span class="line">p2 = &amp;f ; // 给指针赋值</span><br></pre></td></tr></table></figure>
<p><img src="https://v3.wmnzsx.eu.org/i/1/2023/11/24/117mwa3-1.webp" alt="C-pointer4"></p>
<blockquote>
<p>注意：指针自己也有一个地址</p>
</blockquote>
<p><mark>注意：</mark></p>
<p>不同类型的指针，应该用来指向与其相对应的类型的变量的地址。</p>
</li>
<li>
<p>指针的索引</p>
<p>通过指针获得它所指向的数据（<font color="#ff0000">解引用/取目标</font>）</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int a = 100 ;</span><br><span class="line">int * p = &amp;a ;</span><br><span class="line"></span><br><span class="line">*p = 250 ; // *p &lt;==&gt; a</span><br><span class="line"></span><br><span class="line">printf(&quot;*p:%d\n&quot; , *p) ;</span><br><span class="line">printf(&quot;a:%d\n&quot; , a) ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//运行结果</span><br><span class="line">*p:250</span><br><span class="line">a:250</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="野指针">野指针</h3>
<ol>
<li>
<p>概念：指向一块<font color="#ff0000">未知内存</font>的指针， 被称为野指针。</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int * p ;   //仅定义了，但没有初始化也没有给指针赋值</span><br></pre></td></tr></table></figure>
<p><img src="https://v3.wmnzsx.eu.org/i/1/2023/11/24/117c90t-1.webp" alt="C-pointer5"></p>
</li>
<li>
<p>危害：</p>
<ul>
<li>引用野指针的时候，很大概率我们会访问到一个非法内存，通常会出现段错误（Segmentation fault (core dumped)）并导致程序崩溃。</li>
<li>更加严重的后果，如果访问的时系统关键的数据，则有可能造成系统崩溃</li>
</ul>
</li>
<li>
<p>产生原因：</p>
<ul>
<li>定义时没有对他进行初始化</li>
<li>指向的内存被释放，系统已经回收后，该指针并没有重新初始化</li>
<li>指针越界</li>
</ul>
</li>
<li>
<p>如何防止：</p>
<ul>
<li>定义时记得对他进行初始化</li>
<li>绝对不去访问被回收的内存地址，当我们释放之后应该重新初始化该指针。</li>
<li>确认所申请的内存的大小，谨防越界</li>
</ul>
</li>
</ol>
<h3 id="空指针">空指针</h3>
<blockquote>
<p>在很多的情况下，我们一开始还不确定一个指针需要指向哪里，因此可以让该指针先指向一个不会破坏系统关键数据的位置，而这个位置一般就是 NULL （空）。因此指向该地址的指针都称之为空指针。</p>
</blockquote>
<p><img src="https://v3.wmnzsx.eu.org/i/1/2023/11/24/117m4dh-1.png" alt="C-pointer6"></p>
<p><strong>概念：</strong> 空指针就是保存了地址值为零的一个地址， 也就零地址NULL</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int * p1 = NULL ; // 定义一个指针， 并初始化为空指针（ 指向 NULL ）</span><br><span class="line">*p1 = 250 ; // 段错误 ， 该地址不允许写入任何东西</span><br><span class="line"></span><br><span class="line">printf(&quot;%p ‐‐ %d \n&quot; , NULL , NULL ); // （nul‐‐0）</span><br></pre></td></tr></table></figure>
<h3 id="指针运算">指针运算</h3>
<ul>
<li>指针的加法：意味着地址向上移动若干个目标 （指针的类型）</li>
<li>指针的减法：意味着地址向下移动若干个目标 （指针的类型）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">long l ;     //long int</span><br><span class="line">long *p = &amp;l ;</span><br><span class="line"></span><br><span class="line">int i ;</span><br><span class="line">int * p1 = &amp;i;</span><br><span class="line"></span><br><span class="line">printf(&quot;p:%p\n&quot; , p );</span><br><span class="line">printf(&quot;p+1:%p\n&quot; , p+1 );</span><br><span class="line"></span><br><span class="line">printf(&quot;p1:%p\n&quot; , p1 );</span><br><span class="line">printf(&quot;p1+1:%p\n&quot; , p1+1 );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">p:0x7fffcb862610</span><br><span class="line">p+1:0x7fffcb862618</span><br><span class="line">p1:0x7fffcb86260c</span><br><span class="line">p1+1:0x7fffcb862610</span><br></pre></td></tr></table></figure>
<p><img src="https://v3.wmnzsx.eu.org/i/1/2023/11/24/117lt0a-1.webp" alt="C-pointer7"></p>
<p><mark>注意：</mark><br>
指针在加减运算的过程中， 加/减的大小取决于该指针他自己的类型，与它所执行的数据实际的类型没有关系。</p>
<hr>
<h2 id="指针进阶">指针进阶</h2>
<h3 id="char-型指针">char 型指针</h3>
<p>从本质上来看，字符指针其实就是一个指针而已，只不过该指针用来指向一个<font color="#ff0000">字符串/字符串数组</font></p>
<p><code>char * msg = &quot;Hello&quot; ;</code></p>
<h3 id="多级指针">多级指针</h3>
<ul>
<li>如果一个指针 p1 它所指向的是一个<font color="#ff0000">普通变量</font>的地址，那么 p1就是一个一级指针</li>
<li>如果一个指针 p2 它所指向的是一个<font color="#ff0000">指针变量</font>的地址，那么 p2就是一个二级指针</li>
<li>如果一个指针 p3 它所指向的是一个<font color="#ff0000">指向二级指针变量</font>的地址，那么 p3就是一个三级指针</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int a = 100 ;</span><br><span class="line">int * p1 = &amp;a ; // p1是一个一级指针</span><br><span class="line">int ** p2 = &amp;p1 ; // p2是一个二级指针</span><br><span class="line">int *** p3 = &amp;p2 ; // p3是一个三级指针</span><br></pre></td></tr></table></figure>
<p><img src="https://v3.wmnzsx.eu.org/i/1/2023/12/04/nurhan-1.webp" alt="C-pointer8"></p>
<p><mark>指针的拆解方法：</mark><br>
对于任何的指针都可以分为两部分：<br>
第一部分： 说明他是一个指针 （* p ）<br>
第二部分： 说用它所指向的内容的类型 （* p）以外的东西</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char *p1; // 第一部分：* p1 ，第二部分：char ，说明p1 指向的类型为char</span><br><span class="line"></span><br><span class="line">char **p2; // 第一部分：* p2 ，第二部分： char * ， 说明p2 指向的类型为char *</span><br><span class="line"></span><br><span class="line">int **p3 ; // 第一部分：* p3 ，第二部分：int * 说明p3 指向的类型为int *</span><br><span class="line"></span><br><span class="line">char (*p4)[3]; // 第一部分：* p4 , 第二部分： char [3] , 说明p4 指向一个拥有3个元素的char 数组</span><br><span class="line"></span><br><span class="line">char (*p5)(int, float); // 第一部分：* p5, 第二部分：char (int , float)，说明该指针指向一个 拥有char类型返回， 并需要 一个int 和 float 参数的函数</span><br><span class="line"></span><br><span class="line">void *(*p6)(void *); // 第一部分：* p6, 第二部分：void * (void *)，说明p6 指向一个 拥有 void * 返回并需要一个void * 参数的函数，函数指针）</span><br></pre></td></tr></table></figure>
<ul>
<li>以上指针 p1 p2 p3 p4 p5 p6 本质上都是指针，因此它们的大小都是 8字节（64位系统）</li>
<li>以上指针 p1 p2 p3 p4 p5 p6 本质上都是指针，唯一的不容是它们所指向的内容的类型不同</li>
</ul>
<h3 id="void-型指针">void 型指针</h3>
<ol>
<li>
<p>概念： 表示该指针的类型暂时是不确定的</p>
</li>
<li>
<p>要点</p>
<ul>
<li>void 类型的指针，是没有办法直接索引目标的。必须先进行强制类型转换。</li>
<li>void 类型指针，无法直接进行加减运算。</li>
</ul>
</li>
<li>
<p>void 关键字的作用</p>
<ul>
<li>修饰指针，表示该指针指向了一个未知类型的数据。</li>
<li>修饰函数的参数列表，则表示该函数不需要参数。</li>
<li>修饰函数的返回值，则表示该函数没有返回值。</li>
</ul>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void * p = malloc(4) ; // 使用malloc 来申请 4个字节的内存， 并让p来指向该内存的入口地址</span><br><span class="line">  </span><br><span class="line">*(int *)p = 250 ; // 先使用(int*) 来强调p是一个整型地址 ，然后再解引用</span><br><span class="line">printf(&quot;*p:%d\n&quot;, *(int*)p);// 输出时也应该使用对应的类型来进行输出</span><br><span class="line">  </span><br><span class="line">*(float*)p = 3.14 ;</span><br><span class="line">printf(&quot;*p:%f\n&quot;, *(float*)p);</span><br><span class="line">  </span><br><span class="line">int * a ;</span><br><span class="line">char * b ;</span><br><span class="line">float * f ;</span><br><span class="line">  </span><br><span class="line">void * k ;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>以上写法 void * p ，在实际开发中不应该出现。以上代码只是为了说明语法问题。</p>
</blockquote>
</li>
</ol>
<h3 id="const-指针">const 指针</h3>
<p>const 修饰指针有两种效果：</p>
<ul>
<li>
<p>常指针：修饰的是指针本身，表示该指针变量无法修改</p>
<p><code>char * const p ;</code></p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char arr [] = &quot;Hello&quot; ;</span><br><span class="line">char msg [] = &quot;world&quot; ;</span><br><span class="line">char * const p = arr ;</span><br><span class="line"></span><br><span class="line">// p = msg ; // 错误，p 被const 所修饰，说明P是一个常量 ，他的内容（所指向的地址）无法修改</span><br><span class="line"></span><br><span class="line">*(p + 1 ) = &#x27;E&#x27; ; // p所指向的内容是可以通过p 来修改 （只要保持P所指向的地址不变即可）</span><br><span class="line"></span><br><span class="line">printf(&quot;%s\n&quot; , p ); //输出结果为：HEllo</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>常目标指针：修饰的是指针所指向的目标，表示无法通过该指针来改变目标的数据</p>
<p><code>char const * p ;</code><br>
<code>const char * p ;</code></p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char arr [] = &quot;Hello&quot; ;</span><br><span class="line">char msg [] = &quot;world&quot; ;</span><br><span class="line"></span><br><span class="line">const char * p1 = arr ;</span><br><span class="line">p1 = msg ; // p1 的指向是可以被修改的</span><br><span class="line">// *(p1+1) = &#x27;V&#x27; ; // 错误，常目标指针， 不允许通过该指针来它所指向的内容</span><br><span class="line"></span><br><span class="line">*(msg+1) = &#x27;V&#x27; ; // 虽然p1不能修改所指向的内容， 但是内容本身是可以被修改的</span><br><span class="line"></span><br><span class="line">printf(&quot;%s\n&quot; , p1 ); // 输出结果为：wVrld</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><mark>总结：</mark></p>
<ul>
<li>常指针并不常见</li>
<li>常目标指针，在实际开发过程中比较常见，用来限制指针的权限为 <font color="#ff0000">只读</font></li>
</ul>
<p><img src="https://v3.wmnzsx.eu.org/i/1/2023/12/04/nzcluo-1.webp" alt="C-pointer9"></p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言学习一：数据类型</title>
    <url>/2023/10/22/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E4%B8%80%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="数据类型">数据类型</h2>
<h3 id="整形">整形</h3>
<blockquote>
<p>概念： 表示整数类型的数据</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int a = 123 ;      </span><br></pre></td></tr></table></figure>
<p>①先向系统申请一片内存，取名为 a；②确定该内存大小为 4 字节（1 字节 byte = 8 位 bit）；③把 123 转化为二进制存放在该内存中</p>
<ol>
<li>
<p>介绍</p>
<ul>
<li>
<p>整型在 <code>32</code> 位系统以及 <code>64</code> 位系统中都占用 <code>4</code> 字节</p>
</li>
<li>
<p><mark>取值范围</mark></p>
</li>
</ul>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ getconf INT_MAX</span><br><span class="line">2147483647</span><br><span class="line">$ getconf INT_MIN</span><br><span class="line">‐2147483648</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>整型的修饰符：</p>
<ul>
<li>short 短整型，用于修饰整型的尺寸变为原本的一半，减少内存的开支，缩小取值范围</li>
<li>long 长整型，用于修饰整型的尺寸使其尺寸变大（取决与系统），增加内存开支，扩大取值范围</li>
<li>long long 长长整型，用于修饰整型的尺寸使其尺寸变大（取决与系统），增加内存开支，扩大取值范围 （在64位系统中 long 与 long long 的大小一致）</li>
<li>unsigned 无符号整型，用来修饰整型并<mark>去掉</mark>符号位，使得整型数据没有负数，可以提正整数的取值范围 （0 - 4294967295）</li>
<li>整型数据在二进制存储时最高位（第31位）表示符号位，如果为1 则表示负数反之则表示正数</li>
</ul>
</li>
<li>
<p>整数的存储方式：</p>
<ul>
<li>
<p>原码： 正整数是直接使用原码进行存储的，比如100这个正整数，则直接把100 转换成二进制直接存储。</p>
<p><code>100 --&gt; 0000 0000 0000 0000 0000 0000 0110 0100</code></p>
</li>
<li>
<p>补码：负数则是使用补码来存储，补码 = 原码的绝对值取反+ 1，<mark>取反和加1时符号位都不变</mark></p>
<p>比如-100：</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">100 --&gt; 1000 0000 0000 0000 0000 0000 0110 0100</span><br><span class="line">取反-&gt; 1111 1111 1111 1111 1111 1111 1001 1011</span><br><span class="line">加1 --&gt; 1111 1111 1111 1111 1111 1111 1001 1100</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>注：<code>取反</code> 和 <code>加1</code> 的最前面的数字 1 不改变，他为符号位，表示正负，<code>0</code> 为正，<code>1</code> 为负</p>
</blockquote>
</li>
<li>
<p>溢出：</p>
<p>概念：当超过取值范围时则会变成相邻的最小值/最大值</p>
</li>
<li>
<p>整型输出：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int c = 100;</span><br><span class="line">printf(&quot;十六进制：%#x\n&quot; , c);       //`#` 是格式说明符的一部分</span><br><span class="line">printf(&quot;十进制：%d\n&quot; , c);</span><br><span class="line">printf(&quot;八进制：%#o\n&quot; , c);</span><br><span class="line"></span><br><span class="line">// 输出结果：</span><br><span class="line"> 十六进制：0x64</span><br><span class="line"> 十进制：100</span><br><span class="line"> 八进制：0144</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>sizeof 运算符</p>
<blockquote>
<p>用于计算变量/类型的大小。</p>
</blockquote>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int a=123;</span><br><span class="line">printf(&quot;sizeof(short):%ld\n&quot;,sizeof(short));</span><br><span class="line">printf(&quot;sizeof(int):%ld\n&quot;,sizeof(int));</span><br><span class="line">printf(&quot;sizeof(long):%ld\n&quot;,sizeof(long));</span><br><span class="line">printf(&quot;sizeof(long long):%ld\n&quot;,sizeof(long long));</span><br><span class="line">&#125;</span><br><span class="line">//注意括号内部可以写变量类型， 也可以写变量名</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//输出结果</span><br><span class="line">sizeof(a):4</span><br><span class="line">sizeof(short):2</span><br><span class="line">sizeof(int):4</span><br><span class="line">sizeof(long):8</span><br><span class="line">sizeof(long long):8</span><br></pre></td></tr></table></figure>
<p><img src="https://v3.wmnzsx.eu.org/i/1/2023/11/24/119edfv-1.webp" alt="C-type1"></p>
<blockquote>
<p>在 32 位平台下，int 型和 long 型是一致的，都是占用 4 个字节。Long long 是 8 个字节。<br>
在 64 位平台下，int 型是占用 4 个字节，而 long 和 long long 都是占用 8个字节的。<br>
尽量不要使用 long 和 long int，因为 c/c++标准中，只限制了 long int 长度不小于 int，并未限制 long 必须是 4 个字节或者 8 个字节，也就是跟平台相关，这主要是因为有一些历史兼容性原因。所以要使用明确的 long long 或者 uint64_t</p>
</blockquote>
</li>
</ol>
<hr>
<h3 id="浮点型（实型）：">浮点型（实型）：</h3>
<ol>
<li>介绍</li>
</ol>
<ul>
<li>概念：用来表达一个实数的数据类型</li>
<li>分类
<ul>
<li>单精度浮点型 float , 典型尺寸 4 字节</li>
<li>双精度浮点型 double , 典型尺寸 8 字节</li>
<li>长双精度 long double ，典型尺寸 16 字节<br>
占用的内存越多则精度越高</li>
</ul>
</li>
</ul>
<ol start="2">
<li>
<p>浮点数的存储</p>
<blockquote>
<ul>
<li>虽然浮点数储存的也是 <code>0，1</code> ，但和整形不一样</li>
<li>整形是原码补码储存</li>
<li>浮点型是通过计算得出的浮点数二进制码</li>
</ul>
</blockquote>
<p>IEEE 浮点标准采用如下形式来表示一个浮点数</p>
<p><img src="https://v3.wmnzsx.eu.org/i/1/2023/11/24/119eldv-1.webp" alt="C-type2"></p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">float f = 3.14; // 浮点数3.14 通过以上公式计算得到的二进制码，存放在在内存f中</span><br><span class="line">printf(&quot;f:%f\n&quot;,f); // 使用浮点的计算方法来解析内存f中的值(二进制)</span><br><span class="line">printf(&quot;d:%d\n&quot;,f);// 直接使用整型的计算方法来直接解析内存f 中的值 (二进制)</span><br></pre></td></tr></table></figure>
<p>虽然所有的数据都会被转换成二进制进行存储，但如果想到的到正确的数据，必须使用正确的理解方式（类型），来解析二进制数据。所以不能用%d</p>
</li>
</ol>
<hr>
<h3 id="字符类型">字符类型</h3>
<h4 id="字符">字符</h4>
<ol>
<li>
<p>介绍</p>
<p><code>char c = 'K' ;</code><br>
①申请一片内存并且命名为 c<br>
②确定内存的大小为 char （1字节）<br>
③把字符‘K’的 ASCII 码值转换为二进制，并存储到该内存中</p>
<blockquote>
<p>计算机中存储的所有数据都是以二进制的形式存在的，因此字符必须映射某一个数字才能<br>
够被存放到计算机中，这个映射的表就成为 ASCII 表，可以使用 man 手册来查看    <code>man ascii</code></p>
</blockquote>
<blockquote>
<p>字符之间的比较就是比较他们的 ASCII 码</p>
</blockquote>
 <details class="toggle" ><summary class="toggle-button" style="">点击查看 man ascii 解释</summary><div class="toggle-content"><ol>
<li><strong>oct（Octal）：</strong> 这一列显示了 ASCII 字符的八进制（octal）表示。ASCII 字符可以用三位八进制数字表示，例如，大写字母’A’对应的八进制表示为101。</li>
<li><strong>dec（Decimal）：</strong> 这一列显示了ASCII字符的十进制（decimal）表示。ASCII字符可以用十进制数字表示，例如，大写字母’A’对应的十进制表示为65。</li>
<li><strong>hex（Hexadecimal）：</strong> 这一列显示了ASCII字符的十六进制（hexadecimal）表示。ASCII字符可以用两位十六进制数字表示，例如，大写字母’A’对应的十六进制表示为41。</li>
<li><strong>cher（Character）：</strong> 这一列显示了对应的可打印字符或控制字符。可打印字符是可以显示在屏幕上的字符，如字母、数字和符号。控制字符是用于特殊控制目的的字符，如换行符（newline）和回车符（carriage return）。</li>
</ol>
</div></details>
<p><strong>例：</strong></p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char c = &#x27;1&#x27; ;</span><br><span class="line">printf(&quot;字符：%c\n&quot;,c); // 以字符的形式来解析内存 c 的内容得到 对应的字符 1</span><br><span class="line">printf(&quot;整型ASCII值：%d\n&quot;,c); //以十进制整型来解析内存c 的内容 ，得到1多对应的ASCII值</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>注意：</p>
<p><mark>字符实质上是一个单字节的整型，因此支持所有整型的操作</mark></p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">char k = &#x27;H&#x27; ;</span><br><span class="line">printf(&quot;k + 1: %c\n&quot; , k + 1 );</span><br><span class="line">printf(&quot;k - 1: %c\n&quot; , k - 1 );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//输出结果</span><br><span class="line">k + 1: I</span><br><span class="line">k - 1: G</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="字符串">字符串</h4>
<p>字符串的表现形式有两种：</p>
<ol>
<li>
<p>数组（可读，可写）：（存储）</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char s1[] = &quot;Hello&quot; ;   //使用一个数组来存放字符串 &quot;Hello&quot;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>以上语句其实是把一个字符串常量 “Hello” ，复制到数组 s1 所代表的内存当中</p>
</blockquote>
<p><img src="https://v3.wmnzsx.eu.org/i/1/2023/11/24/119ecv5-1.webp" alt="C-type3"></p>
</li>
<li>
<p>指针 （只读）：（指向）</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char *s2 = &quot;Even&quot;; // 使用一个指针来指向常量字符串</span><br></pre></td></tr></table></figure>
<p><img src="https://v3.wmnzsx.eu.org/i/1/2023/11/24/119e6fa-1.webp" alt="C-type4"></p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char s1[] = &quot;abc&quot;;</span><br><span class="line">    char *s2=&quot;def&quot;;</span><br><span class="line">    printf(&quot;%s %s\n&quot;,s1,s2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//输出结果</span><br><span class="line">abc def</span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<h3 id="布尔类型">布尔类型</h3>
<p>概念： 布尔类型用来表示真/假 （非零则真）</p>
<p>真：<code>true</code>                                假：<code>false</code></p>
<p>注意在使用布尔类型是需要包含他的头文件： &lt;stdbool.h&gt;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool a = 1 ; // 真</span><br><span class="line">bool a = 0 ; // 假</span><br><span class="line">bool a = true // 真</span><br><span class="line">bool a = false // 假</span><br></pre></td></tr></table></figure>
<p>一般布尔类型的变量，可以用于逻辑判断比如 if / while ，或者用于函数的返回值。</p>
<p>布尔类型的大小：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool a = true ;</span><br><span class="line">printf(&quot;sizeof(bool):%ld \n &quot;,sizeof(bool) );</span><br><span class="line">printf(&quot;sizeof(a):%ld \n &quot;,sizeof(a) );</span><br><span class="line">printf(&quot;sizeof(true):%ld \n &quot;,sizeof(true) );</span><br><span class="line">printf(&quot;sizeof(false):%ld \n &quot;,sizeof(false) );</span><br><span class="line">printf(&quot;false:%d \n &quot;,false );</span><br><span class="line">printf(&quot;true:%d \n &quot;,true );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//运行结果：</span><br><span class="line">sizeof(bool):1</span><br><span class="line">sizeof(a):1</span><br><span class="line">sizeof(true):4</span><br><span class="line">sizeof(false):4</span><br><span class="line">false:0</span><br><span class="line"> true:1</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="常量与变量">常量与变量</h3>
<p>概念： 不可以被改变的内存，被称为常量，可以被改变的内存则成为变量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int a = 100 ;                     // a是一个变量， 而 100 则是常量</span><br><span class="line">float f = 3.1415;                 // f 是一个变量， 而 3.1415 则是常量</span><br><span class="line">char s1[] = &quot;abcdefg&quot; ;           // s1 是一个变量 , 而&quot;abcdefg&quot; 则是常量 （字符串常量）</span><br></pre></td></tr></table></figure>
<p>常量类型：</p>
<ul>
<li>100 ：整型常量</li>
<li>100L : 长整型 long</li>
<li>100LL : 长长整型 long long</li>
<li>100UL : 无符号的长整型 unsigned long</li>
<li>3.14 : 编译器默认升级为双精度浮点型</li>
<li>3.14L : 长的双精度浮点型</li>
<li>‘a’ : 字符常量</li>
<li>“Hello” : 字符串常量（指针 char * ）</li>
</ul>
<hr>
<h2 id="标准输入与标准输出（格式化输出）">标准输入与标准输出（格式化输出）</h2>
<h3 id="标准输入">标准输入</h3>
<p>概念： 标准输入一般指的是键盘的设备文件，从键盘获取数据就成为标准输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scanf( ); // 扫描键盘 （格式化输入数据 ‐‐&gt; 从键盘中获得指定类型的数据） </span><br><span class="line"></span><br><span class="line">    头文件：</span><br><span class="line">        #include &lt;stdio.h&gt;</span><br><span class="line">    函数原型：</span><br><span class="line">        int scanf(const char *format, ...);</span><br><span class="line">    参数分析：</span><br><span class="line">        format ‐‐&gt; 格式化</span><br><span class="line">        ... ‐‐&gt; 省略号 , 根据format 所写的格式控制符，对应一个内存地址</span><br><span class="line">    返回值：</span><br><span class="line">        成功 返回具体获取到的项目数</span><br><span class="line">        失败 返回0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">getchar( ) ; </span><br><span class="line">// 获取一个字符 （默认从标准输入文件中获取），与scanf( )配合，清空 由 scanf 所留在缓冲区的内容（比如回车\n等）</span><br><span class="line"></span><br><span class="line">    函数原型：</span><br><span class="line">        int getchar(void);</span><br><span class="line">    参数：</span><br><span class="line">        无</span><br><span class="line">    返回值：</span><br><span class="line">        成功 返回一个ASCII值，代表获得的字符 （实际上为unsigned char ）</span><br><span class="line">        失败 返回 EOF 也就是 ‐1</span><br></pre></td></tr></table></figure>
<p><strong>补充：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char * p = malloc(32); // p是指针，使用 p 而不是 &amp;p，因为 p 就是一个地址</span><br><span class="line">scanf (&quot;%[^\n]s&quot;, p);  // [^\n] 表示只有回车符才是结束标记</span><br></pre></td></tr></table></figure>
<p>实例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">int num = 0;</span><br><span class="line">char c = &#x27;0&#x27;;</span><br><span class="line">int ret_val = scanf(&quot;%d&quot;, &amp;num );       // &amp; 取地址符号，获得 内存 num 的地址</span><br><span class="line">while(getchar() != &#x27;\n&#x27;); // 清空 由 scanf 所留在缓冲区的内容</span><br><span class="line">// 如果不清空有可能会导致下一次使用标准输入缓冲区异常（有上一次的数据没有被读取）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">printf(&quot;返回值：%d , 获取的数据为：%d\n&quot; , ret_val , num );</span><br><span class="line">ret_val = scanf(&quot;%c&quot;, &amp;c );</span><br><span class="line">while(getchar() != &#x27;\n&#x27;); // 清空 由 scanf 所留在缓冲区的内容</span><br><span class="line">printf(&quot;返回值：%d , 获取的数据为：%c\n&quot; , ret_val , c );</span><br><span class="line">printf(&quot;EOF:%d\n&quot; , EOF ); //EOF 实际上是一个值为‐1 的宏</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：如果以后需要从标准输入中获取数据得到乱码或未知数据，则可以尝试使用 getchar 进行清空再获取。</p>
</blockquote>
<h3 id="标准输出（格式化输出）">标准输出（格式化输出）</h3>
<p>概念：屏幕（终端）对应的就是标准输出的设备文件，如果往该文件中输出内容则可以成为标准输出。</p>
<p><code>printf( );</code></p>
<ol>
<li>
<p>注意语法点</p>
<ul>
<li><code>%</code> 必须有的，格式化的开头标记</li>
<li>对齐的方式， 向左对齐（空格在右） ，如果没有则是向右对齐（空格在左）</li>
<li><code>m.n </code>  m 指的域宽（需要的字符数）， n 指的是精度（默认精度为6）<br>
m 的值如果比实际数据小则按实际输出，反之则用空格来填补</li>
<li><code>l</code> 指的是 long 表示长整型</li>
<li><code>h </code>指的是短整型</li>
</ul>
</li>
<li>
<p>格式控制符</p>
<ul>
<li>十进制的整型： <code>%d</code> <code>%md</code> <code>%ld</code> <code>%u</code>（无符号） <code>%lu</code></li>
<li>八进制： <code>%o</code> <code>%#o</code>                 # --&gt; 输出进制的符号</li>
<li>十六进制： <code>%x</code> <code>%#x</code> <code>%#X</code></li>
<li>字符： <code>%c</code></li>
<li>字符串： <code>%s</code></li>
<li>单精度浮点： <code>%f</code> <code>%.nf</code> --&gt; n 表示精度</li>
<li>双精度： <code>%lf</code></li>
<li>长双精度 ： <code>%Lf</code></li>
<li>地址： <code>%p</code></li>
</ul>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">printf(&quot;%d\n&quot; , 0123 ); // 使用十进制的格式来输出一个八进制数据 0123 ‐‐&gt;83</span><br><span class="line"></span><br><span class="line">printf(&quot;%o\n&quot; , 0123 ); // 使用八进制的格式来输出一个八进制数据 0123 ‐‐&gt;123</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="类型的转换">类型的转换</h3>
<p>概念：不同的数据类型但是可以兼容的类型之间，如果出现在同一表达式中则会发生类型的转换。</p>
<ol>
<li>
<p>隐式转换（自动）</p>
<p>若在表达式中用户没有手动进行转换，则系统会自动转为高精度的类型（由低精度转换为高精度）<br>
比如：  float + double + int   --&gt;  则系统会自动全部转为 double</p>
</li>
<li>
<p>强制转换（手动）</p>
<p>用户根据自己的需求进行强制的类型转换 ( int )a   --&gt;     强制性把 a 转换为整型</p>
<blockquote>
<p>注意：不管是隐式转换还是强制转换，准换的只是在运算的过程中，并不会影响到原本的数，这是一个临时的转换。</p>
</blockquote>
<blockquote>
<p>运算中可能会丢失精度，但不会影响数据本来的值，只是临时转换</p>
</blockquote>
<p>例如：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a=100;</span><br><span class="line">    char c=&#x27;k&#x27;;</span><br><span class="line">    float f=3.14;</span><br><span class="line">    double d=998526.153;</span><br><span class="line"></span><br><span class="line">//只是临时转换高精度的double m，   a、c、f、d实际没变</span><br><span class="line">    double m=a+c+f+d;    //隐式转换</span><br><span class="line">    int n=(int)a+(int)c+(int)f+(int)d;   //强制转换</span><br><span class="line">    printf(&quot;m= %lf,n=%d\n&quot;,m,n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>精度排序：</strong></p>
<ol>
<li><code>char</code>：1个字节。通常用于存储字符和小整数值。</li>
<li><code>short</code>：2个字节。通常用于较小的整数值。</li>
<li><code>int</code>：4个字节。通常用于一般整数值。</li>
<li><code>float</code>：4个字节。单精度浮点数，通常用于存储小数值，具有较高的精度。</li>
<li><code>double</code>：8个字节。双精度浮点数，通常用于存储双精度小数值，具有更高的精度。</li>
<li><code>long double</code>：这个数据类型的大小可以因系统而异，<mark>通常为8个字节</mark>或更多。它提供了比 <code>double</code> 更高的精度，适用于需要更高精度的计算</li>
</ol>
<h2 id="补充">补充</h2>
<h3 id="数据类型的本质：">数据类型的本质：</h3>
<ol>
<li>
<p>概念：</p>
<p>各种不同的数据类型，从本质上是用户与系统之间的一个约定，这个约定用来如何正确的解析内存中的二进制编码。</p>
<p>比如整形使用原码补码，浮点型是通过计算得出的浮点数二进制码</p>
</li>
<li>
<p>推论：</p>
<p>类型转换：实际上就是在临时打破之前的约定。<br>
理论上任何的数据都可以进行转换，但是转换之后是否有意义？</p>
</li>
</ol>
<h3 id="整型的尺寸">整型的尺寸</h3>
<ol>
<li>
<p>概念：尺寸指的是某一个数据需要多少内存来存储（占用的内存空间）</p>
<p>在 C 语言中并没有规定某一个数据类型他的尺寸是多少，但是有个<mark>相对</mark>的大小约定</p>
<p>Short 不可能比 int 长<br>
Long 不可能比 int 短<br>
Long 的长度等于系统的字长（系统位数，比如 32 位，64 位）</p>
<p>如何查看系统字长：有很多方法</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//方法一，终端输入</span><br><span class="line">$ getconf LONG_BIT</span><br><span class="line">64</span><br><span class="line"></span><br><span class="line">//方法二，终端输入</span><br><span class="line">$ uname -a</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>典型尺寸：</p>
<ul>
<li>char    占用 1 个字节</li>
<li>short   占用 2个字节</li>
<li>int       占用 4 个字节</li>
<li>long    占用 4（32 位系统） /  8（64 位系统） 个字节</li>
</ul>
</li>
</ol>
<h4 id="可移植类型">可移植类型</h4>
<blockquote>
<p>相同的代码在不同（位数）的系统中，它所占用的尺寸会发生变化，有可能导致数据的精度出现问题，严重的可能会导致程序无法运行。<br>
因此，系统中会提供一些可移植类型。</p>
</blockquote>
<p>概念：不管在什么系统中，数据的尺寸都是固定不会发生变化的数据类型，称为可移植数据类型</p>
<p>关键词：typedef</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef int zzz;   //相对于用typedef给int取个别名为zzz</span><br><span class="line">typedef int __int32_t;</span><br><span class="line">typedef long __long_64_t;</span><br></pre></td></tr></table></figure>
<p>系统提供了一些预定义的</p>
<p>通过 cd /usr/include 后，运行 find -name types.h 会发现./x86_64-linux-gnu/bits/types.h<br>
路径：/usr/include/x86_64-linux-gnu/bits/types.h</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* Convenience types.  */</span><br><span class="line">typedef unsigned char __u_char;</span><br><span class="line">typedef unsigned short int __u_short;</span><br><span class="line">typedef unsigned int __u_int;</span><br><span class="line">typedef unsigned long int __u_long;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* Fixed-size types, underlying types depend on word size and compiler.  */</span><br><span class="line">typedef signed char __int8_t;    //有符号的8位整型</span><br><span class="line">typedef unsigned char __uint8_t;   //无符号的8位整型</span><br><span class="line">typedef signed short int __int16_t;</span><br><span class="line">typedef unsigned short int __uint16_t;</span><br><span class="line">typedef signed int __int32_t;</span><br><span class="line">typedef unsigned int __uint32_t;</span><br><span class="line">#if __WORDSIZE == 64     //判断系统的位数（字长）</span><br><span class="line">typedef signed long int __int64_t;    //64位系统中，long int就是64位的有符号整型</span><br><span class="line">typedef unsigned long int __uint64_t;  ////64位系统中，long int就是64位的无符号整型</span><br><span class="line">#else   //判断系统的位数，如果不是64位系统，则判断为32位系统</span><br><span class="line">__extension__ typedef signed long long int __int64_t;  //在32位系统中 long long 才占用64位</span><br><span class="line">__extension__ typedef unsigned long long int __uint64_t;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>笔记</category>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言学习四：数组</title>
    <url>/2023/10/22/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E5%9B%9B%EF%BC%9A%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h2 id="数组入门">数组入门</h2>
<h3 id="概念">概念</h3>
<ol>
<li>
<p>逻辑： 一次性定义多个相同类型的变量，并且给他分配一片连续的内存</p>
</li>
<li>
<p>语法：<code>int arr [5]</code> ;</p>
<p><img src="https://v3.wmnzsx.eu.org/i/1/2023/11/24/116hd4u-1.webp" alt="C-array1"></p>
</li>
<li>
<p>初始化</p>
<p>只有在定义的时候赋值，才可以称为初始化。数组只有在初始化的时候才可以统一赋值。</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int arr [5] = &#123;1,2,3,4,5&#125; ; // 正确，定义并初始化数组</span><br><span class="line">int arr [5] = &#123;1,2,3&#125; ; //可以， 为不完全初始化，后面的两个为0；若完全的不初始化则为随机值</span><br><span class="line"></span><br><span class="line">int arr [5] = &#123;1,2,3,4,5,6,7,8,9&#125; ; // 错误（但是可以用），越界初始化， 越界部分将会被编译器舍弃</span><br><span class="line"></span><br><span class="line">int arr [ ] = &#123;1,2,3,4,5,6,7,8,9&#125; ; // 可以， 用户没有直接给定数组大小，</span><br><span class="line">// 但是有初始化， 因此数组的大小会在初始化时确定， 大小为 9</span><br><span class="line"></span><br><span class="line">int arr [ ]; // 错误， 没有给定大小也没有初始化， 因此数组的内存大小无法确定，系统无法分配</span><br></pre></td></tr></table></figure>
<p><img src="https://v3.wmnzsx.eu.org/i/1/2023/11/24/116hidx-1.webp" alt="C-array2"></p>
<p><mark>注意：</mark></p>
<p>数组在定义的时候必须确定他的大小。<br>
说白了就是中括号中 <code>[]</code> 必须有数组的大小，如果没有就必须初始化</p>
<p><mark>数组元素引用：</mark></p>
<ul>
<li>存储模式：一片连续的内存，按照数据的类型进行分割成若干个大小相同的格子</li>
<li>元素的下标与偏移量：以数组开头为基础的偏移的量（数据类型大小）</li>
</ul>
<p><img src="https://v3.wmnzsx.eu.org/i/1/2023/11/24/116h7zg-1.webp" alt="C-array3"></p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int arr [5] = &#123;1,2,3,4,5&#125; ; // 定义并初始化数组</span><br><span class="line">printf(&quot;arr[0]:%d\n&quot; , arr[0]);</span><br><span class="line">arr[0] = 99 ; // 把数组的第1个元素（ 偏移量为0 ）修改为 99</span><br><span class="line">printf(&quot;arr[0]:%d\n&quot; , arr[0]);</span><br><span class="line">arr[5] = 250 ; //&quot;错误&quot; 越界访问， 很有可能造成非法访问</span><br><span class="line">printf(&quot;arr[5]:%d\n&quot; , arr[5]);</span><br><span class="line"></span><br><span class="line">arr = &#123;9,8,7,6,5,4&#125;; // 整体赋值只允许在初始化中</span><br><span class="line">arr = 100 ; // 错误</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">printf(&quot;sizeof(arr):%ld\n&quot; , sizeof(arr));</span><br><span class="line">int len = sizeof(arr) / sizeof(int) ; // 求数组元素的个数</span><br><span class="line">for (size_t i = 0; i &lt; len ; i++)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;arr[%ld]:%d\n&quot; , i , arr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="字符数组">字符数组</h3>
<ol>
<li>
<p>概念： 专门用来存放字符类型数据的数组，称为字符数组</p>
</li>
<li>
<p>初始化+引用：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char ch1 [5] = &#123;&#x27;H&#x27;,&#x27;e&#x27;,&#x27;l&#x27;,&#x27;l&#x27;,&#x27;o&#x27;&#125; ; // 定义一个字符类型的数组并把&#x27;H&#x27;,&#x27;e&#x27;,&#x27;l&#x27;,&#x27;l&#x27;,&#x27;o&#x27; 一个一个存进去</span><br><span class="line"></span><br><span class="line">char ch2 [5] = &#123;&quot;Hello&quot;&#125; ; // 定义一个字符型的数组， 并把 &quot;Hello&quot; 字符串存放到数组中 ，因此该数组为字符串数组（后面会有一个空字符`\0`），ch2[0]为&#x27;H&#x27;,ch2[5]为空字符&#x27;\0&#x27;，在终端中看不到</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">char ch3 [5] = &quot;Hello&quot; ; // 与ch2 一样， 大括号可以省略</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ch3[1] = &#x27;E&#x27; ; // 可以， 把数组中第二个元素‘e’修改为‘E’</span><br><span class="line">ch3 = &quot;hi&quot; ; // 不可以， 只有在初始化的时候才能整体赋值</span><br><span class="line"></span><br><span class="line">printf(&quot;%s\n&quot; , ch1); // 在访问ch1的时候并没有发现结束符，因此很有可能会把后面ch2的内容一并输出</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：ch1 为字符数组，它没有结束符，因此在打印输出的时候应该避免使用 %s 进行输出，有可能会造成越界访问。</p>
</blockquote>
</li>
</ol>
<h3 id="思考">思考</h3>
<ol>
<li>
<p>定义数组时没有初始化会怎么样？</p>
<p>没有初始化的情况下内存的内容是随机值（内存中原有的内容）</p>
<p><img src="https://v3.wmnzsx.eu.org/i/1/2023/11/24/116h3up-1.webp" alt="C-array4"></p>
</li>
<li>
<p>不完全初始化又会怎么样？</p>
<p>不完全初始化，已经初始化部分是已知值，其它则是0</p>
</li>
<li>
<p>补充</p>
<p><mark>注意：</mark></p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char buf[5]=&#123;1,2,3,4,5&#125;;    //把将1，2，3，4，5当作字符的ASCII值存放在数组中</span><br><span class="line">char buf[5]=&#123;&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;,&#x27;4&#x27;,&#x27;5&#x27;&#125;   //存放在内存中的是字符1，2，3，4，5所对应的ASCII值</span><br></pre></td></tr></table></figure>
</li>
</ol>
<details class="toggle" ><summary class="toggle-button" style="">点击此处展开/收起内容，来自 chatgpt 的解释</summary><div class="toggle-content"><ol>
<li>
<p>char buf[5]={1,2,3,4,5};</p>
<p>表示将整数值 1、2、3、4 和 5 直接存储到 <code>buf</code> 数组中。</p>
<p>在 C 语言中，<code>char</code> 类型是一种整数类型，可以存储整数值。因此，整数值 1、2、3、4 和 5 会被直接存储到 <code>buf</code> 数组的连续内存位置中。</p>
<blockquote>
<p>需要注意的是，这些整数值并不是字符的 ASCII 码值。当您使用整数值初始化 <code>char</code> 数组时，编译器会将这些整数值直接存储到数组的内存位置中，而不会将它们解释为字符。<br>
如果您希望将整数值解释为对应的字符，可以使用类型转换或字符操作函数来实现。例如，可以使用 <code>printf</code> 函数将 <code>buf</code> 数组中的整数值作为字符进行打印：<code>for (int i = 0; i &lt; 5; i++) { printf(&quot;%c &quot;, buf[i]); }</code></p>
</blockquote>
</li>
<li>
<p>char buf[5]={‘1’,‘2’,‘3’,‘4’,‘5’}</p>
<p>表示将字符 ‘1’、‘2’、‘3’、‘4’ 和 ‘5’ 的 ASCII 码值存储到 <code>buf</code> 数组中。</p>
<p>具体地说，字符 ‘1’ 的 ASCII 码值是 49，字符 ‘2’ 的 ASCII 码值是 50，字符 ‘3’ 的 ASCII 码值是 51，字符 ‘4’ 的 ASCII 码值是 52，字符 ‘5’ 的 ASCII 码值是 53。这些 ASCII 码值会被存储到 <code>buf</code> 数组的连续内存位置中。</p>
</li>
</ol>
</div></details>
<hr>
<h2 id="数组进阶">数组进阶</h2>
<h3 id="数组名的含义">数组名的含义</h3>
<p>数组名在不同的场合下的含义不同：</p>
<ol>
<li>
<p>表示整个<font color="#ff0000">数组的首地址</font>：</p>
<ul>
<li>在数组定义的时候</li>
<li>在使用 sizeof 运算符中数组名表示整个数组的首地址（求得整个数组的大小）</li>
<li>在取地址符 中 &amp;arr , arr 表示整个数组</li>
</ul>
</li>
<li>
<p>表示整个数组<font color="#ff0000">首元素的首地址</font>：</p>
<ul>
<li>其它情况</li>
</ul>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int arr[10] ; // arr 表示整个数组的首地址</span><br><span class="line">int len = sizeof arr ; // arr 表示整个数组的首地址 ， sizeof 运算符后的括号可以省略</span><br><span class="line">int (* p) [10] = &amp;arr; //arr 表示整个数组的首地址</span><br><span class="line"></span><br><span class="line">int *p1 = arr ; // arr 表示数组的首元素的首地址</span><br></pre></td></tr></table></figure>
<h3 id="数组下标">数组下标</h3>
<p>数组的下标实际上只是编译器提供一种简写，实际上如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int a [100] ;</span><br><span class="line">a[10] = 250 ;    //  ====&gt; *(a+10) = 250 ;</span><br></pre></td></tr></table></figure>
<p>通过加法交换律，有如下结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a[10] = 250 ;</span><br><span class="line"></span><br><span class="line">*(a+10) = 250 ;</span><br><span class="line">*(10+a) = 250 ;</span><br><span class="line">10[a] = 250 ;</span><br></pre></td></tr></table></figure>
<h3 id="字符串常量">字符串常量</h3>
<p>字符串常量是一个被存放在常量区的字符串，实际上也可称为一个<font color="#ff0000">匿名数组</font>。</p>
<p>匿名数组，同样满足数组名的含义。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char * msg1 = &quot;Hello&quot; ;// &quot;Hello&quot; 字符串常量首元素的首地址</span><br><span class="line">char * msg2 = &quot;Hello&quot;+1 ;</span><br><span class="line"></span><br><span class="line">printf(&quot;%s\n&quot;, &quot;Hello&quot; ) ;// &quot;Hello&quot; 字符串常量首元素的首地址</span><br><span class="line">printf(&quot;%s\n&quot;, &amp;&quot;Hello&quot; ) ; // &quot;Hello&quot; 字符串常量的整个数组的地址</span><br><span class="line"></span><br><span class="line">printf(&quot;%c\n&quot;, &quot;Hello&quot;[4] ) ; // &quot;Hello&quot; 字符串常量首元素的首地址 [4]，[4] 相当于+4个单位（char） 得到 ‘o’</span><br></pre></td></tr></table></figure>
<p>字符串在内存种的存储方式：</p>
<p><img src="https://v3.wmnzsx.eu.org/i/1/2023/12/04/o2wz2s-1.webp" alt="C-array5"></p>
<h3 id="零长数组">零长数组</h3>
<p>概念： 数组的长度为0 ， char arr [0] ;</p>
<p>用途：一般会放在结构体的末尾， 作为可变长度的入口。（数组是唯一一个允许越界访问的载体）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line">int a;</span><br><span class="line">char b ;</span><br><span class="line">float c ;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">int len ;</span><br><span class="line">char arr[0] ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct node *p = malloc(sizeof(struct node) + 20 );// + 20 就是在原有的基础上增加20字节</span><br><span class="line">p‐&gt;len = 20 ; // 设置额外增长的长度为 20</span><br></pre></td></tr></table></figure>
<p><img src="https://v3.wmnzsx.eu.org/i/1/2023/12/04/o3ioop-1.webp" alt="C-array6"></p>
<h3 id="变长数组">变长数组</h3>
<p>概念： 使用一个变量作为数组的长度（元素的个数）。</p>
<p>重点： 变长数组并不是说在任意时候他的长度可以随意变化，实际上只是在定义之前数组的长度是未知的由一个变量来决定，但是定义语句过后变长数组的长度由定义那一刻变量的大小来决定。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int a = 200 ; // a 作为一个普通的变量 ， 200 则可以作为arr 的长度</span><br><span class="line">a = 99 ; // 99 可以作为 arr 的长度</span><br><span class="line"></span><br><span class="line">int arr[a]; // a 当前是 99 ， 因此数组arr 的长度已经确定为 99，之后该数组的长度不会再变换</span><br><span class="line"></span><br><span class="line">a = 10 ; // a = 10 并不会影响上面数组的长度</span><br></pre></td></tr></table></figure>
<p><mark>注意：</mark></p>
<ul>
<li>因为数组的长度未确定，因此它不允许初始化。</li>
<li>在使用的时候可以通过该变长数组来有限的节省内存空间。</li>
</ul>
<h3 id="多维数组">多维数组</h3>
<ol>
<li>
<p>概念：数组内部的成员也是数组</p>
<p><code>int a [2][3] ;</code></p>
<p><img src="https://v3.wmnzsx.eu.org/i/1/2023/12/10/qiew66-1.webp" alt="C-array7"></p>
</li>
<li>
<p>定义与初始化</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int arr[2][3] = &#123; &#123;1,2,3&#125; , &#123; 4,5,6&#125; &#125;;</span><br><span class="line">int arr1[2][3] = &#123; 1,2,3,4,5,6&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>如何引用</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">arr[0] [0] = 100 ; // 数组：（通过下标来访问）    //arr[0]指&#123;1,2,3&#125;</span><br><span class="line">*(*(arr+0)+0) = 100 ; // 通过指针偏移来访问</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>实例</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int arr[2][3] = &#123;&#123;1, 2, 3&#125;, &#123;4, 5, 6&#125;&#125;;</span><br><span class="line">int arr1[2][3] = &#123;1, 2, 3, 4, 5, 6&#125;;</span><br><span class="line"></span><br><span class="line">int *p = arr; // p指向数组arr 的首元素，即&#123;1, 2, 3&#125;的地址</span><br><span class="line"></span><br><span class="line">for (int i = 0; i &lt; 2; i++)</span><br><span class="line">&#123;</span><br><span class="line">    for (int j = 0; j &lt; 3; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;arr[%d][%d]:%d\t&quot;, i, j, arr[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">for (int i = 0; i &lt; 6; i++)</span><br><span class="line">&#123; // *arr 得到元素&#123;1, 2, 3&#125;中的 1 的地址， + 1 则是加一个 int 类型</span><br><span class="line"></span><br><span class="line">    printf(&quot;*(*(arr+%d)):%d\t&quot;, i, *(*(arr) + i));</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">for (int i = 0; i &lt; 6; i++)</span><br><span class="line">&#123; // arr 指的是首元素的首地址 &#123;1,2,3&#125; 的首地址 + 1则 + 3个整型</span><br><span class="line"></span><br><span class="line">    printf(&quot;*(*(arr+%d)):%d\t&quot;, i, *(*(arr + i)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (int i = 0; i &lt; 6; i++)</span><br><span class="line">&#123; // p 只是一个普通的整型指针， 与二维数组没有任何的关系</span><br><span class="line"></span><br><span class="line">printf(&quot;*(p+%d)：%d\n&quot; , i ,*(p+i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>笔记</category>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言学习六：数组与指针的结合</title>
    <url>/2023/10/22/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E5%85%AD%EF%BC%9A%E6%95%B0%E7%BB%84%E4%B8%8E%E6%8C%87%E9%92%88%E7%9A%84%E7%BB%93%E5%90%88/</url>
    <content><![CDATA[<h2 id="基础">基础</h2>
<p><strong>示例一：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int arr [5] = &#123;1,2,3,4,5&#125; ;</span><br><span class="line">int * p1 = &amp;arr ;</span><br><span class="line">int * p2 = arr ;</span><br><span class="line"></span><br><span class="line">printf(&quot;*p1:%d\n&quot; , *(p1+1)) ;</span><br><span class="line">printf(&quot;*p2:%d\n&quot; , *(p2+1)) ;</span><br></pre></td></tr></table></figure>
<p><img src="https://v3.wmnzsx.eu.org/i/1/2023/11/24/115fr9q-1.webp" alt="C-array-pointer1"></p>
<p><strong>示例二：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int arr [5] = &#123;1,2,3,4,5&#125; ;</span><br><span class="line">int * p2 = &amp;arr[2] ;</span><br><span class="line"></span><br><span class="line">printf(&quot;*p2‐1:%d\n&quot; , *(p2‐1)) ;</span><br><span class="line">printf(&quot;*p2:%d\n&quot; , *p2) ;</span><br><span class="line">printf(&quot;*p2+1:%d\n&quot; , *(p2+1)) ;</span><br></pre></td></tr></table></figure>
<p>以上代码是通过指针 p2 来访问数组中的元素。一开始定义p2并初始化让指针p2 指向数组中第3个元素的地址。当我们使用p2 进行指针加减运算的时候 ，由于指针是整型的，可以访问到数组中的下一个元素以及上一个元素。</p>
<h2 id="数组指针">数组指针</h2>
<p>概念：专门用来指向一个数组的指针。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int * p ;</span><br><span class="line">int (* p) [5] ; //定义一个 名为p 的指针，</span><br><span class="line"></span><br><span class="line">//并且确定他指向的类型为int [5] ,一个拥有5个元素的整型数组4</span><br><span class="line">int arr [5] = &#123;1,2,3,4,5&#125; ;</span><br><span class="line">int (*p) [5] = arr ;</span><br><span class="line"></span><br><span class="line">printf(&quot;arr:%p\n&quot; , &amp;arr );</span><br><span class="line">printf(&quot;%p‐‐‐%d\n&quot; ,p , (*p)[2] ); // 3 * p ==&gt; arr</span><br><span class="line">printf(&quot;%p‐‐‐%d\n&quot; , p+1 , (*(p+1))[2] ); // 已经越界访问</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong><br>
以上代码中 p指向的是 一个整型数组并有5个元素。 因此在对p 进行加减运算时， 是加减一个数组。</p>
<h2 id="指针数组">指针数组</h2>
<p>概念：专门用来存放指针的数组，称为指针数组。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int a = 100 ;</span><br><span class="line">int b = 250 ;</span><br><span class="line">int c = 550 ;</span><br><span class="line">int d = 256 ;</span><br><span class="line">int e = 998 ;</span><br><span class="line"></span><br><span class="line">int * p [5] = &#123;&amp;a, &amp;b , &amp;c , &amp;d , &amp;e&#125; ; // 定义一个名字为 p的数组， 并且确定该数组中用来存放int * 整型地址</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for (size_t i = 0; i &lt; 5; i++)</span><br><span class="line"> &#123;</span><br><span class="line">    printf(&quot;*p[%d]:%d \n&quot; , i , *(p[i]) ); // p[0] ‐‐&gt; &amp;a</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="题">题</h2>
<h3 id="理解题">理解题</h3>
<ol>
<li>
<p>题 1</p>
<p><img src="https://v3.wmnzsx.eu.org/i/1/2023/12/12/nj93fp-1.webp" alt="C-array-pointer2"></p>
</li>
<li>
<p>题 2</p>
<p><img src="https://v3.wmnzsx.eu.org/i/1/2023/12/12/nj92cn-1.webp" alt="C-array-pointer3"></p>
<p><code>&amp;b</code>—&gt;<code>b</code>—&gt;<code>*b</code>—&gt;<code>**b</code></p>
<p>整个数组的地址—&gt;第一个元素（{1，2，3，4}）的地址—&gt;“1“的地址—&gt;“1”的值</p>
<p>补充：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">printf(&quot;**(b+1):%d\n&quot;, **(b + 1));  // 打印5</span><br><span class="line">printf(&quot;*(*(b+2)+2):%d\n&quot;, *(*(b + 2) + 2)); // 打印11</span><br><span class="line"></span><br><span class="line">// 使用指针来访问二维数组的每一个元素,打印所有</span><br><span class="line">for (size_t i = 0; i &lt; 12; i++)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;%d\t&quot;, *((*b) + i));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用数组来访问二维数组</span><br><span class="line">for (size_t i = 0; i &lt; 3; i++)</span><br><span class="line">&#123;</span><br><span class="line">    for (size_t j = 0; j &lt; 4; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;b[%d][%d]:%d\t&quot;, i, j, b[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>题 3</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int arr[] = &#123; 1, 3, 5, 7, 9&#125;;</span><br><span class="line">    int i, *p = arr, len = sizeof(arr) / sizeof(int);</span><br><span class="line">    for(i=0; i&lt;len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        //   * 和 ++ 得优先级是同级的 ， 又因为当前这一级的结合性是从右往左 ， 因此先 p++  , 但是是后缀，所以先预算再++</span><br><span class="line"></span><br><span class="line">        printf(&quot;%d\n&quot;, *p++ );   // 先运算（*p）得到 1  ， 然后再（p++）地址+1</span><br><span class="line">        printf(&quot;%d\n&quot;, (*p)++ );  // 先得到p得内容  3 ， 然后再对3进行自加</span><br><span class="line">        for (size_t j = 0; j &lt; len ; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;arr[%d]:%d\t&quot; , j , arr[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><mark>注意：</mark></p>
<ul>
<li>
<p>题①中： <code>p=&amp;arr;</code> p 是一个地址，为整个数组的首地址，相当于&amp;arr。解一次引用，即* p 则为数组首元素的地址。</p>
</li>
<li>
<p>题③中： <code>* p=arr;</code> arr 为数组首元素的地址，p 指向的是首元素的首地址 （p 只是一个普普通通的整型指针），<code>*p</code> 意思为解一次引用，即第一个元素的值。—&gt; 当我们使用 <code>*p</code> 解引用指针 <code>p</code> 时，我们获取的是指针 <code>p</code> 所指向内存位置的值，<code>p</code> 是指向整型数组的指针，所以 <code>*p</code> 将获取数组中的一个整数值。</p>
</li>
</ul>
</li>
<li>
<p>题 4</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int a = 1, b = 2, c = 3;</span><br><span class="line">    int *arr[3] = &#123;&amp;a, &amp;b, &amp;c&#125;;//整型指针数组</span><br><span class="line">    int **parr = arr; // 第一部分 *p ， 第二部分 int * 说明类型   为指针类型   +1 则+1个指针类型 8字节（64）</span><br><span class="line"></span><br><span class="line">    //    arr[0]  --&gt; &amp;a   *&amp;a --&gt; a</span><br><span class="line">    printf(&quot;%d, %d, %d\n&quot;, *arr[0], *arr[1], *arr[2]);</span><br><span class="line">    printf(&quot;%d, %d, %d\n&quot;, **(parr+0), **(parr+1), **(parr+2));</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>题 5</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    char *lines[5] =     //字符指针数组（里面的字符串是以 `char*` 类型的指针形式存在的）</span><br><span class="line">    &#123;</span><br><span class="line">    &quot;COSC1283/1984&quot;,</span><br><span class="line">    &quot;Programming&quot;,</span><br><span class="line">    &quot;Techniques&quot;,</span><br><span class="line">    &quot;is&quot;,</span><br><span class="line">    &quot;great fun&quot;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    char *str1 = lines[1];        </span><br><span class="line">    char *str2 = *(lines + 3);</span><br><span class="line">    char c1    = *(*(lines + 4) + 6);  </span><br><span class="line">    char c2    = (*lines + 5)[5];  </span><br><span class="line">    char c3    = *lines[0] + 2;</span><br><span class="line"></span><br><span class="line">    printf(&quot;str1 = %s\n&quot;, str1);  </span><br><span class="line">    printf(&quot;str2 = %s\n&quot;, str2);  </span><br><span class="line">    printf(&quot;c1   = %c\n&quot;, c1);    </span><br><span class="line">    printf(&quot;c2   = %c\n&quot;, c2);    </span><br><span class="line">    printf(&quot;c3   = %c\n&quot;, c3);    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://v3.wmnzsx.eu.org/i/1/2023/12/12/nj903c-1.webp" alt="C-array-pointer4"></p>
</li>
<li>
<p>题 6</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    int num;</span><br><span class="line">    int (*p)[5] = NULL;  //数组指针  </span><br><span class="line">    int arr[5] =  &#123;5,2,4,5,7&#125;;</span><br><span class="line">    p = &amp;arr;</span><br><span class="line"></span><br><span class="line">    printf(&quot;=====================================\n&quot;);</span><br><span class="line">    num = sizeof(arr)/sizeof(arr[0]);</span><br><span class="line">    for(i=0;i&lt;num;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;*p[%d] = %d\n&quot;,i,*p[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(&quot;=====================================\n&quot;);</span><br><span class="line">    for(i=0;i&lt;num;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;*(p+%d) = %p\n&quot;,i,*(p+i));  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(&quot;=====================================\n&quot;);</span><br><span class="line">    for(i=0;i&lt;num;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;p[%d] = %p\n&quot;,i,p[i]);    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(&quot;=====================================\n&quot;);</span><br><span class="line">    for(i=0;i&lt;num;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;(*p)[%d] = %d\n&quot;,i,(*p)[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://v3.wmnzsx.eu.org/i/1/2023/12/12/nj8xrz-1.webp" alt="C-array-pointer5"></p>
</li>
</ol>
<h3 id="更多">更多</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//程序段一</span><br><span class="line">int arr[] = &#123; 1, 3, 5, 7, 9&#125;;</span><br><span class="line">int *p = &amp;arr[2];  // p只是一个普普通通的整型指针, 并指向的 数据5 的地址，是一个地址</span><br><span class="line">// arr[2] 是数据 5 ， &amp; 则把数据5 的地址进行取出</span><br><span class="line">printf(&quot;%d, %d, %d, %d, %d\n&quot;, *(p-2), *(p-1), *p, *(p+1), *(p+2) ); </span><br><span class="line">//*p解一次引用，则打印出1，3，5，7，9</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//程序段二</span><br><span class="line">int (*p)[5] = NULL; //数组指针</span><br><span class="line">int arr[5] = &#123;1,2,4,5,7&#125;;</span><br><span class="line">p = &amp;arr;   // p指向整个数组的地址</span><br><span class="line">printf(&quot;p    = %p\n&quot;,p);        //&amp;arr，地址</span><br><span class="line">printf(&quot;*p   = %p\n&quot;,*p );      //解一次引用，数组首元素的地址</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//程序段三</span><br><span class="line">int arr[] = &#123; 1, 3, 5, 7, 9&#125;;</span><br><span class="line">int *p = arr;  //p只是一个普普通通的整型指针, 并指向的数组首元素的地址（arr） </span><br><span class="line">printf(&quot;%d\n&quot;, *p);  //*p，解一次引用，得到数组首元素的值，即 1</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>笔记</category>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>Hax&amp;Woiden</title>
    <url>/2022/12/01/Hax-Woiden/</url>
    <content><![CDATA[<div class="note orange icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p>简单记录一下我每次拿到hax&amp;woiden后做的事</p>
</div>
<div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p>开始前先看最后的注意事项，本教程仅为个人备忘录，不保证内容正确性</p>
</div>
<hr>
<h2 id="注册-ssh-连接-hax">注册&amp;ssh 连接 hax</h2>
<ol>
<li>
<p>注册网站： <a href="https://hax.co.id">https://hax.co.id</a></p>
<p><img src="https://v3.wmnzsx.eu.org/i/1/2023/11/24/11a8uul-1.webp" alt="Hax&amp;Woiden1"></p>
</li>
<li>
<p>翻译一下就看懂，其实很简单的</p>
<p>创建 ipv 4 转发后，ssh 连就好了，步骤就懒得说了，我电脑用的 <a href="https://github.com/kingToolbox/WindTerm/releases">WindTerm</a>，手机用的 JuiceSSH</p>
</li>
<li>
<p>当然也可以不用创建 ipv 4 转发，可以直接用<a href="https://ssh.hax.co.id/">官方的网页 ssh 登录</a>，直接用 ipv6。</p>
</li>
</ol>
<hr>
<h2 id="注册-ssh-连接-woiden">注册&amp;ssh 连接 woiden</h2>
<ol>
<li>
<p>注册网站： <a href="https://woiden.id">https://woiden.id</a></p>
<blockquote>
<p>也是一样的，其实 woiden 和 hax 流程都差不多的，一个纯 ipv 6 机器，一个 nat 机器。这里就不多说了</p>
</blockquote>
<p><img src="https://v3.wmnzsx.eu.org/i/1/2023/11/24/11a8n1o-1.webp" alt="Hax&amp;Woiden2"></p>
</li>
</ol>
<h2 id="安装-warp-和-x-ui">安装 warp 和 x-ui</h2>
<ol>
<li>
<p>安装 warp（以 F 佬 WARP 脚本为例）</p>
<p>复制粘贴进 ssh 回车运行：</p>
<p><code>wget -N https://gitlab.com/fscarmen/warp/-/raw/main/menu.sh &amp;&amp; bash menu.sh</code></p>
<p>点击第一个，添加 warp ipv 4 网络接口 (有可能刷新不出来 ip，可以试试其他 warp 脚本)</p>
</li>
<li>
<p>安装 x-ui 面板（二选一，我用的②）</p>
<p>① <a href="https://github.com/vaxilu/x-ui">安装原版x-ui面板</a></p>
<p>直接一条命令回车，然后看脚本，安装，设置用户名密码端口，浏览器访问，然后直接面板操作</p>
<p><code>bash &lt;(curl -Ls https://raw.githubusercontent.com/vaxilu/x-ui/master/install.sh)</code></p>
<p>② <a href="https://github.com/FranzKafkaYu/x-ui">FranzKafkaYu版x-ui面板</a></p>
<p><code>bash &lt;(curl -Ls https://raw.githubusercontent.com/FranzKafkaYu/x-ui/master/install.sh)</code></p>
</li>
</ol>
<hr>
<h2 id="套-cf-加速">套 cf 加速</h2>
<ol>
<li>
<p>上面创建好的节点只有 ipv6，没有 ipv4，有些网站、软件只能用 ipv 4，所以还需要套 cf 加速</p>
</li>
<li>
<p>教程：</p>
<ul>
<li>注册 <a href="https://dash.cloudflare.com/">cloudflre</a> 和 <a href="https://www.freenom.com/">freenom</a> （这个废了，自己找域名），当然也可以不用 freenom 免费域名，随便你，freenom 免费域名注册方法自行谷歌</li>
<li>在 cf 首页点击添加网站，将注册好的域名添加到 cf 上，点网站点进去，左侧添加 dns，然后添加 ssl</li>
</ul>
<p><img src="https://v3.wmnzsx.eu.org/i/1/2023/11/24/11a8zj9-1.webp" alt="Hax&amp;Woiden3"></p>
<p><img src="https://v3.wmnzsx.eu.org/i/1/2023/11/24/11a8rgv-1.webp" alt="Hax&amp;Woiden4"></p>
<p><img src="https://v3.wmnzsx.eu.org/i/1/2023/11/24/11a8ngp-1.webp" alt="Hax&amp;Woiden5"></p>
<p><img src="https://v3.wmnzsx.eu.org/i/1/2023/11/24/11a8gfi-1.webp" alt="Hax&amp;Woiden6"></p>
</li>
</ol>
<hr>
<h2 id="注意事项">注意事项</h2>
<ol>
<li>Hax 网站可能进不去，那是因为你开启了去广告的浏览器插件</li>
<li>如果 hax 中你没用去广告的浏览器插件，那可能是 fq 软件里面的去广告规则导致的，把相应的关闭就行，以 v 2 rayN 为例：设置➡路由设置➡双击绕过大陆➡规则列表里找到 block 双击打开，在 geosite: category-ads-all 前面加个#➡保存</li>
<li>可以不用节点，只不过网站进去有点慢</li>
<li>Hax / Woiden OpenVZ VPS 开启 TUN 模块教程
<ul>
<li>在 <a href="https://hax.co.id/vps-control">https://hax.co.id/vps-control</a> （或 <a href="https://woiden.id/vps-control">https://woiden.id/vps-control</a> ） 点击 Enable TUN 按钮</li>
<li>待 TUN 模块启动成功后，先 Stop 让 VPS 关机，然后再 Start 开机</li>
<li>输入此命令：<code>cat /dev/net/tun</code> ，然后看见<code> cat: /dev/net/tun: File descriptor in bad state</code> 即为成功启用 TUN 模块</li>
</ul>
</li>
<li>也可以不用 x-ui 面板，把命令换成下面这个就行<br>
<code>bash &lt;(curl -s -L https://git.io/v2ray.sh)</code></li>
<li>Hax 和 woiden 每天北京时间凌晨 1 点补货（要抢），7 天续期，tg 机器人最后两天会发消息提醒</li>
<li>安装 bbr 加速（仅限 KVM，openvz 不行，但可以自己网上找魔改 bbr）
<ul>
<li>可以使用 virt-what 查看 VPS 使用哪种虚拟化技术（OpenVZ KVM Xen），具体的自行 Google</li>
<li>卸载内核版本 (一般用这个即可)<br>
<code> wget -O tcp.sh &quot;https://git.io/coolspeeda&quot; &amp;&amp; chmod +x tcp.sh &amp;&amp; ./tcp.sh</code></li>
<li>不卸载内核版本<br>
<code> wget -O tcpx.sh &quot;https://git.io/JYxKU&quot; &amp;&amp; chmod +x tcpx.sh &amp;&amp; ./tcpx.sh</code><br>
一般 BBR+FQ 加速就行，当然也可以不使用 bbr</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>教程</category>
        <category>VPS</category>
      </categories>
      <tags>
        <tag>白嫖VPS</tag>
      </tags>
  </entry>
  <entry>
    <title>利用Github搭建免费图床</title>
    <url>/2023/11/17/Github%E5%9B%BE%E5%BA%8A/</url>
    <content><![CDATA[<h2 id="新建一个Github仓库">新建一个Github仓库</h2>
<p>怎么注册Github并新建一个Github仓库自行谷歌，注意仓库要公开仓库</p>
<h2 id="生成一个-Token">生成一个 Token</h2>
<ol>
<li>
<p>点击右上角用户头像 -&gt; 选择 设置</p>
<p><img src="https://v3.wmnzsx.eu.org/i/1/2023/11/25/n6bfed-1.webp" alt="github-image1"></p>
</li>
<li>
<p>点击网站左侧的最下面的开发者设置</p>
<p>左侧点击 <code>developer settings</code> ，再点击 <code>personal access tokens</code> ，然后点击 <code>generate new token</code></p>
<p><img src="https://v3.wmnzsx.eu.org/i/1/2023/11/25/n7grnz-1.png" alt="github-image2"></p>
<p>Note 用来说明你创建 token 的用途，填写Token描述，scopes 中只需要选 repo 的所有选项即可,然后点击Generate token生成一个Token</p>
<p><img src="https://v3.wmnzsx.eu.org/i/1/2023/11/25/n8kyhw-1.png" alt="github-image3"></p>
<blockquote>
<p>注意这个 Token 只会显示一次，自己先保存下来，或者等后面配置好 PicGo 后再关闭此网页，如果没有记住，等再查看时就只能重新生成</p>
</blockquote>
</li>
</ol>
<h2 id="配置-PicGo">配置 PicGo</h2>
<h3 id="使用-jsdelivr-作为-CDN-加速">使用 jsdelivr 作为 CDN 加速</h3>
<blockquote>
<p>其实使用 jsdelivr 作为 CDN 加速已经不推荐了，现在jsdelivr太慢了，有vps的可以自行搭建图床，或者直接使用别人提供的名气较大的图床（有风险，毕竟东西在别人哪里，什么时候删了都不知道）</p>
</blockquote>
<ol>
<li>
<p>首先下载PicGo</p>
<p>文档地址：<a href="https://picgo.github.io/PicGo-Doc/zh/guide/">PicGo is Here | PicGo</a></p>
<p>下载地址：<a href="https://github.com/Molunerfinn/PicGo/releases">Releases · Molunerfinn/PicGo · GitHub</a></p>
</li>
<li>
<p>打开PicGo工具进行配置</p>
<p><img src="https://v3.wmnzsx.eu.org/i/1/2023/11/25/ndaa2w-1.webp" alt="github-image4"></p>
<ul>
<li>在 PicGo 中，找到图床设置 -&gt; GitHub图床。</li>
<li>设定仓库名：按照 用户名/图床仓库名 的格式填写</li>
<li>设定分支名：main （#分支默认是main，也可去github对应仓库查看）</li>
<li>设定 Token：粘贴之前生成的Token</li>
<li>指定存储路径：填写想要储存的路径，如 img/，这样就会在仓库下创建一个名为img的文件夹，图片将会储存在此文件夹中。</li>
<li>设定自定义域名：它的的作用是，在图片上传后，PicGo 会按照自定义域名+上传的图片名的方式生成访问链接，放到粘贴板上，因为我们要使用 jsDelivr 加速访问，所以可以设置为 <code>https://cdn.jsdelivr.net/gh/用户名/图床仓库名@分支</code></li>
</ul>
<p><mark>注意</mark>：理论上GitHub仓库大小是100g,但到了1g就会有人工审核,而使用jsdelivr加速的文件到达50m（也就是仓库大小）仓库里的资源就有可能失效,仓库理论上是无限建的,到了50m可以新建一个新的来达到白嫖的效果</p>
</li>
</ol>
<h3 id="使用-其他加速-作为-CDN-加速">使用 其他加速 作为 CDN 加速</h3>
<p>待。。。</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>折腾</category>
      </categories>
      <tags>
        <tag>折腾</tag>
        <tag>图床</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo常用命令</title>
    <url>/2022/12/14/Hexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="新建并部署上传">新建并部署上传</h2>
<h3 id="新建">新建</h3>
<p><code>hexo new [layout] &lt;title&gt;</code></p>
<p>新建一篇文章。如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来。</p>
<p>例如：<code>hexo new &quot;post title with whitespace&quot;</code></p>
<h3 id="清除缓存文件">清除缓存文件</h3>
<p><code>hexo clean</code></p>
<p>清除缓存文件 (db.json) 和已生成的静态文件 (public)。<br>
在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。</p>
<h3 id="生成静态文件">生成静态文件</h3>
<p><code>hexo generate</code>   #该命令可以简写为:<code>hexo g</code></p>
<table>
<thead>
<tr>
<th><strong>选项</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>-d ,  --deploy</td>
<td>文件生成后立即部署网站</td>
</tr>
<tr>
<td>-w ,  --watch</td>
<td>监视文件变动</td>
</tr>
<tr>
<td>-b ,  --bail</td>
<td>生成过程中如果发生任何未处理的异常则抛出异常</td>
</tr>
<tr>
<td>-f ,  --force</td>
<td>强制重新生成文件<br/>Hexo 引入了差分机制，如果 <code>public</code> 目录存在，那么 <code>hexo g</code> 只会重新生成改动的文件。<br/>使用该参数的效果接近 <code>hexo clean &amp;&amp; hexo generate</code></td>
</tr>
<tr>
<td>-c ,  --concurrency</td>
<td>最大同时生成文件的数量，默认无限制</td>
</tr>
</tbody>
</table>
<h3 id="本地预览">本地预览</h3>
<p><code>hexo server</code>   #该命令可以简写为：hexo s</p>
<p>启动服务器。默认情况下，访问网址为： <a href="http://localhost:4000/">http://localhost:4000/</a></p>
<table>
<thead>
<tr>
<th><strong>选项</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>-p, --port</td>
<td>重设端口</td>
</tr>
<tr>
<td>-s ,  --static</td>
<td>只使用静态文件</td>
</tr>
<tr>
<td>-l ,  --log-s ,  --static</td>
<td>启动日记记录，使用覆盖记录格式</td>
</tr>
</tbody>
</table>
<h3 id="部署网站">部署网站</h3>
<p><code>hexo deploy</code>   #该命令可以简写为：hexo d</p>
<p>部署网站并上传</p>
<table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>-g ,  --generate</td>
<td>部署之前预先生成静态文件</td>
</tr>
</tbody>
</table>
<ul>
<li>显示 Hexo 版本</li>
</ul>
<p><code>hexo version</code></p>
<h2 id="待补充">待补充</h2>
]]></content>
      <categories>
        <category>教程</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>命令</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 学习系列</title>
    <url>/2023/12/11/Linux-%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>N1盒子刷armbian</title>
    <url>/2023/10/31/N1%E7%9B%92%E5%AD%90%E5%88%B7armbian/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Ubuntu 美化</title>
    <url>/2023/10/21/Ubuntu-%E7%BE%8E%E5%8C%96/</url>
    <content><![CDATA[<h2 id="主题优化">主题优化</h2>
<blockquote>
<p>参考：</p>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/344554622">Gnome插件推荐 - 知乎</a></li>
<li><a href="https://blog.csdn.net/nineya_com/article/details/128244009">Ubuntu 22.04 桌面美化之Mac Big Sur风格_ubuntu美化mac-CSDN博客</a></li>
<li><a href="https://www.bilibili.com/video/BV1LD4y1W7S6/?spm_id_from=333.337.search-card.all.click&amp;vd_source=979e709fec527b7f08f5ef06efb9ff78">将Ubuntu22.04美化为MacOs，Ubuntu+Mac=Ubunmac_哔哩哔哩_bilibili</a></li>
<li><a href="https://www.bilibili.com/video/BV1G14y1J7b5/?spm_id_from=333.1007.0.0&amp;vd_source=979e709fec527b7f08f5ef06efb9ff78">手把手教你Ubuntu 22.10 桌面美化_哔哩哔哩_bilibili</a></li>
<li><a href="https://yaozhijin.gitee.io/Ubuntu20-04%E7%BB%88%E6%9E%81%E7%BE%8E%E5%8C%96.html">Ubuntu20.04终极美化 - Tom的博客</a></li>
<li><a href="https://blog.csdn.net/qq_38263083/article/details/129529137">ubuntu22.04 安装优化（主题，软件，换源，插件扩展）_ubuntu主题怎么安装_灵泽~的博客-CSDN博客</a></li>
</ul>
</blockquote>
<h2 id="安装必要插件">安装必要插件</h2>
<blockquote>
<p>tweaks（优化）、extensions （扩展）</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt update &amp;&amp; sudo apt upgrade</span><br><span class="line">sudo apt install gnome-tweaks chrome-gnome-shell gnome-shell-extensions</span><br></pre></td></tr></table></figure>
<h3 id="安装浏览器插件：gnome">安装浏览器插件：gnome</h3>
<p>进入火狐浏览器后，ctrl + shift + a 打开扩展与插件，搜索 gnome shell 安装并启用插件</p>
<p><img src="https://v3.wmnzsx.eu.org/i/1/2023/11/24/11be5ml-1.webp" alt="ubuntu1"></p>
<p><img src="https://v3.wmnzsx.eu.org/i/1/2023/11/24/11bdtlv-1.webp" alt="ubuntu2"></p>
<h3 id="安装-User-Themes-插件">安装 User Themes 插件</h3>
<p>打开网址插件官网：<a href="https://extensions.gnome.org/">https://extensions.gnome.org/</a><br>
搜索 User Themes 插件，点击进入插件界面进行安装。</p>
<p><img src="https://v3.wmnzsx.eu.org/i/1/2023/11/24/11bd8bt-1.webp" alt="ubuntu3"></p>
<h3 id="安装主题">安装主题</h3>
<p>主题 Github 地址： <a href="https://github.com/vinceliuice/WhiteSur-gtk-theme">https://github.com/vinceliuice/WhiteSur-gtk-theme</a></p>
<blockquote>
<ul>
<li>为当前用户安装：在用户主目录创建 <code>.themes</code>，将主题文件解压在此</li>
<li>为所有用户安装：/usr/share/themes/</li>
</ul>
</blockquote>
<ol>
<li>
<p>进入主题目录，，执行如下命令进行主题安装。</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./install.sh -t all -N glassy -s 220</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>设置主题</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo ./tweaks.sh -g</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="安装图标">安装图标</h3>
<ol>
<li>
<p>Mac 图标下载地址： <a href="https://www.gnome-look.org/p/1400021">https://www.gnome-look.org/p/1400021</a></p>
<blockquote>
<ul>
<li>为当前用户安装：在用户主目录创建 <code>.icons</code> 目录，将图标压缩包中的文件解压在此</li>
<li>为所有用户安装：/usr/share/icons</li>
</ul>
</blockquote>
<p><img src="https://v3.wmnzsx.eu.org/i/1/2023/11/24/11bdhyg-1.webp" alt="ubuntu4"></p>
</li>
<li>
<p>应用主题和图标</p>
<p>搜索打开 <code>tweaks / 美化</code> （优化）应用，调整 <code>Icons / 图标</code>、<code>Shell</code>、<code>Legacy Applications / 过时应用程序</code> 三个配置。本文的配置如下：</p>
<p><img src="https://v3.wmnzsx.eu.org/i/1/2023/11/24/11bdlz5-1.webp" alt="ubuntu5"></p>
</li>
<li>
<p>元素位置调整</p>
<ul>
<li>将标题栏的操作按钮从右侧移动到左侧</li>
</ul>
<p><img src="https://v3.wmnzsx.eu.org/i/1/2023/11/24/11bdc1v-1.webp" alt="ubuntu6"></p>
<ul>
<li>调整桌面图标的大小和新图标的位置，将 <code>Dock</code> 栏从左侧调整到底部，并设置自动隐藏，取消 <code>Dock</code> 延伸到屏幕边缘的选项，调整 <code>Dock</code> 图标的大小。</li>
</ul>
<p><img src="https://v3.wmnzsx.eu.org/i/1/2023/11/24/11bdy7d-1.webp" alt="ubuntu7"></p>
<ul>
<li>更换壁纸<br>
<code>Mac</code> 壁纸可以从这个存储库中下载： <a href="https://github.com/vinceliuice/WhiteSur-wallpapers">https://github.com/vinceliuice/WhiteSur-wallpapers</a></li>
</ul>
</li>
</ol>
<h2 id="更多插件">更多插件</h2>
<p>进入 gnome 官网：<a href="https://extensions.gnome.org/">GNOME Shell Extensions</a></p>
<ul>
<li>blur my shell   —&gt;      抽屉界面爆玻璃效果</li>
<li>Compiz windows effect（by hermes83 ）   —&gt;      窗口特效-移动</li>
<li>Compiz alike magic lamp effect （by hermes83 ）   —&gt;      窗口特效-收起打开</li>
<li>Coverflow Alt-Tab （by dsheeler ） —&gt;      窗口切换特效   （花里胡哨，没必要）</li>
<li>NetSpeed （by hedayaty） —&gt;     上方状态栏显示网速，点击网速可以更换显示的内容<br>
版本不兼容，我没安装</li>
</ul>
<hr>
<h2 id="终端美化：zsh">终端美化：zsh</h2>
<blockquote>
<p>参考：</p>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/441676276">zsh 安装与配置：9步打造高效命令行 - 知乎</a></li>
<li><a href="https://www.bilibili.com/video/BV13P411v745/?spm_id_from=333.880.my_history.page.click&amp;vd_source=979e709fec527b7f08f5ef06efb9ff78">【Linux】从零开始的Ubuntu操作系统美化、优化、常用软件推荐_哔哩哔哩_bilibili</a></li>
</ul>
</blockquote>
<h3 id="安装-zsh">安装 zsh</h3>
<p>macOS：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew install zsh</span><br></pre></td></tr></table></figure>
<p>ubuntu：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">sudo apt-get install zsh</span><br></pre></td></tr></table></figure>
<p>ArchLinux/Manjaro：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo pacman -S zsh</span><br></pre></td></tr></table></figure>
<p>若你使用的是其他发行版本，则使用对应的包管理器安装即可。</p>
<blockquote>
<ul>
<li>安装好后，可以使用 <code>cat /etc/shells</code> 查看系统可以用的 shell</li>
<li>查看当前正在使用的 shell 的路径：<code>echo $SHELL</code></li>
<li>查看当前用户：<code>whoami</code></li>
</ul>
</blockquote>
<p>使用 <code>chsh -s /bin/zsh</code> 命令将 zsh 设置为系统默认 shell，然后注销登录一次，就生效了。</p>
<p><mark>注意：</mark>只在普通用户下使用 <code>chsh -s /bin/zsh</code> 的话，root 用户还是默认的 Bash，在 root 用户下使用，它将应用于指定的用户以及其他用户。这将导致系统中的所有用户（包括普通用户和超级用户）的默认 shell 都变为 Zsh。</p>
<p>第一次运行 zsh 时会进入如下的配置引导页面：<code>没截图</code></p>
<p><mark>输入<code>q</code></mark></p>
<ul>
<li>输入 <code>q</code> 会直接退出配置引导，下一次运行 zsh 时会再次进入配置引导。</li>
<li>输入 <code>0</code>，也会退出配置引导，但是会在当前用户目录生成一个空白的文件 <code>.zshrc</code>，下一次运行时就不会再进入配置引导。下一次运行时是否再进入配置引导，取决于用户目录下是否存在.zshrc 文件。</li>
<li>输入输入 <code>1</code> 后，就开始进行配置</li>
</ul>
<blockquote>
<p>由于 zsh 配置较为复杂，推荐使用下面配置管理工具 oh-my-zsh 来配置 zsh</p>
</blockquote>
<h3 id="安装-oh-my-zsh">安装 oh-my-zsh</h3>
<p>官方地址：<a href="https://ohmyz.sh/">Oh My Zsh - a delightful &amp; open source framework for Zsh</a></p>
<blockquote>
<p>可添加 <a href="https://ghproxy.com/">GitHub Proxy 代理加速</a></p>
</blockquote>
<p>①使用 curl 下载脚本并安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sh -c <span class="string">&quot;<span class="subst">$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)</span>&quot;</span></span><br></pre></td></tr></table></figure>
<p>②或者使用 wget 下载脚本并安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sh -c <span class="string">&quot;<span class="subst">$(wget https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh -O -)</span>&quot;</span></span><br></pre></td></tr></table></figure>
<p>然后同意使用 Oh-my-zsh 的配置模板覆盖已有的 <code>.zshrc</code>：</p>
<h3 id="配置-zsh">配置 zsh</h3>
<p>在 <a href="https://github.com/ohmyzsh/ohmyzsh/wiki/Themes">https://github.com/ohmyzsh/ohmyzsh/wiki/Themes</a> 中查看内置的主题样式和对应的主题名。这些内置主题已经放在 <code>～/.oh-my-zsh/themes</code> 目录下（<code>~/</code> 表示当前用户的主目录），不需要再下载</p>
<p><strong>更换自带主题</strong>：<br>
zsh 官方自带了很多不同风格的主题，可以自定义设定，在~/.zshrc 里面改一行即可。<br>
我这里为：<code>ZSH_THEME=&quot;sonicradish&quot;</code></p>
<h3 id="安装插件">安装插件</h3>
<h4 id="zsh-autosuggestions：命令提示">zsh-autosuggestions：命令提示</h4>
<p><a href="https://github.com/zsh-users/zsh-autosuggestions">zsh-autosuggestions</a> 是一个命令提示插件，，当你输入命令时，会自动推测你可能需要输入的命令，按下右键可以快速采用建议。</p>
<p>安装步骤：</p>
<ol>
<li>
<p>把插件下载到本地的 <code>~/.oh-my-zsh/custom/plugins</code> 目录：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/zsh-users/zsh-autosuggestions <span class="variable">$&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;</span>/plugins/zsh-autosuggestions</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>在 <code>.zshrc</code> 中，把 <code>zsh-autosuggestions</code> 加入插件列表：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 插件之间使用空格隔开</span></span><br><span class="line">plugins=(</span><br><span class="line">        git zsh-autosuggestions zsh-syntax-highlighting</span><br><span class="line">        )</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>开启新的 Shell 或执行 <code>source ~/.zshrc</code>，就可以开始体验插件。</p>
</li>
</ol>
<h4 id="zsh-syntax-highlighting：高亮，语法校验">zsh-syntax-highlighting：高亮，语法校验</h4>
<p><a href="https://github.com/zsh-users/zsh-syntax-highlighting">zsh-syntax-highlighting</a> 是一个命令语法校验插件，在输入命令的过程中，若指令不合法，则指令显示为红色，若指令合法就会显示为绿色。</p>
<p>把插件下载到本地的 <code>~/.oh-my-zsh/custom/plugins</code> 目录，其余命令和上面一样</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/zsh-users/zsh-syntax-highlighting.git $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-syntax-highlighting</span><br></pre></td></tr></table></figure>
<h3 id="补充">补充</h3>
<p>待写。。。</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux | vps 常用命令</title>
    <url>/2022/12/13/Linux_VPS%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p><mark><strong>Linux命令大全(手册)</strong></mark></p>
<ul>
<li>
<p><a href="https://www.linuxcool.com/">Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com)</a></p>
</li>
<li>
<p><a href="https://wangchujiang.com/reference/">Quick Reference &amp; Quick Reference (wangchujiang.com)</a></p>
</li>
<li>
<p><a href="https://wangchujiang.com/linux-command/">Linux命令搜索引擎 命令，Linux Linux命令搜索引擎 命令详解：最专业的Linux命令大全，内容包含Linux命令手册、详解、学习，值得收藏的Linux命令速查手册。 - Linux 命令搜索引擎 (wangchujiang.com)</a></p>
  <details class="toggle" ><summary class="toggle-button" style="">对应的GitHub仓库</summary><div class="toggle-content"><ul>
<li><a href="https://github.com/jaywcjlove/reference">GitHub - jaywcjlove/reference: 为开发人员分享快速参考备忘清单(速查表)</a></li>
<li><a href="https://github.com/jaywcjlove/linux-command">GitHub - jaywcjlove/linux-command: Linux命令大全搜索工具，内容包含Linux命令手册、详解、学习、搜集。https://git.io/linux</a></li>
</ul>
</div></details>
</li>
</ul>
<h2 id="常用命令">常用命令</h2>
<h3 id="Linux更新及常用软件安装命令">Linux更新及常用软件安装命令</h3>
<ol>
<li>
<p>Debian/Ubuntu常用命令：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">更新软件源&amp;更新软件：sudo apt update &amp;&amp; sudo apt upgrade</span><br><span class="line"></span><br><span class="line">查看内核版本：uname -a  </span><br><span class="line">查看ubuntu版本：cat /etc/issue  </span><br><span class="line">查看ip：ip addr show 或者 ifconfig</span><br><span class="line">关闭系统电源：sudo systemctl poweroff</span><br><span class="line"></span><br><span class="line">查看磁盘使用情况：df -h  </span><br><span class="line">查看交换内存使用情况：free -h  </span><br><span class="line">查看当前的内存使用情况：free -m  </span><br><span class="line">查看当前有哪些进程：ps -A  </span><br><span class="line">杀死一个进程：kill id / killall id / kill -9 id  </span><br><span class="line"></span><br><span class="line">安装 openssh-server：sudo apt install openssh-server  </span><br><span class="line">确认sshserver是否启动：ps -e | grep ssh  </span><br><span class="line"></span><br><span class="line">Linux开启原版BBR：  </span><br><span class="line">echo &quot;net.core.default_qdisc=fq&quot; &gt;&gt; /etc/sysctl.conf  </span><br><span class="line">echo &quot;net.ipv4.tcp_congestion_control=bbr&quot; &gt;&gt; /etc/sysctl.conf  </span><br><span class="line">sysctl -p  </span><br><span class="line">lsmod | grep bbr</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>常用工具：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install curl wget lrzsz vim cron unzip screen</span><br></pre></td></tr></table></figure>
 <details class="toggle" ><summary class="toggle-button" style="">点击此处展开/收起内容，来自 chatgpt 的解释</summary><div class="toggle-content"><ul>
<li><code>curl</code>：用于在终端中进行网络请求和数据传输，支持各种协议（如 HTTP、HTTPS、FTP 等）。</li>
<li><code>wget</code>：用于从Web服务器下载文件，支持HTTP、HTTPS和FTP协议，具有断点续传功能。</li>
<li><code>lrzsz</code>：提供了Xmodem、Ymodem和Zmodem等协议的文件传输功能，用于通过终端与远程主机进行文件传输。</li>
<li><code>vim</code>：一种强大的文本编辑器，常用于命令行环境下编辑文本文件。</li>
<li><code>cron</code>：用于在预定时间自动运行命令或脚本的任务调度程序。</li>
<li><code>unzip</code>：用于解压缩ZIP格式的压缩文件。</li>
<li><code>screen</code>：用于在终端中创建和管理多个会话，允许在不同的终端窗口或会话之间切换。</li>
</ul>
</div></details>
</li>
</ol>
<h3 id="Debian-Ubuntu-基础命令">Debian/Ubuntu 基础命令</h3>
<ol>
<li>
<p>apt/apt-get</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Debian系系统常用软件包管理指令，常用子命令：</span><br><span class="line">install    从仓库寻找并安装软件包</span><br><span class="line">remove    移除软件包及重要依赖</span><br><span class="line">autoremove    自动移除软件包及相关依赖</span><br><span class="line">update    更新软件仓库</span><br><span class="line">upgrade    获取软件更新并自动更新到最新版本</span><br><span class="line">search    关键词搜索软件包</span><br></pre></td></tr></table></figure>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">清理旧版本的软件缓存：sudo apt autoclean  </span><br><span class="line">清理所有软件缓存：sudo apt clean  </span><br><span class="line">删除系统不再使用的孤立软件：sudo apt autoremove</span><br><span class="line">修复软件包依赖问题：sudo apt-get install -f</span><br></pre></td></tr></table></figure>
 <details class="toggle" ><summary class="toggle-button" style="">点击此处展开/收起内容，来自 chatgpt 的解释</summary><div class="toggle-content"><p>对于Debian系系统，apt和apt-get是常用的软件包管理指令。下面是这些指令的常用子命令及其功能的解释：</p>
<ul>
<li>apt install <package>：从软件仓库中寻找并安装指定的软件包。你可以在软件包名称后面加上&quot;=&quot;和版本号来安装特定版本的软件包。</li>
<li>apt remove <package>：移除指定的软件包及其重要依赖。这个命令会卸载软件包并删除相关的配置文件。</li>
<li>apt autoremove：自动移除不再需要的软件包及其相关依赖。这个命令会删除之前安装的软件包中不再需要的依赖项。</li>
<li>apt update：更新软件仓库中的软件包信息。这个命令会从软件源中获取最新的软件包列表。</li>
<li>apt upgrade：获取软件更新并自动更新已安装的软件包到最新版本。这个命令会检查可用的软件包更新，并自动升级已安装的软件包到最新版本。</li>
<li>apt-cache search <keyword>：使用关键词在软件仓库中搜索软件包。这个命令会根据关键词查找匹配的软件包名称和描述。</li>
</ul>
<p>需要注意的是，apt是apt-get的高级包装工具，提供了更友好的用户界面和一些额外功能。在大多数情况下，你可以使用apt来替代apt-get，因为它提供了更直观的命令和输出。</p>
</div></details>
</li>
<li>
<p>netstat</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//用来显示网络状态，比较常用的有查看当前使用的端口等功能</span><br><span class="line">netstat -tunlp       #用于显示 tcp，udp 的端口和进程等相关</span><br><span class="line">netstat -tunlp |     #grep 端口号    查看指定端口占用情况</span><br><span class="line">netstat -ntlp        #查看全部tcp端口占用</span><br><span class="line">netstat -apu         #查看UDP端口占用</span><br><span class="line">netstat -i           #显示网卡列表</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>screen的一些基本命令（注意指令区分大小写）</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">screen -ls              #列出所有创建的窗口</span><br><span class="line">screen -ls              #列出所有创建的窗口</span><br><span class="line">screen -S xxxx          #新建一个名字为`xxxx`的新窗口并进入</span><br><span class="line">screen -r xxxx          #进入一个名字为`xxxx`的窗口，如果没有这个名字的窗口会显示`There is no screen to be resumed matching xxxx.`</span><br><span class="line">screen -R xxxx          #进入一个名字为`xxxx`的窗口，如果没有这个窗口会`自动创建`新窗口且名字为`xxxx`</span><br><span class="line"></span><br><span class="line">关闭screen               #进入要关闭的窗口，然后关闭当前的项目，再输入exit，即可退出窗口并从列表中移除</span><br><span class="line">screen -X -S xxxx quit   #删除一个名字为`xxxx`的窗口 </span><br><span class="line"></span><br><span class="line">screen -wipe             #列出全部窗口并自动移除无效的窗口</span><br><span class="line">Ctrl + a + d             #分离当前窗口（进入一个窗口后，先按ctrl+a,保持ctrl键再按d即可离开该窗口，不影响运行的项目）</span><br><span class="line">Ctrl + a + k             #关闭当前窗口，终止窗口的进程</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Linux用户与用户组的添加</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//添加普通账户</span><br><span class="line">//最基础的使用方法如下：</span><br><span class="line">    sudo useradd guest     #新建用户</span><br><span class="line">    sudo passwd guest      #设置初始密码</span><br><span class="line">//添加更多参数：</span><br><span class="line">    sudo useradd -d &quot;/home/guest&quot; -m -s &quot;/bin/bash&quot; guest</span><br><span class="line">        -s：指定shell为/bin/bash</span><br><span class="line">        -d：指定其home目录为/home/guest</span><br><span class="line">        -m：如果指定的home目录不存在，则新建</span><br><span class="line"></span><br><span class="line">//添加sudo权限，先修改sudoers为可写权限</span><br><span class="line">chmod u+w /etc/sudoers</span><br><span class="line"></span><br><span class="line">//编辑sudoers</span><br><span class="line">vim /etc/sudoers</span><br><span class="line"></span><br><span class="line">//在 root ALL=(ALL:ALL) ALL 下面添加</span><br><span class="line">guest  ALL=(ALL:ALL) ALL    //允许用户guest执行sudo,需要密码</span><br><span class="line">%guest  ALL=(ALL:ALL) ALL    //允许用户组guest里面的用户执行sudo,需要密码</span><br><span class="line"></span><br><span class="line">//如果你想允许用户执行 sudo 时无需输入密码，可以使用以下：</span><br><span class="line">guest  ALL=(ALL:ALL) NOPASSWD: ALL    //允许用户guest执行sudo且不输入密码</span><br><span class="line">%guest  ALL=(ALL:ALL) NOPASSWD: ALL    //允许用户组guest里面的用户执行sudo且不输入密码</span><br><span class="line"></span><br><span class="line">//撤销sudoers写入权限</span><br><span class="line">chmod u-w /etc/sudoers</span><br><span class="line"></span><br><span class="line">//查看全部用户</span><br><span class="line">cat /etc/passwd</span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<h3 id="Linux-常用的一键脚本">Linux 常用的一键脚本</h3>
<h4 id="经常使用的脚本">经常使用的脚本</h4>
<ol>
<li>
<p>X-UI 一键脚本</p>
<p>①<a href="https://github.com/vaxilu/x-ui">原版</a> :</p>
<p><code>bash &lt;(curl -Ls https://raw.githubusercontent.com/vaxilu/x-ui/master/install.sh)</code></p>
<p>②<a href="https://github.com/FranzKafkaYu/x-ui">FranzKafkaYu</a> :</p>
<p><code>bash &lt;(curl -Ls https://raw.githubusercontent.com/FranzKafkaYu/x-ui/master/install.sh)</code></p>
<p>③V2ray-233blog 一键创建节点</p>
<p><code>bash &lt;(curl -s -L https://git.io/v2ray.sh)</code></p>
</li>
<li>
<p>WARP 一键脚本</p>
<p>①FSCARMEN (<a href="https://gitlab.com/fscarmen/warp.git">fscarmen / warp · GitLab</a>) :</p>
<p>首次运行 <code>wget -N https://gitlab.com/fscarmen/warp/-/raw/main/menu.sh &amp;&amp; bash menu.sh</code></p>
<p>日常维护 <code>warp</code></p>
<p>②P3TERX (<a href="https://github.com/P3TERX/warp.sh">https://github.com/P3TERX/warp.sh</a>) :</p>
<p>首次运行 <code>bash &lt;(curl -fsSL git.io/warp.sh) menu</code></p>
<p>日常维护 <code>bash warp.sh</code></p>
<p>③WARP-GO (<a href="https://gitlab.com/ProjectWARP/warp-go/-/tree/master/">https://gitlab.com/ProjectWARP/warp-go/-/tree/master/</a>) :</p>
<p>首次运行 <code>wget -N https://gitlab.com/fscarmen/warp/-/raw/main/menu.sh &amp;&amp; bash menu.sh</code></p>
<p>日常维护 <code>warp-go</code></p>
</li>
<li>
<p>bbr 加速（仅限 KVM，openvz 不行，但可以自己网上找魔改 bbr）</p>
 <details class="toggle" ><summary class="toggle-button" style="">官网链接地址，点击打开</summary><div class="toggle-content"><p><a href="https://blog.ylx.me/archives/783.html">Linux 一键安装常见/最新内核脚本锐速/BBRPLUS/BBR2 [100.0.1.25] - HJM</a> <br><br>
<a href="https://github.com/ylx2016/Linux-NetSpeed">GitHub - ylx2016/Linux-NetSpeed: 将Linux现常用的网络加速集成在一起</a></p>
</div></details>
<blockquote>
<p>一般 BBR+FQ 加速就行，当然也可以不使用 bbr</p>
</blockquote>
</li>
</ol>
<h4 id="以下一键脚本本人未测试，来自网上搜集，自行决定">以下一键脚本本人未测试，来自网上搜集，自行决定</h4>
<ol>
<li>
<p>V2ray-agent：</p>
<p>Github地址：<a href="https://github.com/mack-a/v2ray-agent">https://github.com/mack-a/v2ray-agent</a></p>
<p>支持快捷方式启动，安装完毕后，shell输入【vasma】即可打开脚本，脚本执行路径[/etc/v2ray-agent/install.sh]</p>
</li>
<li>
<p>Latest Version</p>
<p><code>wget -P /root -N --no-check-certificate &quot;https://raw.githubusercontent.com/mack-a/v2ray-agent/master/install.sh&quot; &amp;&amp; chmod 700 /root/install.sh &amp;&amp; /root/install.sh</code></p>
</li>
<li>
<p>Stable-v2.4.16【无gRPC】</p>
<p><code>wget -P /root -N --no-check-certificate &quot;https://raw.githubusercontent.com/mack-a/v2ray-agent/stable_v2.4.16/install.sh&quot; &amp;&amp; chmod 700 /root/install.sh &amp;&amp; /root/install.sh</code></p>
</li>
<li>
<p>UnixBench跑分工具测试</p>
<p>UnixBench下载地址：<a href="https://code.google.com/archive/p/byte-unixbench/downloads">https://code.google.com/archive/p/byte-unixbench/downloads</a></p>
<p><code>wget --no-check-certificate http://tools.laobuluo.com/tools/unixbench.sh chmod +x unixbench.sh ./unixbench.sh</code></p>
</li>
<li>
<p><a href="http://bench.sh">bench.sh</a> 测速脚本</p>
<p>Github地址：<a href="https://github.com/teddysun/across">https://github.com/teddysun/across</a></p>
<p><code>wget -qO- bench.sh | bash</code><br>
或者<br>
<code>curl -Lso- bench.sh | bash</code></p>
</li>
<li>
<p>BestTrace 路由追踪</p>
<p><code>wget https://cdn.ipip.net/17mon/besttrace4linux.zip</code><br>
<code>unzip besttrace4linux.zip</code><br>
<code>chmod +x besttrace</code><br>
<code>./besttrace 114.114.114.114</code></p>
</li>
<li>
<p>流媒体解锁检测脚本</p>
<p>Github地址：<a href="https://github.com/sjlleo/netflix-verify">https://github.com/sjlleo/netflix-verify</a></p>
</li>
<li>
<p>Netflix 解锁检测脚本</p>
<p><code>wget -O nf https://github.com/sjlleo/netflix-verify/releases/download/2.61/nf_2.61_linux_amd64 &amp;&amp; chmod +x nf &amp;&amp; clear &amp;&amp; ./nf</code></p>
</li>
</ol>
<hr>
<h2 id="进阶命令">进阶命令</h2>
<h3 id="docker和docker-compose安装与配置">docker和docker-compose安装与配置</h3>
<blockquote>
<p>更多请查看：  <a href="https://www.runoob.com/docker/docker-tutorial.html">Docker 教程 | 菜鸟教程 (runoob.com)</a></p>
</blockquote>
<h4 id="安装docker">安装docker</h4>
<ol>
<li>
<p>以 root 用户登录，执行一键脚本安装 Docker</p>
<p>升级源并安装软件（下面两行命令二选一，根据你自己的系统）</p>
<p>Debian / Ubuntu<br>
<code>apt update &amp;&amp; apt install -y wget vim</code></p>
<p>CentOS<br>
<code>yum update &amp;&amp; yum install -y wget vim</code></p>
</li>
<li>
<p>执行此命令等候安装 Docker</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#Ubuntu  </span><br><span class="line">curl -fsSL https://test.docker.com -o test-docker.sh  </span><br><span class="line">sudo sh test-docker.sh  </span><br><span class="line"></span><br><span class="line">#Debian  </span><br><span class="line">curl -fsSL https://get.docker.com -o get-docker.sh  </span><br><span class="line">sudo sh get-docker.sh  </span><br><span class="line"></span><br><span class="line">#CentOS  </span><br><span class="line">curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun</span><br></pre></td></tr></table></figure>
<blockquote>
<p>说明：请使用 KVM 架构的 VPS，OpenVZ 架构的 VPS 不支持安装 Docker。 更多关于 Docker 安装的内容参考 <a href="https://docs.docker.com/engine/install/">Docker 官方安装指南</a> 。</p>
</blockquote>
</li>
<li>
<p>国内源推荐  ：</p>
<ul>
<li><a href="http://hub-mirror.c.163.com/">http://hub-mirror.c.163.com</a></li>
<li><a href="https://registry.docker-cn.com/">https://registry.docker-cn.com</a></li>
<li><a href="https://docker.mirrors.ustc.edu.cn/">https://docker.mirrors.ustc.edu.cn</a></li>
<li><a href="https://docker.mirrors.ustc.edu.cn/">https://docker.mirrors.ustc.edu.cn</a></li>
</ul>
</li>
</ol>
<h4 id="安装docker-compose">安装docker-compose</h4>
<ol>
<li>
<p>最新发行的版本地址：<a href="https://github.com/docker/compose/releases">https://github.com/docker/compose/releases</a></p>
</li>
<li>
<p>运行以下命令以下载Docker Composed当前最新的稳定版本：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo curl -L &quot;https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意: 如果无法下载,可以本地下载好后上传到服务器/usr/local/bin/即可</p>
</blockquote>
</li>
<li>
<p>将可执行权限应用于二进制文件：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo chmod +x /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：如果命令docker-compose在安装后失败，请检查您的路径。您还可以创建指向/usr/local/bin/或路径中任何其他目录的符号链接。</p>
</blockquote>
</li>
<li>
<p>创建软链：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：如果命令 docker-compose 在安装后失败，请检查您的路径。您还可以创建指向/usr/local/bin/或路径中任何其他目录的符号链接。</p>
</blockquote>
</li>
<li>
<p>测试安装</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker-compose --version</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>卸载docker-compose</p>
<blockquote>
<p>直接移除二进制包即可</p>
</blockquote>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo rm /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="docker常用命令">docker常用命令</h3>
<ol>
<li>
<p>常用</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl start docker                    #启动  </span><br><span class="line">systemctl stop docker                     #停止  </span><br><span class="line">systemctl restart docker                  #重启  </span><br><span class="line">systemctl enable docker                   #开机自启动  </span><br><span class="line">systemctl status docker                   #运行状态  </span><br><span class="line">docker version                            #Docker 版本信息  </span><br><span class="line">docker info                               #Docker 系统信息  </span><br><span class="line"></span><br><span class="line">docker ps       #查看正在运行的容器  </span><br><span class="line">    # -a: 显示所有的容器，包括未运行的。</span><br><span class="line">    # -q: 静默模式，只显示容器编号。</span><br><span class="line">    # -n: 列出最近创建的n个容器。 </span><br><span class="line"></span><br><span class="line">docker rm 容器id                          #删除指定容器  </span><br><span class="line">docker images                             #查看本地所有的镜像  </span><br><span class="line">docker images -q                          #仅显示镜像id，常用于批量删除镜像  </span><br><span class="line">docker rmi 镜像id或镜像名称的前缀即可       #删除指定的本地镜像    </span><br><span class="line"></span><br><span class="line">#进入容器  </span><br><span class="line">docker exec -it 容器名/ID bash  </span><br><span class="line">#退出容器  </span><br><span class="line">exit                                      #容器直接退出  </span><br><span class="line">ctrl +P +Q                                #容器不停止退出       </span><br><span class="line"></span><br><span class="line">docker pull            #从镜像仓库中拉取或者更新指定镜像  </span><br><span class="line">docker push            #将本地的镜像上传到镜像仓库,要先登陆到镜像仓库  </span><br><span class="line">docker rename          #重命名容器  </span><br><span class="line">docker top 容器名称                       #查看容器中运⾏的进程  </span><br><span class="line">docker stats 容器名称                     #查看资源占⽤  </span><br><span class="line">docker cp 容器id:容器内路径  主机目的路径    #从容器内拷贝到主机上</span><br><span class="line"></span><br><span class="line">docker port            #列出指定的容器的端口映射，或者查找将PRIVATE_PORT NAT到面向公众的端口  </span><br></pre></td></tr></table></figure>
</li>
<li>
<p>更换镜像源</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 如果etc下没有docker目录就创建</span><br><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line"></span><br><span class="line"># 更换镜像源,</span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;</span><br><span class="line">&#123;</span><br><span class="line">    &quot;registry-mirrors&quot; : [</span><br><span class="line">    &quot;http://hub-mirror.c.163.com&quot;,</span><br><span class="line">    &quot;https://registry.docker-cn.com&quot;,</span><br><span class="line">    &quot;https://docker.mirrors.ustc.edu.cn&quot;,</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"># 重载配置文件</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line"># 重启Docker</span><br><span class="line">sudo systemctl restart docker</span><br><span class="line"># 显示Docker系统信息</span><br><span class="line">docker info</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>命令大全（网上搜集）</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker attach    #连接到正在运行中的容器  </span><br><span class="line">docker build    #使用 Dockerfile 创建镜像  </span><br><span class="line">docker builder    #管理builds  </span><br><span class="line">docker builder prune    #清除build缓存  </span><br><span class="line">docker checkpoint    #管理checkpoints  </span><br><span class="line">docker checkpoint create    #从正在运行的容器创建检查点  </span><br><span class="line">docker checkpoint ls    #列出容器的检查点  </span><br><span class="line">docker checkpoint rm    #删除指定的检查点  </span><br><span class="line">docker commit    #从容器创建一个新的镜像  </span><br><span class="line">docker config    #管理Docker配置  </span><br><span class="line">docker config create    #创建配置文件  </span><br><span class="line">docker config inspect    #查看配置文件信息  </span><br><span class="line">docker config ls        #显示docker里已经保存得配置文件  </span><br><span class="line">docker config rm        #删除配置文件  </span><br><span class="line">docker container    #管理容器  </span><br><span class="line">docker container prune    #删除所有已停止的容器  </span><br><span class="line">docker context    #管理contexts  </span><br><span class="line">docker context create    #创建一个上下文  </span><br><span class="line">docker context export    #将上下文导出到tar或kubecconfig文件中  </span><br><span class="line">docker context import    #从tar或zip文件导入上下文  </span><br><span class="line">docker context inspect    #在一个或多个上下文上显示详细信息  </span><br><span class="line">docker context ls        #列出上下文  </span><br><span class="line">docker context rm        #删除一个或多个上下文  </span><br><span class="line">docker context update    #更新  </span><br><span class="line">docker context use        #设置当前docker的上下文  </span><br><span class="line">docker cp        #用于容器与主机之间的数据拷贝  </span><br><span class="line">docker create    #创建一个新的容器但不启动它  </span><br><span class="line">docker diff        #检查容器里文件结构的更改  </span><br><span class="line">docker events    #从服务器获取实时事件  </span><br><span class="line">docker exec        #在运行的容器中执行命令  </span><br><span class="line">docker export    #将文件系统作为一个tar归档文件导出到STDOUT  </span><br><span class="line">docker history    #查看指定镜像的创建历史  </span><br><span class="line">docker image    #管理镜像  </span><br><span class="line">docker image inspect    #显示一个或多个镜像的元数据  </span><br><span class="line">docker image ls            #列出本地镜像  </span><br><span class="line">docker image prune        #删除没有使用的镜像  </span><br><span class="line">docker image rm            #删除一个或多个镜像  </span><br><span class="line">docker images    #列出本地镜像  </span><br><span class="line">docker import    #从归档文件中创建镜像  </span><br><span class="line">docker info        #显示 Docker 系统信息，包括镜像和容器数  </span><br><span class="line">docker inspect    #获取容器/镜像的元数据  </span><br><span class="line">docker kill        #杀掉一个运行中的容器  </span><br><span class="line">docker load        #导入使用 docker save 命令导出的镜像  </span><br><span class="line">docker login    #登陆到一个Docker镜像仓库，如果未指定镜像仓库地址，默认为官方仓库 Docker Hub  </span><br><span class="line">docker logout    #登出一个Docker镜像仓库，如果未指定镜像仓库地址，默认为官方仓库 Docker Hub  </span><br><span class="line">docker logs        #获取容器的日志  </span><br><span class="line">docker manifest    #管理manifest(实验，不应用于生产环境)  </span><br><span class="line">docker manifest annotate    #向本地镜像清单添加附加信息  </span><br><span class="line">docker manifest create        #创建用于注释和推入注册表的本地清单列表  </span><br><span class="line">docker manifest inspect        #显示镜像清单或清单列表  </span><br><span class="line">docker manifest push        #将清单列表推入仓库  </span><br><span class="line">docker manifest rm            #从本地存储中删除一个或多个清单列表  </span><br><span class="line">docker network    #管理网络  </span><br><span class="line">docker network connect        #将容器连接到网络  </span><br><span class="line">docker network create        #创建一个网络  </span><br><span class="line">docker network disconnect    #断开容器的网络  </span><br><span class="line">docker network inspect        #显示一个或多个网络的元数据  </span><br><span class="line">docker network ls            #列出网络  </span><br><span class="line">docker network prune        #删除所有没有使用的网络  </span><br><span class="line">docker network rm            #删除一个或多个网络  </span><br><span class="line">docker node        #管理集群(swarm)节点  </span><br><span class="line">docker node demote            #从群集(swarm)管理器中降级一个或多个节点  </span><br><span class="line">docker node inspect            #显示一个或多个节点的元数据  </span><br><span class="line">docker node ls                #列出群集(swarm)中的节点  </span><br><span class="line">docker node promote            #将一个或多个节点推入到群集管理器中  </span><br><span class="line">docker node ps                #列出在一个或多个节点上运行的任务，默认为当前节点  </span><br><span class="line">docker node rm                #从群集(swarm)删除一个或多个节点  </span><br><span class="line">docker node update            #更新一个节点  </span><br><span class="line">docker pause    #暂停容器中所有的进程  </span><br><span class="line">docker plugin    #管理插件  </span><br><span class="line">docker plugin create        #从rootfs和配置创建一个插件。插件数据目录必须包含config.json和rootfs目录。  </span><br><span class="line">docker plugin disable        #禁用插件  </span><br><span class="line">docker plugin enable        #启用插件  </span><br><span class="line">docker plugin inspect        #显示一个或多个插件的元数据  </span><br><span class="line">docker plugin install        #安装一个插件  </span><br><span class="line">docker plugin ls            #列出所有插件  </span><br><span class="line">docker plugin push            #将插件推送到注册表  </span><br><span class="line">docker plugin rm            #删除一个或多个插件  </span><br><span class="line">docker plugin set            #更改插件的设置  </span><br><span class="line">docker plugin upgrade        #升级现有插件  </span><br><span class="line">docker port        #列出指定的容器的端口映射，或者查找将PRIVATE_PORT NAT到面向公众的端口  </span><br><span class="line">docker ps        #列出容器  </span><br><span class="line">docker pull        #从镜像仓库中拉取或者更新指定镜像  </span><br><span class="line">docker push        #将本地的镜像上传到镜像仓库,要先登陆到镜像仓库  </span><br><span class="line">docker rename    #重命名容器  </span><br><span class="line">docker restart    #重启容器  </span><br><span class="line">docker rm        #删除一个或多个容器  </span><br><span class="line">docker rmi        #删除一个或多个镜像  </span><br><span class="line">docker run        #创建一个新的容器并运行一个命令  </span><br><span class="line">docker save        #将指定镜像保存成 tar 归档文件  </span><br><span class="line">docker search    #从Docker Hub查找镜像  </span><br><span class="line">docker secret    #管理Docker secrets  </span><br><span class="line">docker secret create    #从文件或STDIN创建一个秘密作为内容  </span><br><span class="line">docker secret inspect    #显示有关一个或多个秘密的详细信息  </span><br><span class="line">docker secret ls        #列出秘密  </span><br><span class="line">docker secret rm        #删除一个或多个秘密  </span><br><span class="line">docker service    #管理服务  </span><br><span class="line">docker service create    #创建一个服务  </span><br><span class="line">docker service inspect    #查看服务的元数据  </span><br><span class="line">docker service logs        #获取服务的日志  </span><br><span class="line">docker service ls        #列出服务  </span><br><span class="line">docker service ps        #列出一个或多个服务的任务  </span><br><span class="line">docker service rm        #删除一个或多个服务  </span><br><span class="line">docker service rollback    #将更改恢复到服务的配置  </span><br><span class="line">docker service scale    #缩放一个或多个复制服务  </span><br><span class="line">docker service update    #更新服务  </span><br><span class="line">docker stack    #管理堆栈  </span><br><span class="line">docker stack deploy        #部署新的堆栈或更新现有堆栈  </span><br><span class="line">docker stack ls            #列出现有堆栈  </span><br><span class="line">docker stack ps            #列出堆栈中的任务  </span><br><span class="line">docker stack rm            #删除堆栈      </span><br><span class="line">docker stack services    #列出堆栈中的服务  </span><br><span class="line">docker start    #启动一个或多个已经被停止的容器  </span><br><span class="line">docker stats    #显示容器的实时流资源使用统计信息  </span><br><span class="line">docker stop        #停止一个运行中的容器  </span><br><span class="line">docker swarm    #管理集群(Swarm)  </span><br><span class="line">docker swarm ca            #查看或旋转当前群集CA证书。此命令必须针对管理器节点  </span><br><span class="line">docker swarm init        #初始化一个群集(Swarm)  </span><br><span class="line">docker swarm join        #加入群集作为节点和/或管理器  </span><br><span class="line">docker swarm join-token    #管理加入令牌  </span><br><span class="line">docker swarm leave        #离开群集(Swarm)  </span><br><span class="line">docker swarm unlock        #解锁群集(Swarm)  </span><br><span class="line">docker swarm unlock-key    #管理解锁钥匙  </span><br><span class="line">docker swarm update        #更新群集(Swarm)  </span><br><span class="line">docker system    #管理Docker  </span><br><span class="line">docker system df        #显示docker磁盘使用情况  </span><br><span class="line">docker system events    #从服务器获取实时事件  </span><br><span class="line">docker system info        #显示系统范围的信息  </span><br><span class="line">docker system prune        #删除未使用的数据  </span><br><span class="line">docker tag        #标记本地镜像，将其归入某一仓库  </span><br><span class="line">docker top        #查看容器中运行的进程信息，支持 ps 命令参数  </span><br><span class="line">docker trust    #管理Docker镜像的信任  </span><br><span class="line">docker trust inspect    #返回有关key和签名的低级信息  </span><br><span class="line">docker trust key        #管理登入Docker镜像的keys  </span><br><span class="line">    docker trust key generate    #生成并加载签名密钥对  </span><br><span class="line">    docker trust key load        #加载私钥文件以进行签名  </span><br><span class="line">docker trust revoke        #删除对镜像的认证  </span><br><span class="line">docker trust sign        #镜像签名  </span><br><span class="line">docker trust signer        #管理可以登录Docker镜像的实体  </span><br><span class="line">    docker trust signer add        #新增一个签名者  </span><br><span class="line">    docker trust signer remove    #删除一个签名者  </span><br><span class="line">docker unpause    #恢复容器中所有的进程  </span><br><span class="line">docker update    #更新一个或多个容器的配置  </span><br><span class="line">docker version    #显示 Docker 版本信息  </span><br><span class="line">docker volume    #管理volumes  </span><br><span class="line">docker volume create    #创建一个卷  </span><br><span class="line">docker volume inspect    #显示一个或多个卷的元数据  </span><br><span class="line">docker volume ls        #列出卷  </span><br><span class="line">docker volume prune        #删除所有未使用的卷  </span><br><span class="line">docker volume rm        #删除一个或多个卷  </span><br><span class="line">docker wait        #阻塞运行直到容器停止，然后打印出它的退出代码</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>笔记</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>命令</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>VMware Workstation Pro教程三：安装Debian</title>
    <url>/2023/10/18/VMware-Workstation-Pro%E6%95%99%E7%A8%8B%E4%B8%89%EF%BC%9A%E5%AE%89%E8%A3%85Debian/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>笔记</category>
        <category>VMware虚拟机</category>
      </categories>
      <tags>
        <tag>VMware</tag>
        <tag>虚拟机</tag>
        <tag>Debian</tag>
      </tags>
  </entry>
  <entry>
    <title>VMware Workstation Pro教程一：安装软件</title>
    <url>/2023/10/18/VMware-Workstation-Pro%E6%95%99%E7%A8%8B%E4%B8%80%EF%BC%9A%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>笔记</category>
        <category>VMware虚拟机</category>
      </categories>
      <tags>
        <tag>VMware</tag>
        <tag>虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title>VMware Workstation Pro教程二：安装Ubuntu desktop</title>
    <url>/2023/10/18/VMware-Workstation-Pro%E6%95%99%E7%A8%8B%E4%BA%8C%EF%BC%9A%E5%AE%89%E8%A3%85Ubuntu-desktop/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<p>Ubuntu 是一种广受欢迎的开源操作系统，基于 Linux 内核。它以稳定性、易用性和强大的社区支持而闻名。本文介绍了在 VMware 虚拟机上的安装 Ubuntu 最新发布版本 <code>Ubuntu 22.04.1 LTS</code>，LTS 意为“长期支持”，一般为5年。该 LTS 版本将提供免费安全和维护更新至 2027年4月。有需要了解更多的，可以到 <a href="https://cn.ubuntu.com/desktop">Ubuntu官网</a> 了解。</p>
<h2 id="下载-Ubuntu22-04-镜像">下载 Ubuntu22.04 镜像</h2>
<p>ubuntu22.04.2-desktop-amd64.iso：<a href="https://ubuntu.com/download/desktop">点击下载</a></p>
<p><img src="https://v3.wmnzsx.eu.org/i/1/2023/11/24/11d0xj9-1.webp" alt="VM-ubuntu1"></p>
<h2 id="创建虚拟机">创建虚拟机</h2>
<h3 id="创建">创建</h3>
<p>打开 VMware 虚拟机—&gt;点击文件—&gt;新建虚拟机</p>
<p><img src="https://v3.wmnzsx.eu.org/i/1/2023/11/24/11d8nal-1.webp" alt="VM-ubuntu2"></p>
<h3 id="选择硬件兼容性">选择硬件兼容性</h3>
<p>默认点击下一步</p>
<p><img src="https://v3.wmnzsx.eu.org/i/1/2023/11/24/11czaye-1.webp" alt="VM-ubuntu3"></p>
<h3 id="选择安装来源">选择安装来源</h3>
<p>选择 【稍后安装系统】，点击下一步</p>
<p><img src="https://v3.wmnzsx.eu.org/i/1/2023/11/24/11d0ql3-1.webp" alt="VM-ubuntu4"></p>
<h3 id="选择系统类型">选择系统类型</h3>
<p>选择“Linux（L）”和“Ubuntu 64 位”，点击“下一步”。</p>
<p><img src="https://v3.wmnzsx.eu.org/i/1/2023/11/24/11cyo65-1.webp" alt="VM-ubuntu5"></p>
<h3 id="虚拟机命名">虚拟机命名</h3>
<p>自定义虚拟机名称和存储位置</p>
<p><img src="https://v3.wmnzsx.eu.org/i/1/2023/11/24/11cz8n0-1.webp" alt="VM-ubuntu6"></p>
<h3 id="一些配置">一些配置</h3>
<h4 id="处理器配置">处理器配置</h4>
<blockquote>
<p>处理器个数至少为 1 个，可根据自己需求进行选择。</p>
</blockquote>
<p><img src="https://v3.wmnzsx.eu.org/i/1/2023/11/24/11czhiy-1.webp" alt="VM-ubuntu7"></p>
<h4 id="虚拟机内存配置">虚拟机内存配置</h4>
<blockquote>
<p>根据自己物理机进行分配内存，最多不能大于物理机内存。</p>
</blockquote>
<p><img src="https://v3.wmnzsx.eu.org/i/1/2023/11/24/11cyye1-1.webp" alt="VM-ubuntu8"></p>
<h4 id="网络和-I-O-类型">网络和 I/O 类型</h4>
<blockquote>
<p>我一般使用 NAT</p>
</blockquote>
<p><img src="https://v3.wmnzsx.eu.org/i/1/2023/11/24/11cznru-1.webp" alt="VM-ubuntu9"></p>
<p><img src="https://v3.wmnzsx.eu.org/i/1/2023/11/24/11czfxl-1.webp" alt="VM-ubuntu10"></p>
<h4 id="磁盘类型">磁盘类型</h4>
<p>默认即可</p>
<p><img src="https://v3.wmnzsx.eu.org/i/1/2023/11/24/122utvl-1.webp" alt="VM-ubuntu11"></p>
<h4 id="创建磁盘">创建磁盘</h4>
<p><img src="https://v3.wmnzsx.eu.org/i/1/2023/11/24/122uwal-1.webp" alt="VM-ubuntu12"></p>
<p><img src="https://v3.wmnzsx.eu.org/i/1/2023/11/24/122und6-1.webp" alt="VM-ubuntu13"></p>
<h4 id="自定义硬件">自定义硬件</h4>
<p>选择自己镜像的存储位置，然后点击“关闭”、“完成”（虚拟机基础操作完毕后可取消）</p>
<p><img src="https://v3.wmnzsx.eu.org/i/1/2023/11/24/122uoxu-1.webp" alt="VM-ubuntu14"></p>
<h2 id="启动虚拟机">启动虚拟机</h2>
<p><img src="https://v3.wmnzsx.eu.org/i/1/2023/11/24/122umi9-1.webp" alt="VM-ubuntu15"></p>
<p><img src="https://v3.wmnzsx.eu.org/i/1/2023/11/24/122uxgk-1.webp" alt="VM-ubuntu16"></p>
<blockquote>
<p>默认点击继续</p>
</blockquote>
<p><img src="https://v3.wmnzsx.eu.org/i/1/2023/11/24/122v9fs-1.webp" alt="VM-ubuntu17"></p>
<p><img src="https://v3.wmnzsx.eu.org/i/1/2023/11/24/122vey4-1.webp" alt="VM-ubuntu18"></p>
<p><img src="https://v3.wmnzsx.eu.org/i/1/2023/11/24/122vf1k-1.webp" alt="VM-ubuntu19"></p>
<blockquote>
<p>选择时区</p>
</blockquote>
<p><img src="https://v3.wmnzsx.eu.org/i/1/2023/11/24/122vj5h-1.webp" alt="VM-ubuntu20"></p>
<p><img src="https://v3.wmnzsx.eu.org/i/1/2023/11/24/125uc8x-1.webp" alt="VM-ubuntu21"></p>
<p><img src="https://v3.wmnzsx.eu.org/i/1/2023/11/24/122vlf9-1.webp" alt="VM-ubuntu22"></p>
<p><strong>完成安装</strong></p>
<h2 id="基础配置">基础配置</h2>
<h3 id="更换国内源"><strong>更换国内源</strong></h3>
<p>打开&quot;软件和更新&quot;</p>
<p><img src="https://v3.wmnzsx.eu.org/i/1/2023/11/24/122vsu4-1.webp" alt="VM-ubuntu23"></p>
<p>可自行百度选择，我这里选择的阿里云的。</p>
<h3 id="安装常用软件">安装常用软件</h3>
<p><code>apt-get install curl wget lrzsz vim cron unzip screen</code></p>
<details class="toggle" ><summary class="toggle-button" style="">点击此处展开/收起内容，来自 chatgpt 的解释</summary><div class="toggle-content"><ol>
<li><code>curl</code>：用于在终端中进行网络请求和数据传输，支持各种协议（如 HTTP、HTTPS、FTP 等）。</li>
<li><code>wget</code>：用于从 Web 服务器下载文件，支持 HTTP、HTTPS 和 FTP 协议，具有断点续传功能。</li>
<li><code>lrzsz</code>：提供了 Xmodem、Ymodem 和 Zmodem 等协议的文件传输功能，用于通过终端与远程主机进行文件传输。</li>
<li><code>vim</code>：一种强大的文本编辑器，常用于命令行环境下编辑文本文件。</li>
<li><code>cron</code>：用于在预定时间自动运行命令或脚本的任务调度程序。</li>
<li><code>unzip</code>：用于解压缩 ZIP 格式的压缩文件。</li>
<li><code>screen</code>：用于在终端中创建和管理多个会话，允许在不同的终端窗口或会话之间切换。</li>
</ol>
</div></details>
<h3 id="其他">其他</h3>
<ul>
<li>查看是否有网：ping <a href="http://baidu.com">baidu.com</a></li>
<li>查看 ip：ifconfig</li>
</ul>
<h2 id="美化">美化</h2>
<p><a href="https://fkcc.me/2023/10/21/Ubuntu-%E7%BE%8E%E5%8C%96/">Ubuntu 美化 | ZのBlog (fkcc.me)</a></p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>VMware虚拟机</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>VMware</tag>
        <tag>虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2022/12/01/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start">Quick Start</h2>
<h3 id="Create-a-new-post">Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server">Run server</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files">Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites">Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>windows 常用运行环境的安装</title>
    <url>/2023/10/17/windows%E5%B8%B8%E7%94%A8%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83%E7%9A%84%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h2 id="Git">Git</h2>
<p>见：</p>
<p><a href="https://fkcc.me/2023/10/17/%E5%AE%89%E8%A3%85Git/">windows 安装Git | ZのBlog (fkcc.me)</a></p>
<h2 id="Node-Js">Node.Js</h2>
<blockquote>
<p>去官网下载最新的稳定版 <a href="https://nodejs.org/en/">Node.JS</a> ，一般推荐 64 位（大家应该现在用的电脑基本都是 64 位的吧），安装的话很简单，基本就是下一步下一步点击就好了。</p>
</blockquote>
<h3 id="下载安装包">下载安装包</h3>
<p>要安装 <code>Node.js</code>，首先需要去下载对应系统安装包：</p>
<blockquote>
<p>根据自己电脑系统及位数选择，我的电脑是 Windows 系统、64位、想下载稳定版的.msi（LTS 为长期稳定版）这里选择 <code>windows64位.msi</code> 格式安装包。</p>
</blockquote>
<blockquote>
<p><code>.msi</code> 和 <code>.zip</code> 格式区别：</p>
<ul>
<li><code>.msi</code> 是 Windows installer 开发出来的程序安装文件，它可以让你安装，修改，卸载你所安装的程序。说白了.msi 就是 Windows installer 的数据包，把所有和安装文件相关的内容封装在一个包里。<strong>此外：它还包含有关安装过程自己的信息。例如：安装序列、目标文件夹路径、安装选项和控制安装过程的属性。</strong></li>
<li><code>.zip</code> 是一个压缩包，解压之后即可，不需要安装</li>
</ul>
</blockquote>
<p><a href="https://nodejs.org/zh-cn/download/">点击下载 | Node.js</a></p>
<p><img src="https://v3.wmnzsx.eu.org/i/1/2023/11/24/12877q4-1.webp" alt="nodejs1"></p>
<h3 id="安装程序">安装程序</h3>
<ol>
<li>
<p>下载完成后，双击安装包，开始安装，使用默认配置安装一直点 <code>next</code> 即可，安装路径默认在 <code>C:\Program Files</code> 下，也可以自定义修改，我这里安装在 <code>E:\Nodejs </code></p>
</li>
<li>
<p>下图根据本身的需要进行，我选择了默认 <code>Node.js runtime</code></p>
<ul>
<li><code>Node.js runtime</code> ：表示运行环境</li>
<li><code>npm package manager</code>：表示npm包管理器</li>
<li><code>online documentation shortcuts</code> ：在线文档快捷方式</li>
<li><code>Add to PATH</code>：添加到环境变量</li>
</ul>
<p><img src="https://v3.wmnzsx.eu.org/i/1/2023/11/24/1286xv5-1.webp" alt="nodejs2"></p>
</li>
<li>
<p>下图框中所示，不用选</p>
<p><img src="https://v3.wmnzsx.eu.org/i/1/2023/11/24/1287g2j-1.webp" alt="nodejs3"></p>
</li>
<li>
<p>点击 Install，完成安装</p>
</li>
<li>
<p>安装完成后，.msi 格式的安装包已经将 node 启动程序添加到系统环境变量 path 中,我们能够查看系统变量进行验证：在【个人电脑】右键→【属性】→【高级系统设置】，在系统变量中查看【path】。</p>
</li>
</ol>
<h3 id="修改位置">修改位置</h3>
<ol>
<li>
<p>修改全局模块路径和缓存路径（可选）</p>
<blockquote>
<p>当我们在执行 npm install express -g 命令时，g 表示 global 全局。会默认下载到 c 盘，c 盘一般作为系统盘，尽量把一些程序安装到其他盘，来减少 c 盘空间的占用，它的默认路径为：<code>C:\Users\用户名\AppData\Roaming\npm</code>。</p>
</blockquote>
<blockquote>
<p><strong>注意：此文件夹默认是隐藏的，需要设置显示隐藏的文件夹。</strong></p>
</blockquote>
<p>①若希望将<strong>全模块所在路径</strong>和<strong>缓存路径</strong>放在自己的 node.js 安装的文件夹中，则在安装的文件夹 <code>E:\Nodejs </code> 下创建两个文件夹 <code>node_global</code> 和 <code>node_cache</code>，在 <code>node_global</code> 文件夹下再建一个 <code>node_modules </code> 文件夹<br>
②win+R 打开运行窗口，输入 cmd，再输入以下两条指令</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm config set prefix &quot;创建的node_global文件夹所在路径&quot; </span><br><span class="line">npm config set cache &quot;创建的node_cache文件夹所在路径&quot;</span><br></pre></td></tr></table></figure>
<p>比如：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm config set prefix &quot;E:\Nodejs\node_global&quot;  </span><br><span class="line">npm config set cache &quot;E:\Nodejs\node_cache&quot;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>修改系统环境变量</strong></p>
<p>①将【用户变量】下的 <code>Path </code> 变量中的默认的 npm 路径修改为新建的 node_global 路径，即修改为 <code>E:\Nodejs\node_global</code>，之后点击确定。<br>
② 在【系统变量】下新建 <code>NODE_PATH</code> 为 <code>E:\Nodejs\node_global\node_modules</code><br>
③ 在【系统变量】下的 <code>Path </code> 新建添加 node 全局文件夹 <code>E:\Nodejs\node_global </code></p>
</li>
<li>
<p><strong>验证</strong></p>
<p>①经过上面的步骤，<strong>nodejs</strong> 下载的模块就会自动下载到我们自定义的目录输入下面的命令：</p>
<p><code>npm install express -g</code>      # -g 是全局安装的意思，不加 -g 就是默认下载到当前目录</p>
<p>②下载成功后，我们回到自定义的目录查看。</p>
<p>如果可以看到，下载的 express 模块即一个名叫 express 的文件夹全局的指定目录。即完成</p>
<blockquote>
<p><strong>注：若执行命令 <code>npm install express -g </code> 出现报错，由于权限的原因，可以以管理员身份运行 cmd</strong></p>
</blockquote>
</li>
</ol>
<h3 id="更换国内源">更换国内源</h3>
<h4 id="更换-npm-源为淘宝镜像">更换 npm 源为淘宝镜像</h4>
<blockquote>
<p>npm 默认的  registry ,也就是下载 npm 包时是从国外的服务器下载，国内很慢，一般都会指向淘宝 <a href="https://registry.npm.taobao.org">https://registry.npm.taobao.org</a></p>
</blockquote>
<ol>
<li>
<p>查看初始 npm 源</p>
<p><code>npm config get registry </code></p>
</li>
<li>
<p>更换镜像为淘宝镜像</p>
<p><code>npm config set registry https://registry.npm.taobao.org/</code></p>
</li>
</ol>
<h4 id="全局安装基于淘宝源的-cnpm（可使用上面那个）">全局安装基于淘宝源的 cnpm（可使用上面那个）</h4>
<blockquote>
<p>由于 npm 的服务器在海外，所以访问速度比较慢，访问不稳定，cnpm 的服务器是由淘宝团队提供服务器在国内 cnpm 是 npm 镜像，一般会同步更新，相差在10分钟，所以 cnpm 在安装一些软件时候会比较有优势。但是一般 cnpm 只用于安装时候，所以在项目创建与卸载等相关操作时候我们还是使用 npm。</p>
</blockquote>
<ol>
<li>
<p>全局安装基于淘宝源的 cnpm</p>
<p><code>npm install -g cnpm --registry= https://registry.npm.taobao.org</code></p>
<p>下载完后，我们在本地就能看到 cnpm 模块, 在 node_modules 文件夹会出现一个名叫 cnpm 的文件夹</p>
</li>
<li>
<p>执行命令查看 cnpm 是否安装成功</p>
<p><code>cnpm -v </code></p>
</li>
</ol>
<h4 id="验证安装">验证安装</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#进入命令提示符窗口，分别输入以下命令，显示版本号，则安装成功</span><br><span class="line">node -v       显示安装的nodejs版本  </span><br><span class="line">npm -v        显示安装的npm版本</span><br></pre></td></tr></table></figure>
<h4 id="参考文档">参考文档</h4>
<ul>
<li><a href="https://blog.csdn.net/qq_52855464/article/details/127600132">Nodejs安装教程（全套教程保姆级）_nodejs 14.16_潮汐未见潮落的博客-CSDN博客</a></li>
</ul>
<hr>
<h2 id="MinGW-w64">MinGW-w64</h2>
<blockquote>
<p>C/C++的编译器有很多种，大家可自行选择，但网上大部分人都用的 MinGW-w64，故以此编译器为例</p>
</blockquote>
<blockquote>
<p>gcc 是 c/c++的编译器，但是通常在 Linux 上才能用。如果要在 windows 上用，我们要借助 MinGW 使用它。在 MinGW 官网上，可以下载 zip 也可以下载 exe 执行文件，但是 .exe 执行文件在安装时，其实是会根据你的选择去下载 zip ，而且网速不好根本下不下来，会报错，所以我们直接选择对应版本的 zip 文件下载就可以了。</p>
</blockquote>
<h3 id="下载">下载</h3>
<blockquote>
<p>链接 1： <a href="https://sourceforge.net/projects/mingw-w64/files/">MinGW-w64 - for 32 and 64 bit Windows - Browse Files at SourceForge.net</a><br>
链接 2： <a href="https://www.mingw-w64.org/downloads/">Downloads - MinGW-w64</a></p>
</blockquote>
<p><img src="https://v3.wmnzsx.eu.org/i/1/2023/11/24/12870m1-1.webp" alt="mingw64-1"></p>
<ul>
<li>X86_64 是指 64 位的操作系统，i686 是指 32 位的操作系统</li>
<li>Win32 是开发 windows 系统程序的协议，posix 是其他系统的协议（例如 Linux、Unix、Mac OS）</li>
<li>异常处理模型 seh（新的，仅支持 64 位系统），sjlj （稳定的，64 位和 32 位都支持），    dwarf （优于 sjlj 的，仅支持 32 位系统）</li>
</ul>
<h3 id="安装">安装</h3>
<ol>
<li>
<p>方法一：在线安装（网络问题，很炸裂）</p>
<p><img src="https://v3.wmnzsx.eu.org/i/1/2023/11/24/1286n5u-1.webp" alt="mingw64-2"></p>
<ul>
<li>Version 是版本，一般选最高版本；</li>
<li>Architecture 是系统架构，电脑系统是 64 位的选择 x 86_64，是 32 位的则选择 i 686；</li>
<li>Threads 是操作系统接口协议，如果你想要开发 Windows 程序，需要选择 win 32 ，而开发</li>
<li>Linux、Unix、Mac OS 等其他操作系统下的程序，则需要选择 posix</li>
<li>Exception 是异常处理模型，推荐 seh (64 位系统)或 dwarf (32 位系统)</li>
<li>Build revision，默认值即可</li>
</ul>
<blockquote>
<p>注意安装目录需是纯英文的，且<strong>不含空格</strong></p>
</blockquote>
</li>
<li>
<p>方法二：直接下载对应的压缩包</p>
<p>下载后解压压缩包，右击“此电脑”——“属性”——“高级系统设置”——“环境变量”——找到“系统变量”中的“Path”条目——“编辑”——“新建”——将你的 MinGW-w64 安装路径复制到新条目中(格式形如 D:\mingw-w64\bin，一定要写到 bin 这个文件夹)——完成</p>
<p><img src="https://v3.wmnzsx.eu.org/i/1/2023/11/24/1286rox-1.webp" alt="mingw64-3"></p>
<p>打开命令提示符(直接在 Windows 搜索框输入 cmd 即可找到)，输入 gcc -v，然后回车，验证是否成功(如果出现十几行乱码一样的东西，则配置环境变量成功)(<strong>注意：gcc 与 -v 之间有一个空格！</strong>)</p>
</li>
</ol>
<hr>
<h2 id="PHP">PHP</h2>
<h3 id="下载-2">下载</h3>
<blockquote>
<p>下载地址：<a href="https://windows.php.net/download">https://windows.php.net/download</a></p>
</blockquote>
<p><img src="https://v3.wmnzsx.eu.org/i/1/2023/11/24/1287eey-1.png" alt="php1"></p>
<details class="toggle" ><summary class="toggle-button" style="">点击此处展开/收起内容，来自 chatgpt 的解释</summary><div class="toggle-content"><ul>
<li>“VS16 x64 Thread Safe” 和 “VS16 x64 Non Thread Safe” 是指针对 Windows 平台上的 PHP 编译版本。</li>
<li>“VS16” 表示使用的是 Visual Studio 2019 编译器（版本号为 16）。</li>
<li>“x64” 表示编译为 64 位版本，这意味着它适用于 64 位的 Windows 操作系统。</li>
<li>“Thread Safe” 表示编译版本是线程安全的，即支持多线程操作。这意味着您可以在一个应用程序中同时运行多个线程，而不会出现竞争条件或内存访问冲突。</li>
<li>“Non Thread Safe” 表示编译版本不是线程安全的，即不支持多线程操作。这意味着您应该在单线程环境下使用它，或者需要自行处理多线程操作的同步和互斥。</li>
</ul>
<p>选择哪个版本取决于您的具体需求和环境。如果您的应用程序需要多线程支持，那么选择 “Thread Safe” 版本是更安全的选择。否则，如果您的应用程序是单线程的，或者您能够自行处理多线程操作的同步和互斥，那么选择 “Non Thread Safe” 版本也是可以的。</p>
</div></details>
<h3 id="安装-2">安装</h3>
<p>将下载好的 zip 文件解压到自己认为比较合适的地方（例如：<code>D:\php\php-8.2.12-nts-Win32-vs16-x64</code>），不需要安装，解压即可。</p>
<h3 id="环境配置">环境配置</h3>
<p>打开 <code>设置</code> --&gt; <code>系统</code> --&gt; <code>系统信息</code> --&gt; <code>高级系统设置</code> --&gt; <code>环境变量</code></p>
<p>在下面的系统变量里找到 <code>Path</code>，双击新建一条记录，将上述 PHP 路径粘贴进去，保存</p>
<h3 id="验证">验证</h3>
<p>按下 <code>Win + R</code>，输入 <code>cmd</code>，打开命令行工具，输入 <code>php -v</code></p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>软件与环境</category>
      </categories>
      <tags>
        <tag>环境</tag>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title>VS Code配置</title>
    <url>/2023/10/21/VS-Code%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<div class="note orange icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p>简单记录一下我VS code的配置，不保证准确性</p>
</div>
<blockquote>
<p>vs 配置参考：</p>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/62913725">第一次使用VS Code时你应该知道的一切配置 - 知乎</a></li>
<li><a href="https://blog.csdn.net/wkd_007/article/details/131407330">【VSCode | 主题】推荐几个适合看 C/C++ 代码的 VSCode 主题-CSDN博客</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/639196010">VSCode C/C++开发配置都在这里了 - 知乎</a></li>
</ul>
</blockquote>
<blockquote>
<p>首先先安装中文扩展：搜索 Chinese</p>
</blockquote>
<p><img src="https://v3.wmnzsx.eu.org/i/1/2023/11/24/126f1xx-1.webp" alt="vs"></p>
<h2 id="配置-C-C-语言环境">配置 C/C++ 语言环境</h2>
<h3 id="安装MinGW-w64">安装MinGW-w64</h3>
<p>见安装 MinGW-w64部分：</p>
<p><a href="https://fkcc.me/2023/10/17/windows%E5%B8%B8%E7%94%A8%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83%E7%9A%84%E5%AE%89%E8%A3%85/">windows常用运行环境的安装 | Z の Blog (fkcc.me)</a></p>
<h3 id="设置-vscode-里的环境">设置 vscode 里的环境</h3>
<blockquote>
<p>配置文件有三个，分别为：①构建任务文件： tasks.json，②编译器路径文件： c_cpp_properties.json，③调试设置文件：launch.json</p>
<p>// launch.json可以不创建</p>
</blockquote>
<blockquote>
<p>可以按照下方教程手动配置，也可以直接复制我提供的文件（每个教程后面会给出，注意更改路径）</p>
</blockquote>
<h4 id="配置-C-C-语言环境-2">配置 C/C++ 语言环境</h4>
<h5 id="配置-C-语言环境">配置 C 语言环境</h5>
<blockquote>
<p>参考：</p>
<ul>
<li><a href="https://blog.csdn.net/incredibleimpact/article/details/109733494">VS Code C语言开发环境配置附图版保姆教程</a></li>
<li><a href="https://www.cnblogs.com/xiaml/articles/17391759.html">VS Code配置C语言开发与调试环境(超详细) - Arthur古德曼 - 博客园</a></li>
</ul>
</blockquote>
<ol>
<li>
<p>安装必要扩展</p>
<ul>
<li>C/C++</li>
</ul>
<p><img src="https://v3.wmnzsx.eu.org/i/1/2023/11/24/126f6vf-1.webp" alt="C-1"></p>
<ul>
<li>其他扩展<br>
待写。。。</li>
</ul>
</li>
<li>
<p>配置</p>
<p>①新建项目仓库，比如  <code>C </code> 文件夹<br>
②使用 vs code 打开 <code>C</code> 文件夹并在里面创建 Hello.c 文件</p>
<blockquote>
<p>PS：请注意路径不能有中文</p>
</blockquote>
<p>将以下代码填入 Hello. c 文件中，保存</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello, World!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>③配置构建任务文件： tasks.json<br>
按 F5，按图示选择第一个：</p>
<p><img src="https://v3.wmnzsx.eu.org/i/1/2023/11/24/126ew0a-1.png" alt="C-2"></p>
<p>④配置编译器路径文件： c_cpp_properties.json</p>
<ul>
<li>按快捷键 Ctrl+Shift+P 调出命令面板，输入 <code>C/C++</code>，选择“<code>Edit Configurations (UI)</code>”进入配置。</li>
<li>这里的路径根据大家自己安装的 Mingw 编译器位置和配置的环境变量位置所决定。</li>
</ul>
<blockquote>
<p>配置“编译器路径”(写自己的编译器下载路径，例如：<code>D:/mingw-w64/bin/gcc.exe</code> )以及“IntelliSense 模式”(设为：<code>gcc-x64</code>)</p>
</blockquote>
<p>然后会自动创建文件</p>
<p>⑤配置调试设置文件：launch.json<br>
点击左边调试，点击创建 launch.json 文件</p>
<p><img src="https://v3.wmnzsx.eu.org/i/1/2023/11/24/126f2ov-1.webp" alt="C-3"></p>
<p>选择 C++(GDB/LLDB)</p>
<p><img src="https://v3.wmnzsx.eu.org/i/1/2023/11/24/126euxn-1.webp" alt="C-4"></p>
<p>紧接着会产生一个 launch.json 的文件，里面没什么东西，可以参考我的（后面会给出代码）</p>
 <details class="toggle" ><summary class="toggle-button" style="">点击查看文件代码</summary><div class="toggle-content"><blockquote>
<p>此处为我的配置文件，可以直接复制粘贴，但不保证准确性</p>
</blockquote>
<p>tasks.json：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;tasks&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;type&quot;: &quot;cppbuild&quot;,</span><br><span class="line">            &quot;label&quot;: &quot;C/C++: gcc.exe 生成活动文件&quot;,</span><br><span class="line">            &quot;command&quot;: &quot;D:\\mingw-w64\\bin\\gcc.exe&quot;,     //换成你的路径</span><br><span class="line">            &quot;args&quot;: [</span><br><span class="line">                &quot;-fdiagnostics-color=always&quot;,</span><br><span class="line">                &quot;-g&quot;,</span><br><span class="line">                &quot;$&#123;file&#125;&quot;,</span><br><span class="line">                &quot;-o&quot;,</span><br><span class="line">                &quot;$&#123;fileDirname&#125;\\$&#123;fileBasenameNoExtension&#125;.exe&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;options&quot;: &#123;</span><br><span class="line">                &quot;cwd&quot;: &quot;$&#123;fileDirname&#125;&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;problemMatcher&quot;: [</span><br><span class="line">                &quot;$gcc&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;group&quot;: &#123;</span><br><span class="line">                &quot;kind&quot;: &quot;build&quot;,</span><br><span class="line">                &quot;isDefault&quot;: true</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;detail&quot;: &quot;调试器生成的任务。&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;version&quot;: &quot;2.0.0&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>c_cpp_properties.json：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;configurations&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;Win32&quot;,</span><br><span class="line">            &quot;includePath&quot;: [</span><br><span class="line">                &quot;$&#123;workspaceFolder&#125;/**&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;defines&quot;: [</span><br><span class="line">                &quot;_DEBUG&quot;,</span><br><span class="line">                &quot;UNICODE&quot;,</span><br><span class="line">                &quot;_UNICODE&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;compilerPath&quot;: &quot;D:\\mingw-w64\\bin\\gcc.exe&quot;,    //换成你的路径</span><br><span class="line">            &quot;cStandard&quot;: &quot;c17&quot;,</span><br><span class="line">            &quot;cppStandard&quot;: &quot;gnu++14&quot;,</span><br><span class="line">            &quot;intelliSenseMode&quot;: &quot;windows-gcc-x64&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;version&quot;: 4</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>launch.json：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    // 使用 IntelliSense 了解相关属性。 </span><br><span class="line">    // 悬停以查看现有属性的描述。</span><br><span class="line">    // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387</span><br><span class="line">        &quot;version&quot;: &quot;0.2.0&quot;,</span><br><span class="line">        &quot;configurations&quot;: [</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;name&quot;: &quot;C/C++ Debug&quot;,      // 配置名称，将会在启动配置的下拉菜单中显示</span><br><span class="line">            &quot;type&quot;: &quot;cppdbg&quot;,           // 配置类型，这里只能为cppdbg</span><br><span class="line">            &quot;request&quot;: &quot;launch&quot;,        // 请求配置类型，可以为launch（启动）或attach（附加）  </span><br><span class="line">            &quot;program&quot;: &quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.exe&quot;,          // 将要进行调试的程序的路径，详细见下方注释</span><br><span class="line">            &quot;args&quot;: [],                                               // 程序调试时传递给程序的命令行参数，一般设为空即可  </span><br><span class="line">            &quot;stopAtEntry&quot;: false,                                     // 设为true时程序将暂停在程序入口处，一般设置为false  </span><br><span class="line">            &quot;cwd&quot;: &quot;$&#123;fileDirname&#125;&quot;,          // 调试程序时的工作目录，详细见下方注释</span><br><span class="line">            &quot;environment&quot;: [],</span><br><span class="line">            &quot;externalConsole&quot;: false,        // 调试时是否显示控制台窗口，一般设置为false即在控制台显示，true则弹出终端</span><br><span class="line">            &quot;MIMode&quot;: &quot;gdb&quot;,                                          </span><br><span class="line">            &quot;miDebuggerPath&quot;: &quot;D:\\mingw-w64\\bin\\gdb.exe&quot;,   // miDebugger的路径，注意这里要与自己电脑安装的MinGw的路径对应</span><br><span class="line">            &quot;preLaunchTask&quot;: &quot;C/C++: gcc.exe 生成活动文件&quot;, // 调试会话开始前执行的任务，一般为编译程序，和tasks.json文件中的&quot;label&quot;一样</span><br><span class="line">            &quot;setupCommands&quot;: [</span><br><span class="line">              &#123;</span><br><span class="line">                &quot;description&quot;: &quot;Enable pretty-printing for gdb&quot;,</span><br><span class="line">                &quot;text&quot;: &quot;-enable-pretty-printing&quot;,</span><br><span class="line">                &quot;ignoreFailures&quot;: true</span><br><span class="line">              &#125;</span><br><span class="line">            ],</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>来自Chatgpt的解释：</strong></p>
<ol>
<li>
<p>program变量</p>
<ul>
<li><code>&quot;program&quot;: &quot;${workspaceFolder}/${fileBasenameNoExtension}.exe&quot;</code>：
<ul>
<li>始终使用 <code>${workspaceFolder}</code> 中的可执行文件。</li>
<li>适合在整个工作区内使用相同的可执行文件的情况。</li>
</ul>
</li>
<li><code>&quot;program&quot;: &quot;${fileDirname}/${fileBasenameNoExtension}.exe&quot;</code>：
<ul>
<li>自动使用当前活动文件所在文件夹中的可执行文件。</li>
<li>更适合在不同文件夹中编写代码并希望在当前文件夹中查找可执行文件的情况。</li>
</ul>
</li>
</ul>
<p>如果你的项目结构中不同文件夹中都有各自的可执行文件，使用 <code>&quot;program&quot;: &quot;${fileDirname}/${fileBasenameNoExtension}.exe&quot;</code> 更灵活，因为它会根据当前活动文件的位置自动查找相关的可执行文件，而不需要在不同文件夹中手动切换配置。</p>
</li>
<li>
<p>cwd变量</p>
<ul>
<li><code>&quot;cwd&quot;: &quot;${workspaceFolder}&quot;</code> 将工作目录设置为你的 VS Code 项目的根目录，即打开的文件夹的根目录。这通常是你的整个项目的根目录。当你需要在整个项目中执行或调试任务时，这是一个常见的设置。</li>
<li><code>&quot;cwd&quot;: &quot;${fileDirname}&quot;</code> 将工作目录设置为当前打开文件的目录。这对于执行或调试与当前打开文件直接相关的任务非常有用，例如，如果你需要在与当前文件相关的特定子目录中执行任务，可以使用 <code>${fileDirname}</code>。</li>
</ul>
<p>你可以根据具体需求选择使用哪个工作目录设置。如果你想要在整个项目中运行任务，通常使用 <code>&quot;workspaceFolder&quot;</code> 是一个好的选择。如果你只想针对当前打开的文件运行任务，那么使用 <code>&quot;fileDirname&quot;</code> 更合适。</p>
<p>使用 <code>${workspaceFolder}</code> 通常对于整个项目的任务非常有用，而 <code>${fileDirname}</code> 对于与单个文件关联的任务更合适。</p>
</li>
</ol>
</div></details>
</li>
</ol>
<hr>
<h5 id="配置-C-语言环境-2">配置 C++ 语言环境</h5>
<blockquote>
<p>和“<font color="#ff0000">配置 C 语言环境</font>”这一步基本一样，就几个地方有点区别，需要把一些地方出现的gcc换成g++</p>
</blockquote>
<blockquote>
<p>参考：</p>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/87864677">VSCode配置C/C++环境 - 知乎</a></li>
<li><a href="https://blog.csdn.net/weixin_44996090/article/details/104432593">【精选】vscode配置c/c++编译环境（最终解决办法）_未配置编译器。除非设置自己的配置,否则 intellisense 可能无法正常工作。-CSDN博客</a></li>
<li><a href="https://blog.csdn.net/qq_45807140/article/details/112862592">【精选】从零开始的vscode安装及环境配置教程(C/C++)(Windows系统)_从零开始的vscode安装及环境配置教程(c/c++)(windows系统)_vscode环境配置_-CSDN博客</a></li>
</ul>
</blockquote>
<ol>
<li>
<p>安装必要扩展</p>
<ul>
<li>C/C++</li>
<li>其他扩展：<br>
待写。。。</li>
</ul>
</li>
<li>
<p>配置</p>
<p>①新建项目仓库，比如 CPP 文件夹<br>
②使用 vs code 打开 CPP 文件夹并在里面创建 Hello.cpp 文件</p>
<blockquote>
<p>PS：请注意路径不能有中文</p>
</blockquote>
<p>将以下代码填入 Hello.cpp 文件中，保存</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello World\n&quot;</span>);</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>③配置构建任务文件： tasks.json</p>
<p>按 F5，按图示选择第一个：</p>
<p><img src="https://v3.wmnzsx.eu.org/i/1/2023/11/24/126f0h1-1.webp" alt="CPP-1"></p>
<p>选择 g++</p>
<p><img src="https://v3.wmnzsx.eu.org/i/1/2023/11/24/127nkg7-1.webp" alt="CPP-2"></p>
<p>④配置编译器路径文件： c_cpp_properties.json</p>
<ul>
<li>按快捷键 Ctrl+Shift+P 调出命令面板，输入 <code>C/C++</code>，选择“<code>Edit Configurations(UI)</code>”进入配置。</li>
<li>这里的路径根据大家自己安装的 Mingw 编译器位置和配置的环境变量位置所决定。</li>
</ul>
<blockquote>
<p>配置“编译器路径”(写自己的编译器下载路径，例如：<code>D:/mingw-w64/bin/g++.exe</code>)以及“IntelliSense 模式”(设为：<code>gcc-x64</code>)</p>
</blockquote>
<p>⑤配置调试设置文件：launch.json<br>
参考上面 “<code>配置 C 语言环境</code>” 部分</p>
 <details class="toggle" ><summary class="toggle-button" style="">点击查看文件代码</summary><div class="toggle-content"><blockquote>
<p>此处为我的配置文件，可以直接复制粘贴，但不保证准确性</p>
</blockquote>
<p>tasks.json：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;tasks&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;type&quot;: &quot;cppbuild&quot;,</span><br><span class="line">            &quot;label&quot;: &quot;C/C++: g++.exe 生成活动文件&quot;, </span><br><span class="line">            &quot;command&quot;: &quot;D:\\mingw-w64\\bin\\g++.exe&quot;,         //换成你的路径</span><br><span class="line">            &quot;args&quot;: [</span><br><span class="line">                &quot;-fdiagnostics-color=always&quot;,</span><br><span class="line">                &quot;-g&quot;,</span><br><span class="line">                &quot;$&#123;file&#125;&quot;,</span><br><span class="line">                &quot;-o&quot;,</span><br><span class="line">                &quot;$&#123;fileDirname&#125;\\$&#123;fileBasenameNoExtension&#125;.exe&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;options&quot;: &#123;</span><br><span class="line">                &quot;cwd&quot;: &quot;$&#123;fileDirname&#125;&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;problemMatcher&quot;: [</span><br><span class="line">                &quot;$gcc&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;group&quot;: &quot;build&quot;,</span><br><span class="line">            &quot;detail&quot;: &quot;编译器: D:\\mingw-w64\\bin\\g++.exe&quot;      //换成你的路径</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;version&quot;: &quot;2.0.0&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>c_cpp_properties.json：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;configurations&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;Win32&quot;,</span><br><span class="line">            &quot;includePath&quot;: [</span><br><span class="line">                &quot;$&#123;workspaceFolder&#125;/**&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;defines&quot;: [</span><br><span class="line">                &quot;_DEBUG&quot;,</span><br><span class="line">                &quot;UNICODE&quot;,</span><br><span class="line">                &quot;_UNICODE&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;compilerPath&quot;: &quot;D:/mingw-w64/bin/g++.exe&quot;,           //换成你的路径</span><br><span class="line">            &quot;cStandard&quot;: &quot;c17&quot;,</span><br><span class="line">            &quot;cppStandard&quot;: &quot;gnu++14&quot;,</span><br><span class="line">            &quot;intelliSenseMode&quot;: &quot;windows-gcc-x64&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;version&quot;: 4</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>launch.json：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    // 使用 IntelliSense 了解相关属性。 </span><br><span class="line">    // 悬停以查看现有属性的描述。</span><br><span class="line">    // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387</span><br><span class="line">        &quot;version&quot;: &quot;0.2.0&quot;,</span><br><span class="line">        &quot;configurations&quot;: [</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;name&quot;: &quot;C/C++ Debug&quot;,      // 配置名称，将会在启动配置的下拉菜单中显示</span><br><span class="line">            &quot;type&quot;: &quot;cppdbg&quot;,           // 配置类型，这里只能为cppdbg</span><br><span class="line">            &quot;request&quot;: &quot;launch&quot;,        // 请求配置类型，可以为launch（启动）或attach（附加）  </span><br><span class="line">            &quot;program&quot;: &quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.exe&quot;,          // 将要进行调试的程序的路径，详细见下方注释</span><br><span class="line">            &quot;args&quot;: [],                                               // 程序调试时传递给程序的命令行参数，一般设为空即可  </span><br><span class="line">            &quot;stopAtEntry&quot;: false,                                     // 设为true时程序将暂停在程序入口处，一般设置为false  </span><br><span class="line">            &quot;cwd&quot;: &quot;$&#123;fileDirname&#125;&quot;,                              // 调试程序时的工作目录，详细见下方注释</span><br><span class="line">            &quot;environment&quot;: [],</span><br><span class="line">            &quot;externalConsole&quot;: false,                             // 调试时是否显示控制台窗口，一般设置为false即在控制台显示，true则弹出终端</span><br><span class="line">            &quot;MIMode&quot;: &quot;gdb&quot;,                                          </span><br><span class="line">            &quot;miDebuggerPath&quot;: &quot;D:\\mingw-w64\\bin\\gdb.exe&quot;,   // miDebugger的路径，注意这里要与自己电脑安装的MinGw的路径对应</span><br><span class="line">            &quot;preLaunchTask&quot;: &quot;C/C++: g++.exe 生成活动文件&quot;, // 调试会话开始前执行的任务，一般为编译程序，和tasks.json文件中的&quot;label&quot;一样</span><br><span class="line">            &quot;setupCommands&quot;: [</span><br><span class="line">              &#123;</span><br><span class="line">                &quot;description&quot;: &quot;Enable pretty-printing for gdb&quot;,</span><br><span class="line">                &quot;text&quot;: &quot;-enable-pretty-printing&quot;,</span><br><span class="line">                &quot;ignoreFailures&quot;: true</span><br><span class="line">              &#125;</span><br><span class="line">            ],</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&quot;program&quot;和&quot;cwd&quot;的注释请参考上方“配置 C 语言环境” 这一步骤</p>
</div></details>
</li>
</ol>
<h5 id="参考">参考</h5>
<ul>
<li><a href="https://www.52pojie.cn/thread-1725753-1-1.html">C/C++编译器 离线安装包、便携版 有TDM-GCC MinGW-GCC Clang等 - 『精品软件区』 - 吾爱破解 - LCG - LSG |安卓破解|病毒分析|www.52pojie.cn</a></li>
<li><a href="https://www.cnblogs.com/ggg-327931457/p/9694516.html">MinGW-w64安装教程——著名C/C++编译器GCC的Windows版本 - 『潇洒の背影』 - 博客园</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/180438950">VScode安装配置C语言运行环境（踩坑贴） - 知乎</a></li>
<li><a href="https://blog.csdn.net/B11050729/article/details/132176767">MinGW-W64 下载、安装与配置（支持最新版的GCC，目前 GCC 13.2.0）_mingw 最新-CSDN博客</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/354400717">VS Code配置C语言开发环境的超详细教程 - 知乎</a></li>
<li><a href="https://blog.csdn.net/qq_45807140/article/details/112862592">【精选】从零开始的vscode安装及环境配置教程(C/C++)(Windows系统)_从零开始的vscode安装及环境配置教程(c/c++)(windows系统)_vscode环境配置_-CSDN博客</a></li>
</ul>
<hr>
<h2 id="配置-PHP-环境">配置 PHP 环境</h2>
<h3 id="安装-PHP">安装 PHP</h3>
<p>见安装 PHP 部分：</p>
<p><a href="https://fkcc.me/2023/10/17/windows%E5%B8%B8%E7%94%A8%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83%E7%9A%84%E5%AE%89%E8%A3%85/">windows常用运行环境的安装 | Z の Blog (fkcc.me)</a></p>
<h3 id="设置-vscode-里的环境-2">设置 vscode 里的环境</h3>
]]></content>
      <categories>
        <category>笔记</category>
        <category>vs code</category>
      </categories>
      <tags>
        <tag>vs</tag>
        <tag>vs code</tag>
      </tags>
  </entry>
  <entry>
    <title>zram与swap交换内存</title>
    <url>/2023/10/31/zram%E4%B8%8Eswap%E4%BA%A4%E6%8D%A2%E5%86%85%E5%AD%98/</url>
    <content><![CDATA[<h2 id="必看">必看</h2>
<div class="note orange icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><ol>
<li>本篇文章是结合chatgpt所写,不保证正确性。</li>
<li>zram部分没用过，不知道，直接抄下来的</li>
<li>swap已使用，并成功，但是”删除swap交换分区“这一部分没用过</li>
<li>本教程操作设备为刷了debian的随机WiFi棒子</li>
<li>一般来说，能不用swap更好</li>
<li>zram读写速度快于swap，因为它将内存中的数据进行压缩，可以节省 I/O 操作时间和磁盘空间。</li>
<li>zram适合用于内存较小的系统或者需要频繁使用交换分区的场合，因为它可以在不占用额外磁盘空间的情况下提供更多的虚拟内存。而 swap 则适用于具有大量磁盘空间但内存较少的系统，或者需要在磁盘上保留一定的空间以供其他用途的场合。</li>
</ol>
</div>
<h3 id="zram">zram</h3>
<h4 id="介绍">介绍</h4>
<p>zram 是一种基于内存压缩技术的交换空间，它将一部分空闲物理内存作为交换空间，并将其中的数据进行压缩，从而更高效地使用内存。与传统的 swap 分区不同，zram 使用的是内存而不是硬盘，因此其读写速度比 swap 分区更快。并且 zram 压缩技术可以在不降低系统性能的情况下提供更多的可用内存。</p>
<h4 id="创建zram交换分区">创建zram交换分区</h4>
<ol>
<li>
<p>加载 zram 内核模块，并创建一个 zram设备。</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo modprobe zram num_devices=1</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>将 zram 设备上的压缩算法设置为 LZ4，这是一种高效的压缩算法，可以提高交换空间的性能。</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo lz4 | sudo tee /sys/block/zram0/comp_algorithm</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>调整系统的缺省换页策略（swappiness），将其设置为10，这意味着系统更倾向于使用物理内存而不是交换空间。</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo sysctl vm.swappiness=10</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>关闭当前正在使用的 zram 设备。</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo swapoff /dev/zram0</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>重置 zram 设备，清除其中所有数据。</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo zramctl --reset /dev/zram0</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>格式化 zram 设备，以便将其用作交换空间。</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo mkswap /dev/zram0</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>打开 zram 设备，并将其设置为默认的交换空间。</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo swapon /dev/zram0</span><br></pre></td></tr></table></figure>
<p>这里使用了 lz4 压缩算法，并将 num_devices 参数设置为 1。如果需要更多的设备，可以适当调整该参数。</p>
</li>
</ol>
<h3 id="swap">swap</h3>
<h4 id="介绍-2">介绍</h4>
<p>Swap 是将部分物理内存空间暂时移动到硬盘上的交换空间。当物理内存不足时，系统将不经常使用的数据转移到 swap 分区中，以便为当前运行的程序提供更多的物理内存。Swap 使用。硬盘作为存储介质，因此其速度相对较慢。而且当交换频繁发生时，也容易降低系统的性能和响应速度。会减小硬盘的寿命。</p>
<p><strong>所以把swap优先级放在zram后面，即先使用zram，再使用swap。（数字越大，优先级越高，越先使用）</strong></p>
<h4 id="创建swap交换分区">创建swap交换分区</h4>
<ol>
<li>
<p>此命令将显示当前正在使用的所有交换分区及其相关信息，包括标签和 UUID。</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo swapon --show</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>创建交换空间大小1G，可自行修改：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo fallocate -l 1G /swapfile</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>授予权限</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod 600 /swapfile</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>启用交换内存</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkswap /swapfile</span><br><span class="line">swapon /swapfile</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>交换空间使用权重，即优先级（随便，越大越靠前，越先使用）</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sysctl vm.swappiness=100</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>开机启用交换空间</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &#x27;/swapfile swap swap defaults 0 0&#x27; &gt;&gt; /etc/fstab</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="删除swap交换分区（没用过）">删除swap交换分区（没用过）</h4>
<ol>
<li>
<p>此命令将显示当前正在使用的所有交换分区及其相关信息，包括标签和 UUID。</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo swapon --show</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>关闭要删除的交换分区。 运行以下命令：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo swapoff -L &#123;swap_label&#125;</span><br></pre></td></tr></table></figure>
<p>将 “{swap_label}” 替换为要删除的交换分区的标签。 如果您知道它的 UUID，请使用以下命令：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo swapoff -U &#123;swap_uuid&#125;</span><br></pre></td></tr></table></figure>
<p>将 “{swap_uuid}” 替换为要删除的交换分区的 UUID。</p>
</li>
<li>
<p>删除交换分区文件。如果您使用的是文件作为交换分区的话，运行以下命令：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo rm &#123;swap_file&#125;</span><br></pre></td></tr></table></figure>
<p>将 “{swap_file}” 替换为包含交换分区的文件路径和名称。</p>
</li>
<li>
<p>更新 /etc/fstab 文件。 打开 /etc/fstab 文件，并找到包含要删除的交换分区的行。 在此行上添加 “#” 符号（无引号），以将其注释掉，或者直接将该行从文件中删除。 保存更改。完成以上步骤后，即可成功删除指定的交换分区。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>笔记</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>windows 安装Git</title>
    <url>/2023/10/17/%E5%AE%89%E8%A3%85Git/</url>
    <content><![CDATA[<h2 id="windows-安装">windows 安装</h2>
<h3 id="官网下载安装包：-Git-Downloading-Package"><strong>官网下载安装包：</strong> <a href="https://git-scm.com/download/win">Git - Downloading Package</a></h3>
<p><img src="https://v3.wmnzsx.eu.org/i/1/2023/11/24/10w19tn-1.webp" alt="git1"></p>
<h3 id="安装："><strong>安装：</strong></h3>
<h4 id="选择-Git-的安装路径：">选择 Git 的安装路径：</h4>
<p><img src="https://v3.wmnzsx.eu.org/i/1/2023/11/24/10w0tou-1.webp" alt="git2"></p>
<h4 id="选择安装组件">选择安装组件</h4>
<p><img src="https://v3.wmnzsx.eu.org/i/1/2023/11/24/10y53pa-1.webp" alt="git3"></p>
<ul>
<li>Additional Icons、On the Desktop  添加桌面图标推荐选择推荐选择</li>
<li>Windows Explorer integration、Git Bash Here、Git GUI Here<br>
可以右键选择使用 Git Bash 和 Git GUI 两种方式的客户端</li>
<li>Git LFS （Large File Support） 大文件支持，推荐勾选</li>
<li>Associate .git* configuration files with the default text editor 关联.git 后缀文件，推荐勾选</li>
<li>Associate .sh files to be run with Bash 关联<code>.sh</code> 文件，推荐勾选</li>
<li>Check daily for Git for Windows updates 每天检查版本更新，不推荐勾选</li>
<li>(NEW!) Add a Git Bash Profile to Windows Terminal 将 Git Bash 添加到 Windows Terminal 中推荐勾</li>
<li>(NEW!)Scalar (Git add-on to manage large-scale repositories) Windows 新开发的一种大规模仓库管理，视情况而定</li>
</ul>
<h4 id="创建菜单文件夹">创建菜单文件夹</h4>
<p><img src="https://v3.wmnzsx.eu.org/i/1/2023/11/24/10y59st-1.webp" alt="git4"></p>
<blockquote>
<p>在开始菜单栏创建 Git 文件夹，可以修改“Git”来重新命名文件夹，也可以点击“Browser”添加到别的已有文件夹，也可以勾选“Don’t create a Start Menu folder”来选择不创建文件夹</p>
</blockquote>
<h4 id="选择-Git-默认编辑器">选择 Git 默认编辑器</h4>
<p>Git 安装程序里面内置了10种编辑器供你挑选，比如 Atom、Notepad、Notepad++、Sublime Text、Visual Studio Code、Vim 等等，默认的是 Vim ，选择 Vim 后可以直接进行到下一步，但是 Vim 是纯命令行，操作有点难度，需要学习。如果选其他编辑器，则还需要去其官网安装后才能进行下一步。</p>
<blockquote>
<p>本教程选择 Vim 编辑器</p>
</blockquote>
<p><img src="https://v3.wmnzsx.eu.org/i/1/2023/11/24/10y54jx-1.webp" alt="git5"></p>
<h4 id="决定初始化新项目（仓库）的主干名字">决定初始化新项目（仓库）的主干名字</h4>
<p><img src="https://v3.wmnzsx.eu.org/i/1/2023/11/24/10y52s9-1.webp" alt="git6"></p>
<blockquote>
<p>注： 第二个选项下面有个 NEW！ ，说很多团队已经重命名他们的默认主干名为 main . 这是因为2020 年非裔男子乔治·弗洛伊德因白人警察暴力执法惨死而掀起的 Black Lives Matter(黑人的命也是命)运动，很多人认为 master 不尊重黑人，呼吁改为 main.</p>
</blockquote>
<h4 id="调整你的-path-环境变量">调整你的 path 环境变量</h4>
<ul>
<li>第一种是仅从 Git Bash 使用 Git。这个的意思就是你只能通过 Git 安装后的 Git Bash 来使用 Git ，其他的什么命令提示符啊等第三方软件都不行。</li>
<li>第二种是从命令行以及第三方软件进行 Git。这个就是在第一种基础上进行第三方支持，你将能够从 Git Bash，命令提示符 (cmd) 和 Windows PowerShell 以及可以从 Windows 系统环境变量中寻找 Git 的任何第三方软件中使用 Git。推荐使用这个。</li>
<li>第三种是从命令提示符使用 Git 和可选的 Unix 工具。选择这种将覆盖 Windows 工具，如 “ find 和 sort ”。只有在了解其含义后才使用此选项。一句话，适合比较懂的人折腾。</li>
</ul>
<p><img src="https://v3.wmnzsx.eu.org/i/1/2023/11/24/10y50rg-1.webp" alt="git7"></p>
<details class="toggle" ><summary class="toggle-button" style="">点击查看相关解释</summary><div class="toggle-content"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">翻译如下：</span><br><span class="line"></span><br><span class="line">Use Git from Git Bash only </span><br><span class="line">This is the most cautious choice as your PATH will not be modified at all. You w only be able to use the Git command line tools from Git Bash.</span><br><span class="line">仅从 Git Bash 使用 Git</span><br><span class="line">这是最谨慎的选择，因为您的 PATH 根本不会被修改。您将只能使用 Git Bash 中的 Git 命令行工具。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Git from the command line and also from 3 rd-party software</span><br><span class="line">(Recommended) This option adds only some minimal Git wrappers to your PATH to avoid cluttering your environment with optional Unix tools.</span><br><span class="line">You will be able to use Git from Git Bash，the Command Prompt and the Windov PowerShell as well as any third-party software looking for Git in PATH.</span><br><span class="line">从命令行以及第三方软件进行 Git</span><br><span class="line">（推荐）此选项仅将一些最小的 Git 包装器添加到 PATH 中，以避免使用可选的 Unix 工具使环境混乱。</span><br><span class="line">您将能够使用 Git Bash 中的 Git，命令提示符和 Windov PowerShell 以及在 PATH 中寻找 Git 的任何第三方软件。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Use Git and optional Unix tools from the Command Prompt </span><br><span class="line">Both Git and the optional Unix tools will be added to your PATH.</span><br><span class="line">Warning: This will override Windows tools like &quot;find&quot;and &quot;sort&quot;. Only use this option if you understand the implications.</span><br><span class="line">使用命令提示符中的 Git 和可选的 Unix 工具</span><br><span class="line">Git 和可选的 Unix 工具都将添加到您的 PATH 中。</span><br><span class="line">警告：这将覆盖 Windows 工具，例如 &quot;find&quot; and &quot;sort&quot;. 仅在了解其含义后使用此选项。</span><br></pre></td></tr></table></figure>
</div></details>
<h4 id="选择-SSH-执行文件">选择 SSH 执行文件</h4>
<blockquote>
<p>勾选默认即可</p>
</blockquote>
<p><img src="https://v3.wmnzsx.eu.org/i/1/2023/11/24/10y4taa-1.webp" alt="git8"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Use bundled OpenSSH </span><br><span class="line">This uses ssh. Exe that comes with Git.</span><br><span class="line">使用捆绑的 OpenSSH</span><br><span class="line">这使用的 ssh. Exe 是 Git 自带的 </span><br><span class="line"></span><br><span class="line">Use external OpenSSH </span><br><span class="line">NEW! This uses an external ssh. Exe. Git will not install its own OpenSSH</span><br><span class="line">(and related) binaries but use them as found on the PATH.</span><br><span class="line">使用外部 OpenSSH</span><br><span class="line">新！这使用外部 ssh. Exe 文件。 </span><br><span class="line">Git 不会安装自己的 OpenSSH（和相关）二进制文件，而是使用在环境变量 PATH 中找到的它们。</span><br></pre></td></tr></table></figure>
<h4 id="选择-HTTPS-后端传输">选择 HTTPS 后端传输</h4>
<p><img src="https://v3.wmnzsx.eu.org/i/1/2023/11/24/10y88zz-1.webp" alt="git9"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">翻译如下：</span><br><span class="line"></span><br><span class="line">use the OpenSSL library </span><br><span class="line">Server certificates will be validated using the ca-bundle. crt file.</span><br><span class="line">使用 OpenSSL 库</span><br><span class="line">服务器证书将使用 ca-bundle.crt 文件进行验证。</span><br><span class="line">    </span><br><span class="line">Use the native Windows Secure Channel library </span><br><span class="line">Server certificates will be validated using Windows Certificate Stores.</span><br><span class="line">This option also allows you to use your company&#x27;s internal Root CA certificates distributed e.g. via Active Directory Domain Services.</span><br><span class="line">使用本机 Windows 安全通道库</span><br><span class="line">服务器证书将使用 Windows 证书存储进行验证。</span><br><span class="line">此选项还允许您使用公司内部分发的内部根 CA 证书，例如通过 Active Directory 域服务。</span><br></pre></td></tr></table></figure>
<p>这两种选项有什么区别：<br>
来自：<a href="https://stackoverflow.com/questions/62456484/whats-the-difference-between-openssl-and-the-native-windows-secure-channel-libr">https://stackoverflow.com/questions/62456484/whats-the-difference-between-openssl-and-the-native-windows-secure-channel-libr</a></p>
<blockquote>
<p>如果在具有企业管理证书的组织中使用 Git，则将需要使用安全通道。如果你仅使用 Git 来访问公共存储库（例如 GitHub ），或者你的组织不管理自己的证书，那么使用 SSL 后端（它们只是同一协议的不同实现）就可以了。</p>
</blockquote>
<p>也就是说，作为普通用户，只是用 Git 来访问 Github、GitLab 等网站，选择前者就行了。</p>
<h4 id="配置行尾符号转换">配置行尾符号转换</h4>
<p><img src="https://v3.wmnzsx.eu.org/i/1/2023/11/24/10zyuj7-1.webp" alt="git10"></p>
<details class="toggle" ><summary class="toggle-button" style="">点击查看相关解释</summary><div class="toggle-content"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Checkout Windows-style, commit Unix-style line endings </span><br><span class="line">Git will convert LF to CRLF when checking out text files. </span><br><span class="line">When committing text files, CRLF will be converted to LF. For cross-platform projects, this is the recommended setting on Windows(&quot;core. autocrif&quot;is set to &quot;true&quot;).</span><br><span class="line">签出 Windows 样式，提交 Unix 样式的行结尾</span><br><span class="line">Git 签出文本文件时，会将 LF 转换为 CRLF。</span><br><span class="line">提交文本文件时，CRLF 将转换为 LF。</span><br><span class="line">对于跨平台项目，这是 Windows 上的建议设置（&quot;core.autocrif&quot; 设置为 &quot;true&quot;）。</span><br><span class="line"></span><br><span class="line">Checkout as-is, commit Unix-style line endings </span><br><span class="line">Git will not perform any conversion when checking out text files. </span><br><span class="line">When committing text files, CRLF will be converted to LF. For cross-platform projects, this is the recommended setting on Unix(&quot;core.autocrif&quot; is set to &quot;input&quot;).</span><br><span class="line">按原样签出，提交 Unix 样式的行结尾</span><br><span class="line">Git 在签出文本文件时不会执行任何转换。提交文本文件时，CRLF 将转换为 LF。</span><br><span class="line">对于跨平台项目，这是在 Unix 上的建议设置（&quot;core.autocrif&quot; 设置为 &quot;input&quot;）。</span><br><span class="line"></span><br><span class="line">Checkout as-is, commit as-is </span><br><span class="line">Git will not perform any conversions when checking out or committing text files. </span><br><span class="line">Choosing this option is not recommended for cross-platform projects(&quot;core. autocrif&quot;is set to &quot;false&quot;).</span><br><span class="line">按原样签出，按原样提交</span><br><span class="line">Git 在签出或提交文本文件时不会执行任何转换。</span><br><span class="line">不建议跨平台项目选择此选项（&quot;core.autocrif&quot; 设置为 &quot;false&quot;）。</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>这三种选择分别是：</strong><br>
<code>签出 Windows 样式，提交 Unix 样式的行结尾。</code><br>
<code>按原样签出，提交Unix样式的行结尾。</code><br>
<code>按原样签出，按原样提交。</code></p>
</blockquote>
<p><strong>更多：</strong></p>
<p>那 Windows 样式和 Unix 样式到底有什么区别呢？引用《<a href="https://book.douban.com/subject/26462816/">GitHub入门与实践</a>》第 50 页内容</p>
<blockquote>
<p>GitHub 中公开的代码大部分都是以 Mac 或 Linux 中的 LF（Line Feed）换行。然而，由于 Windows 中是以 CRLF（Carriage Return+ Line Feed）换行的，所以在非对应的编辑器中将不能正常显示。<br>
Git 可以通过设置自动转换这些换行符。使用 Windows 环境的各位，请选择推荐的 “Checkout Windows-style，commit Unix-style line endings” 选项。换行符在签出时会自动转换为 CRLF，在提交时则会自动转换为 LF .</p>
</blockquote>
<p>上面说 Mac 、Linux、Unix 的 Line Feed ，翻译过来就是换行符，用 “\n” 表示，换行符 “\n” 的 ASCII 值为 10；<br>
Windows 的是 Carriage Return+ Line Feed（回车+换行），用 “\r\n” 表示，回车符 “\r” 的 ASCII 值为 13；<br>
这上下两者是不一样的。<br>
所以这就需要转换了，至于为什么选第一项？<br>
这还用问吗？<strong><code>我们现在的教程就是介绍怎么安装 Windows 版 Git，肯定选第一项啦。</code></strong><br>
至于 “回车”（carriage return）和 “换行”（line feed）这两个概念的来历和区别？<br>
引用一下阮一峰老师博客的部分内容</p>
<blockquote>
<p>在计算机还没有出现之前，有一种叫做电传打字机（Teletype Model 33）的玩意，每秒钟可以打 10 个字符。但是它有一个问题，就是打字机打完一行换行的时候，要用去 0.2 秒，正好可以打两个字符。要是在这 0.2 秒里面，又有新的字符传过来，那么这个字符将丢失。于是，研制人员想了个办法解决这个问题，就是在每行后面加两个表示结束的字符。一个叫做&quot;回车&quot;，告诉打字机把打印头定位在左边界；另一个叫做&quot;换行&quot;，告诉打字机把纸向下移一行。</p>
</blockquote>
<p>更多资料参考：<br>
腾讯云 - 换行符‘\n’和回车符‘\r’的区别？[ <a href="https://cloud.tencent.com/developer/article/1353286">https://cloud.tencent.com/developer/article/1353286</a> ]<br>
知乎 - 为什么会用\r\n 两个字符表示换行？[ <a href="https://www.zhihu.com/question/29326647">https://www.zhihu.com/question/29326647</a> ]<br>
Stackoverflow - What are carriage return, linefeed, and form feed?[ <a href="https://stackoverflow.com/questions/3091524/what-are-carriage-return-linefeed-and-form-feed">https://stackoverflow.com/questions/3091524/what-are-carriage-return-linefeed-and-form-feed</a> ]<br>
点击 next 到下一步。</p>
</div></details>
<h4 id="配置终端模拟器以与-Git-Bash-一起使用">配置终端模拟器以与 Git Bash 一起使用</h4>
<p><img src="https://v3.wmnzsx.eu.org/i/1/2023/11/24/10zyzl6-1.webp" alt="git11"></p>
<ul>
<li>建议选择第一种，MinTTY 3功能比 cmd 多，cmd 只不过比 MinTTY 更适合处理 Windows 的一些接口问题，这个对 Git 用处不大，除此之外 Windows 的默认控制台窗口（cmd）有很多劣势，比如 cmd 具有非常有限的默认历史记录回滚堆栈和糟糕的字体编码等等。</li>
<li>相比之下，MinTTY 具有可调整大小的窗口和其他有用的可配置选项，可以通过右键单击的工具栏来打开它们 git-bash 。点击next到下一步。建议选择第一种，MinTTY 3 功能比 cmd 多，cmd 只不过比 MinTTY 更适合处理 Windows 的一些接口问题，这个对 Git 用处不大，除此之外 Windows 的默认控制台窗口（cmd）有很多劣势，比如 cmd 具有非常有限的默认历史记录回滚堆栈和糟糕的字体编码等等。</li>
<li>相比之下，MinTTY 具有可调整大小的窗口和其他有用的可配置选项，可以通过右键单击的工具栏来打开它们 git-bash 。点击 next 到下一步。</li>
</ul>
<h4 id="选择默认的-“git-pull”-行为">选择默认的 “git pull” 行为</h4>
<p><img src="https://v3.wmnzsx.eu.org/i/1/2023/11/24/10y5xa4-1.webp" alt="git12"></p>
<ul>
<li>Git pull 就是获取最新的远程仓库分支到本地，并与本地分支合并<br>
上面给了三个 “git pull” 的行为：
<ul>
<li>第一个是 merge</li>
<li>第二个是 rebase</li>
<li>第三个是直接获取</li>
</ul>
</li>
<li>第一种 git pull = git fetch + git merge<br>
第二种 git pull = git fetch + git rebase<br>
第三种 git pull = git fetch ？(这个没试过，纯属猜测)</li>
</ul>
<blockquote>
<p>一般默认选择第一项，git rebase 绝大部分程序员都用不好或者不懂，而且风险很大，但是很多会用的人也很推崇，但是用不好就是灾难。<br>
Git pull 只是拉取远程分支并与本地分支合并，而 git fetch 只是拉取远程分支，怎么合并，选择 merge 还是 rebase ，可以再做选择。</p>
</blockquote>
<details class="toggle" ><summary class="toggle-button" style="">点击查看更多参考资料</summary><div class="toggle-content"><ul>
<li>知乎 - git pull 和 git fetch 的区别？ [ <a href="https://www.zhihu.com/question/38305012">https://www.zhihu.com/question/38305012</a> ]</li>
<li>知乎 - 在开发过程中使用 git rebase 还是 git merge，优缺点分别是什么？ [ <a href="https://www.zhihu.com/question/36509119">https://www.zhihu.com/question/36509119</a> ]</li>
<li>Stackoverflow - Why does git perform fast-forward merges by default? [ <a href="https://stackoverflow.com/questions/2850369">https://stackoverflow.com/questions/2850369</a> ]</li>
<li>Stackoverflow - In git how is fetch different than pull and how is merge different than rebase? [ <a href="https://stackoverflow.com/questions/14894768/">https://stackoverflow.com/questions/14894768/</a> ]</li>
<li>Stackoverflow - Difference between git pull and git pull --rebase [ <a href="https://stackoverflow.com/questions/18930527">https://stackoverflow.com/questions/18930527</a> ]</li>
</ul>
</div></details>
<h4 id="选择一个凭证帮助程序">选择一个凭证帮助程序</h4>
<p><img src="https://v3.wmnzsx.eu.org/i/1/2023/11/24/10y656i-1.webp" alt="git13"></p>
<p><strong>一共两个选项：</strong><br>
<code>Git 凭证管理</code><br>
<code>不使用凭证助手</code></p>
<p>第一个选项是提供<code>登录凭证</code>帮助的，Git 有时需要用户的凭据才能执行操作；例如，可能需要输入<code>用户名</code>和<code>密码</code>才能通过 HTTP 访问远程存储库（GitHub，GItLab 等等）。</p>
<h4 id="配置额外的选项">配置额外的选项</h4>
<p><img src="https://v3.wmnzsx.eu.org/i/1/2023/11/24/10y63fm-1.webp" alt="git14"></p>
<p><strong>有两个选项：</strong><br>
<code>启用文件系统缓存 </code> 和 <code>启用符号链接</code><br>
启用文件系统缓存就是将批量读取文件系统数据并将其缓存在内存中以进行某些操作，可以显著提升性能。这个选项默认开启。</p>
<p>启用符号链接，符号链接是一类特殊的文件，其包含有一条以绝对路径或者相对路径的形式指向其它文件或者目录的引用，类似于 Windows 的快捷方式，不完全等同类Unix（如 Linux的符号链接。因为该功能的支持需要一些条件，所以默认不开启。</p>
<h4 id="配置实验性选项">配置实验性选项</h4>
<p><img src="https://v3.wmnzsx.eu.org/i/1/2023/11/24/10y6y2b-1.webp" alt="git15"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Enable experimental support for pseudo consoles.</span><br><span class="line">(NEW!) This allows running native console programs like Node or Python in a Git Bash window without using winpty, </span><br><span class="line">but it still has known bugs.</span><br><span class="line">启用对伪控制台的实验性支持。</span><br><span class="line">(新功能!) 这允许在不使用 winpty 的情况下在 Git Bash 窗口中运行诸如 Node 或 Python 之类的本机控制台程序，</span><br><span class="line">但是它仍然存在已知的 bug。</span><br><span class="line"></span><br><span class="line">Enable experimental built-in file system monitor</span><br><span class="line">(NEW!) Automatically run a built-in file system watcher, to speed up common operations such as &#x27; git status&#x27;, &#x27; git add&#x27;, &#x27; git commit&#x27;, etc in worktrees containing many files.</span><br><span class="line">启用实验性内置文件系统监视器</span><br><span class="line">（新！）自动运行内置文件系统监视器，以加快包含许多文件的工作树中的常见操作，例如 &#x27;git status&#x27;、&#x27;git add&#x27;、&#x27;git commit&#x27; 等.</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这是实验性功能，可能会有一些小错误之类的，建议不用开启。<br>
点击 install 进行安装。</p>
</blockquote>
<h4 id="测试安装">测试安装</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 查看Git版本</span><br><span class="line">git version</span><br><span class="line"></span><br><span class="line"># 查看Git路径</span><br><span class="line">where git</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="将-git-与-GitHub-账号绑定">将 git 与 GitHub 账号绑定</h2>
<ol>
<li>
<p>使用注册 <a href="https://github.com/">GitHub</a> 账户<br>
选择免费账户（Free），并完成邮件验证。桌面鼠标右键 -&gt; 打开Git Bash Here</p>
</li>
<li>
<p><strong>配置用户名和邮箱：</strong></p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;github 用户名&quot;</span><br><span class="line">git config --global user.email &quot;github 注册邮箱&quot;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>创建 SSH 密匙</strong>：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#生成 ssh 密钥,输入下方命令，然后一路回车。</span><br><span class="line"></span><br><span class="line">ssh-keygen -t rsa -C &quot;github 注册邮箱&quot;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>添加密匙：</strong></p>
<ul>
<li>一般执行上述命令之后，会生成 <code>id_rsa</code> 和 <code>id_rsa.pub</code> 两个文件，前者是我们私有的，而后者则是对外开放的。</li>
<li>接着找到生成的 <code>.ssh</code> 的文件夹中的 id_rsa.pub 密钥。</li>
<li>进入 C:\Users\用户名.ssh 目录（要勾选显示“隐藏的项目”），用记事本打开公钥 id_rsa.pub 文件并复制里面的内容。</li>
<li>登陆 GitHub ，进入 Settings 页面，选择左边栏的 SSH and GPG keys，点击 New SSH key。<br>
即：<a href="https://github.com/settings/keys">Sign in to GitHub · GitHub</a></li>
<li>选择 new ssh keys，创建一个新的 SSH key，填写 <code>Title</code> 和 <code>Key</code>。 <code>Title</code> 可以随意，而 <code>Key</code> 的内容则是我们刚才复制的 <code>id_rsa.pub</code> 中的内容，最后点击 <code>Add SSH key</code> 即可。</li>
</ul>
</li>
<li>
<p><strong>验证连接：</strong></p>
<p>打开 Git Bash，输入 <code>ssh -T git@github.com</code> 出现 “Are you sure……”，输入 yes 回车确认。<br>
显示 “Hi xxx! You’ve successfully……” 即连接成功。</p>
</li>
</ol>
<hr>
<h2 id="参考文档">参考文档</h2>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/607970211">Git安装全教程（Win11） - 知乎</a></li>
<li><a href="https://blog.csdn.net/mukes/article/details/115693833">Git 详细安装教程（详解 Git 安装过程的每一个步骤）_git安装_mukes的博客-CSDN博客</a></li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
        <category>软件与环境</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建图床系列</title>
    <url>/2023/10/31/%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A%E7%B3%BB%E5%88%97/</url>
    <content><![CDATA[<h2 id="搭建简单图床-EasyImage">搭建简单图床 EasyImage</h2>
<p>注意：注意定时压缩下载进行备份</p>
<ul>
<li><a href="https://github.com/icret/EasyImages2.0">GitHub - icret/EasyImages2.0: 简单图床 - 一款功能强大无数据库的图床 2.0版</a></li>
<li><a href="https://icret.github.io/EasyImages2.0/#/">EasyImage2.0 简单图床</a></li>
<li><a href="https://iwanlab.com/aapanel-install-easyimage/">【宝塔面板系列】10分钟搭建一个简单图床——EasyImage 简单到无需数据库！ | 爱玩实验室 (iwanlab.com)</a></li>
</ul>
<h2 id="搭建-Telegraph-Image-图床">搭建 Telegraph-Image 图床</h2>
<p>注意：①上传后的文件删除不了，但可以设置黑白名单使其不能被正常访问，但文件实际还储存在tg的服务器上，②只要知道图片文件名，别人使用相同程序搭建该图床，别人也能通过他的域名+你的图片文件名访问图片</p>
<ul>
<li><a href="https://github.com/cf-pages/Telegraph-Image">GitHub - cf-pages/Telegraph-Image: Image Hosting solution, Flickr/imgur alternative, make it easy for users to share their images. Using Cloudflare Pages and Telegraph.</a></li>
<li><a href="https://www.nodeseek.com/post-734-1">【更新】Telegraph-Image免费自建图床新增后台图片管理功能</a></li>
</ul>
<h2 id="搭建-tgState-图床">搭建 tgState 图床</h2>
<p>注意：上传后的文件删除不了，就算你把频道啥的里面的文件删了，也没有用，文件实际还储存在tg的服务器上</p>
<ul>
<li><a href="https://github.com/csznet/tgState">GitHub - csznet/tgState: 使用Telegram作为存储的文件外链系统，可以作为图床使用，也可以作为网盘使用。</a></li>
</ul>
<h2 id="其他">其他</h2>
<h3 id="已使用">已使用</h3>
<ul>
<li>
<p>PicGo-图床工具</p>
<ul>
<li>
<p><a href="https://github.com/Molunerfinn/PicGo">GitHub - Molunerfinn/PicGo: :rocket:A simple &amp; beautiful tool for pictures uploading built by vue-cli-electron-builder</a></p>
</li>
<li>
<p><a href="https://picgo.github.io/PicGo-Doc/">PicGo</a></p>
</li>
</ul>
</li>
</ul>
<h3 id="未验证（暂未使用）">未验证（暂未使用）</h3>
<ul>
<li>
<p>盘络上传-图床上传扩展程序</p>
<ul>
<li><a href="https://fileup.dev/">盘络上传扩展 (fileup.dev)</a></li>
<li><a href="https://github.com/ZenEcho/PLExtension">GitHub - ZenEcho/PLExtension: 盘络上传，是一款免费的上传扩展程序提供兰空图床,简单图床,chevereto,阿里云oss,AWS S3,GitHub等程序的文件上传</a></li>
</ul>
</li>
<li>
<p>PicX-一款基于 GitHub API 开发的图床工具</p>
<ul>
<li><a href="https://github.com/XPoet/picx">GitHub - XPoet/picx: 🏞️ PicX 是一款基于 GitHub API 开发的图床工具，提供图片上传托管、生成图片链接和常用图片工具箱服务。</a></li>
</ul>
</li>
<li>
<p>其他</p>
<ul>
<li><a href="https://github.com/tdouguo/pic">GitHub - tdouguo/pic: 多合一图床 - Cdn图床,百度图床,阿里图床,京东图床,搜狗图床,搜狐图床,QQ图床,58图床,头条图床,网易图床,360图床,葫芦侠图床-OLEOU</a></li>
<li><a href="https://gist.github.com/BlueSkyXN/8d261d13d79e7a7672999f9935acdfe9">tgphimgbed.js · GitHub</a></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
        <category>折腾</category>
      </categories>
      <tags>
        <tag>折腾</tag>
        <tag>图床</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建免费博客：Hexo+butterfly</title>
    <url>/2023/10/17/%E6%90%AD%E5%BB%BA%E5%85%8D%E8%B4%B9%E5%8D%9A%E5%AE%A2%EF%BC%9AHexo-butterfly/</url>
    <content><![CDATA[<div class="note orange icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p>简单记录一下我博客的安装和美化，本教程仅为个人备忘录</p>
</div>
<div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p>开始前先看官方文档（最起码过一遍）<br>
官方文档：<a href="https://butterfly.js.org/">Butterfly - A Simple and Card UI Design theme for Hexo</a></p>
</div>
<h2 id="环境搭建">环境搭建</h2>
<h3 id="安装-Git：">安装 Git：</h3>
<p><a href="https://fkcc.me/2023/10/17/%E5%AE%89%E8%A3%85Git/">windows 安装Git | ZのBlog (fkcc.me)</a></p>
<h3 id="安装-node-js">安装 node.js</h3>
<p>见安装Node.Js部分</p>
<p><a href="https://fkcc.me/2023/10/17/windows%E5%B8%B8%E7%94%A8%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83%E7%9A%84%E5%AE%89%E8%A3%85/">windows常用运行环境的安装 | Z の Blog (fkcc.me)</a></p>
<h2 id="安装-Hexo">安装 Hexo</h2>
<ol>
<li>
<p>安装Hexo<br>
首先新建一个文件夹为 Hexo <strong>安装文件夹</strong>，例如：<code>E:\Blog\Hexo-Blog</code></p>
<blockquote>
<p>在 Git Bash 中使用 <code>cd</code> 命令进入文件夹：<br>
需使用 cd E:/Blog/Hexo-Blog 或者 cd /e/Blog/Hexo-Blog</p>
</blockquote>
<ul>
<li>全局安装：<code>npm install -g hexo-cli </code></li>
<li>仅局部安装 <code>hexo</code> ：<code>npm install hexo</code>        <strong># 本教程采用局部安装</strong></li>
<li>安装hexo服务器模块：<code>npm install hexo-server --save</code></li>
</ul>
 <details class="toggle" ><summary class="toggle-button" style="">点击此处展开/收起内容，来自 chatgpt 的解释</summary><div class="toggle-content"><p>全局安装和局部安装都有各自的用途和优势，选择使用哪种安装方式取决于您的具体需求。</p>
<p><strong>全局安装的优势：</strong></p>
<ul>
<li>全局安装的软件包可以在系统的任何位置使用，而不仅限于特定的项目目录。</li>
<li>全局安装的软件包可以通过命令行直接调用，无需指定完整的路径。</li>
<li>全局安装的软件包可以在多个项目中共享，避免了重复安装和占用磁盘空间。</li>
</ul>
<p><strong>局部安装的优势</strong>：</p>
<ul>
<li>局部安装将软件包安装在特定的项目目录中，使得每个项目都可以独立管理自己的依赖项。</li>
<li>局部安装的软件包版本可以与每个项目的要求相匹配，避免了不同项目之间的冲突。</li>
<li>局部安装可以使得项目更加可移植和可复制，其他用户或开发者可以通过简单的安装依赖来复现您的项目环境。</li>
</ul>
<p><strong>综合考虑</strong>，一般建议在以下情况下使用全局安装：</p>
<ul>
<li>安装命令行工具，如 Hexo CLI、Vue CLI、Angular CLI 等，这些工具通常需要在全局范围内使用。</li>
<li>安装全局的开发工具，如 TypeScript、ESLint 等，这些工具在多个项目中都可以使用。</li>
</ul>
<p>而在以下情况下使用局部安装<strong>更为合适</strong>：</p>
<ul>
<li>安装项目特定的依赖项，这样可以确保每个项目都有独立的依赖环境。</li>
<li>在不同的项目中使用不同版本的软件包，以满足不同项目的特定需求。</li>
<li>分发和共享项目时，可以通过将依赖项包含在项目中，使得其他用户或开发者可以轻松地复现项目环境。</li>
</ul>
</div></details>
<blockquote>
<p>特别注意：<br>
局部安装需要将 Hexo 所在的目录下的 <code>node_modules中的.bin</code> 添加到环境变量 PATH 之中</p>
</blockquote>
</li>
<li>
<p>在<strong>安装文件夹</strong>（E:\Blog\Hexo-Blog）下新建一个文件夹为博客文件夹 blog，并初始化博客</p>
 <figure class="highlight text"><table><tr><td class="code"><pre><span class="line">hexo init blog     //初始化项目</span><br><span class="line">cd blog            //进入项目文件夹</span><br><span class="line">npm install        //安装相关依赖</span><br></pre></td></tr></table></figure>
<blockquote>
<p>执行完成后我们打开 blog 文件夹：<br>
scaffolds 是模板文件夹，创建新文章或者新页面时，Hexo 会根据此文件夹建立文件；<br>
source 是资源文件夹；<br>
themes是主题文件夹，Hexo会根据此文件夹生成静态页面</p>
</blockquote>
<p>初始化后，目录结构如下：</p>
 <figure class="highlight text"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml      # 博客配置信息</span><br><span class="line">├── package.json     # 项目名称、描述、版本、运行和开发等信息</span><br><span class="line">├── scaffolds        # 生成文章的一些模板</span><br><span class="line">├── source           # 存放用户资源</span><br><span class="line">|   ├── _drafts</span><br><span class="line">└── _posts</span><br><span class="line">├── node_modules     # 依赖包</span><br><span class="line">└── themes           # 主题文件夹</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="将静态博客挂载到-GitHub">将静态博客挂载到 GitHub</h2>
<ol>
<li>
<p>安装 hexo-deployer-git</p>
<p><code>npm install hexo-deployer-git --save</code></p>
</li>
<li>
<p>修改 _config.yml 文件</p>
<p>在 blog 目录下的_config.yml，就是整个 Hexo 框架的配置文件了。可以在里面修改大部分的配置。详细可参考官方的 <a href="https://hexo.io/zh-cn/docs/configuration">配置描述</a>。<br>
修改最后一行的配置，将 repository 修改为你自己的 github 项目地址即可。</p>
<blockquote>
<p>请检查自己的默认分支是不是 main</p>
</blockquote>
</li>
<li>
<p>部署项目到 GitHub</p>
<p>修改好配置后，运行如下命令，将代码部署到 GitHub</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo generate</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure>
<ul>
<li>Hexo clean：删除之前生成的文件，若未生成过静态文件，可忽略此命令。</li>
<li>Hexo generate：生成静态文章，可以用 hexo g 缩写</li>
<li>Hexo deploy：部署文章，可以用 hexo d 缩写</li>
</ul>
<blockquote>
<p>注意：deploy 时可能要输入 username 和 password</p>
</blockquote>
<p>如果出现 Deploy done，则说明部署成功了。</p>
</li>
</ol>
<hr>
<h2 id="安装-Butterfly-主题">安装 Butterfly 主题</h2>
<blockquote>
<p><a href="https://butterfly.js.org/posts/21cfbf15/">Butterfly 安裝文檔(一) 快速開始 | Butterfly</a></p>
</blockquote>
<ol>
<li>
<p>本人用的是 git clone 方式安装的 hexo-theme-butterfly</p>
<p>在你的博客根目录里（本教程路径为【E:/Blog/Hexo-Blog/blog】），打开 Git 工具，执行命令即可。</p>
<ul>
<li>稳定版【建议】</li>
</ul>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly</span><br></pre></td></tr></table></figure>
<ul>
<li>测试版</li>
</ul>
<blockquote>
<p>测试版可能存在 bug，追求稳定的请安装稳定版</p>
</blockquote>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone -b dev https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly</span><br></pre></td></tr></table></figure>
<ul>
<li>升级方法：在主题目录下，运行 git pull</li>
</ul>
<blockquote>
<p>注意：如果自己魔改了，谨慎升级</p>
</blockquote>
</li>
<li>
<p>应用主题</p>
<p>修改 Hexo 根目录下的 _config.yml，把主题改为 butterfly<br>
<code>theme: butterfly</code></p>
</li>
<li>
<p>安装插件</p>
<p>如果你没有 pug 以及 stylus 的渲染器，请下载安装：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-renderer-pug hexo-renderer-stylus --save</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>升级建议</p>
<p>为了减少升级主题后带来的不便，请使用以下方法（建议，也可以不做）</p>
<p>在 hexo 的根目录创建一个文件· <code>_config.butterfly.yml</code>，并把主题目录的 <code>_config.yml</code> 内容复制到 <code> _config.butterfly.yml</code> 去。( 注意: 复制的是主题的 <code>_config.yml</code> ，而不是 hexo 的 <code>_config.yml</code>)</p>
<blockquote>
<p>注意：不要把主题目录的 <code>_config.yml</code> 删掉</p>
</blockquote>
<blockquote>
<p>注意： 以后只需要在 <code>_config. Butterfly.yml</code> 进行配置就行。<br>
如果使用了 <code>_config. Butterfly.yml</code>，配置主题的 <code>_config.yml</code> 将不会有效果。</p>
</blockquote>
<p>Hexo 会自动合并主题中的 <code> _config.yml</code> 和 <code> _config.butterfly.yml</code> 里的配置，如果存在同名配置，会使用 <code>_config.butterfly.yml</code> 的配置，其优先度较高。</p>
</li>
</ol>
<h2 id="美化">美化</h2>
<ol>
<li>
<p>首先先按照官方文档进行一些基础设置和美化</p>
<p><a href="https://butterfly.js.org/">Butterfly - A Simple and Card UI Design theme for Hexo</a></p>
<blockquote>
<p>官方文档中都有，按照顺序搞一遍进行了</p>
</blockquote>
</li>
<li>
<p>更多美化和魔改</p>
<p>其实按照官方文档设置后差不多就可以了，想要更加花里胡哨的话，可以在此基础上添加其他的美化和魔改</p>
<ul>
<li>
<p>我添加的美化和魔改：<a href="https://fkcc.me/2023/09/15/Butterfly-%E4%B8%80%E4%BA%9B%E9%AD%94%E6%94%B9%E7%BE%8E%E5%8C%96/">Butterfly 一些魔改美化 | Z の Blog (fkcc.me)</a></p>
</li>
<li>
<p>我参考的：</p>
</li>
</ul>
 <details class="toggle" ><summary class="toggle-button" style="">点击查看更多</summary><div class="toggle-content"><ol>
<li>
<p>参考比较多的</p>
<ul>
<li><a href="https://fe32.top/articles/hexo1606/#%E4%BE%A7%E8%BE%B9%E6%A0%8F%E5%85%AC%E4%BC%97%E5%8F%B7">基于 Hexo 从零开始搭建个人博客（六） | 唐志远の博客</a></li>
</ul>
</li>
<li>
<p>其他</p>
<ul>
<li>
<p><a href="https://akilar.top/">Akilarの糖果屋 - Akilar.top</a></p>
</li>
<li>
<p><a href="https://yisous.xyz/">Ariasakaの小窝</a></p>
</li>
<li>
<p><a href="https://9527zxl.github.io/2021/07/22/butterfly%E4%B8%BB%E9%A2%98%E9%AD%94%E6%94%B9%E6%A0%B7%E5%BC%8F/#%E9%A1%B5%E8%84%9A%E9%80%8F%E6%98%8E">butterfly主题魔改样式 | 从你的世界路过</a></p>
</li>
<li>
<p><a href="https://code7rain.github.io/2022/11/19/Hexo%E4%B8%BB%E9%A2%98Butterfly%E9%85%8D%E7%BD%AE%E3%80%81%E8%B8%A9%E5%9D%91%E5%8F%8A%E9%AD%94%E6%94%B9/">Hexo主题Butterfly配置、踩坑及魔改 | CodeRain</a></p>
</li>
<li>
<p><a href="https://qianchenggit.github.io/2021/10/19/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%B7%E5%BC%8F%E9%AD%94%E6%94%B9/">自定义样式魔改 | QianChengGit の小森林</a></p>
</li>
<li>
<p><a href="https://blog.csdn.net/howareyou2104/article/details/106361169">butterfly外挂插件增强(超全)_butterfly插件_会飞的小弋的博客-CSDN博客</a></p>
</li>
<li>
<p><a href="https://blog.csdn.net/howareyou2104/article/details/106393184">手把手教你修改butterfly主题的样式_butrerfly主题background更换_会飞的小弋的博客-CSDN博客</a></p>
</li>
<li>
<p><a href="https://lovelijunyi.gitee.io/posts/c898.html">小弋の生活馆全样式预览 | 小弋の生活馆</a></p>
</li>
<li>
<p><a href="https://hr-insist.github.io/Hexo/%E5%85%B3%E4%BA%8E%E6%88%91%E7%9A%84Butterfly%E4%B8%BB%E9%A2%98%E7%9A%84%E6%89%80%E6%9C%89%E4%BC%98%E5%8C%96/">关于我的Butterfly主题的所有优化 | Modesty</a></p>
</li>
<li>
<p><a href="https://blog.csdn.net/csdn__cpp/article/details/110007453">在butterfly主题下如何配置加强版看板娘？-CSDN博客</a></p>
</li>
</ul>
</li>
</ol>
</div></details>
</li>
</ol>
<h2 id="参考">参考</h2>
<p><a href="https://juejin.cn/post/6844904122353713165">使用 Hexo + GitHub + Netlify + Cloudflare 搭建个人博客 - 掘金</a></p>
]]></content>
      <categories>
        <category>教程</category>
        <category>Hexo</category>
        <category>Butterfly</category>
      </categories>
      <tags>
        <tag>Butterfly</tag>
        <tag>美化</tag>
      </tags>
  </entry>
  <entry>
    <title>随身WiFi刷debian</title>
    <url>/2023/10/31/%E9%9A%8F%E8%BA%ABWiFi%E5%88%B7debian/</url>
    <content><![CDATA[<h2 id="工具包介绍">工具包介绍</h2>
<ul>
<li>
<p>miko_service_tool_pro：备份自己的rom，以防后续操作出问题，救砖用。</p>
</li>
<li>
<p>Qualcomm Premium Tool ：备份全部分区文件</p>
</li>
<li>
<p>星海和apk文件夹：备份qcn和root</p>
</li>
<li>
<p>搞机工具箱：很多功能，可以不用这个，但是我一并上传到文件夹里了</p>
</li>
<li>
<p>随身WiFi助手：<a href="https://www.coolapk.com/u/2176732">酷铵水遍</a>的工具，可以一键刷机，可以直接刷他的包，但有些功能要钱，我没用他的，仅用此工具安装驱动等</p>
</li>
<li>
<p>DiskGeniusEng_Pro（没用过）</p>
</li>
</ul>
<blockquote>
<p><strong>详细备份过程看下方酷安帖子：</strong><br>
<a href="https://www.coolapk.com/feed/37834896?shareKey=OTc0N2EwOGM0NjdkNjQzYTk1NjQ~&amp;shareUid=3683525&amp;shareFrom=com.coolapk.market_13.1.1">高通骁龙芯片的随身wifi入门刷机教程 来自 伏莱兮浜 - 酷安 (coolapk.com)</a></p>
</blockquote>
<h2 id="刷机包介绍">刷机包介绍</h2>
<p>本教程有两种，刷机包介绍（基于<a href="https://github.com/OpenStick/OpenStick">GitHub - OpenStick/OpenStick</a>修改），均为酷安<a href="https://www.coolapk.com/u/20775713">jsbsbxjxh66</a>大佬的</p>
<h3 id="2-1Ghz-btrfs-debian-ufi-001c-其他型号自行替换boot和基带文件-7z">2.1Ghz-btrfs-debian-ufi+001c-其他型号自行替换boot和基带文件.7z</h3>
<blockquote>
<p>作者原帖介绍：<a href="https://www.coolapk.com/feed/41957632?shareKey=YjNhOWY3YWU1MTViNjQzYTk1OGQ~&amp;shareUid=3683525&amp;shareFrom=com.coolapk.market_13.1.1">410随身wifi_debian系统btrfs文件系统正式上线 来自 jsbsbxjxh66 - 酷安 (coolapk.com)</a></p>
</blockquote>
<p>文件地址(作者的)：<a href="https://cloud.189.cn/t/NnIvYrvi2AJb">https://cloud.189.cn/t/NnIvYrvi2AJb</a>  （访问码：4dzu）</p>
<p><strong>简洁介绍：</strong></p>
<ul>
<li>4g当8g用，8g当16g，主频高达2.1Ghz</li>
<li>网络文件系统齐全，usb有线网卡驱动齐全，常用串口驱动齐全</li>
<li>支持自行编译树外驱动(没有的驱动自己编译加载)</li>
<li>频率过高导致不稳定自行百度限制cpu频率。</li>
<li>ssh连接地址10.42.0.1<br>
ssh <a href="mailto:root@10.42.0.1">root@10.42.0.1</a> 密码:1313144</li>
<li><strong>压缩系统命令:<code>btrfs filesystem defragment -r -v -czstd</code> /</strong></li>
<li><strong>btrfs文件系统断电丢失数据概率大一些，因此尽量不要直接拔电源，先执行<code>poweroff</code>来关闭电源，再拔出WiFi棒子。</strong></li>
<li>部分型号刷了不启动，经过验证是随身wifi品质太差那就自行刷<a href="https://github.com/OpenStick/OpenStick">作者原版0.9Ghz的！</a></li>
<li><strong>里面只有一个001c的包，有释放内存和不释放内存boot(释放内存有467m可用吧！不能modem)其他型号自行替换boot内核和基带文件。</strong></li>
</ul>
<h3 id="ufi003-debian超频版-zip-没有btrfs">ufi003-debian超频版.zip(没有btrfs)</h3>
<p>文件地址(作者的)：<a href="https://cloud.189.cn/t/neAnmabAnYji">https://cloud.189.cn/t/neAnmabAnYji</a> （访问码：6nti）</p>
<p><strong>是上面btrfs版本的上一个版本，没有btrfs</strong></p>
<blockquote>
<p>作者原帖介绍：<a href="https://www.coolapk.com/feed/41664623?shareKey=YWFkM2Q3OWQ1YTdlNjQzYTk2MGU~&amp;shareUid=3683525&amp;shareFrom=com.coolapk.market_13.1.1">410随身wifi 各个频率版&amp;释放内存版&amp;驱动全面 来自 jsbsbxjxh66 - 酷安 (coolapk.com)</a></p>
</blockquote>
<p><strong>简洁介绍：</strong></p>
<ul>
<li>可刷型号：uif001b ufi003 ufi001c ufi903 ufi103s uz801 sp970 ufi16v3/4</li>
<li>频率有：1.2Ghz 1.4Ghz 1.6Ghz 1.8Ghz 2.0Ghz 2.1Ghz</li>
<li>释放内存版：去掉了modem和gps设备树运行内存增加到462mb！(也就是说不能插卡)</li>
<li>一键替换基带文件夹：自行提取基带文件放入里面的modem文件夹通过adb一键替换基带文件。</li>
<li>一键只刷boot&amp;rootfs文件夹：把相应的镜像文件放入一键刷入(可用于openwrt&amp;debian来回刷只需要boot和rootfs镜像文件)</li>
<li>一键通过adb连接棒子:需要更新adb驱动才能用</li>
<li>全面的网卡驱动能编译的都编译上了(可以通过usb给棒子供网两个棒子不就无线中继了)</li>
</ul>
<p><strong>须知:</strong></p>
<ul>
<li>各个型号已经替换了相应的基带文件</li>
<li>安装了一些必备软件包</li>
<li>增加了rc.local开机自动执行服务修改/etc/rc.local文件可加入一些开机要执行的命令</li>
<li>刷入自带热点4G-wifi 密码:12345678</li>
<li>ssh连接地址10.42.0.1<br>
ssh <a href="mailto:root@10.42.0.1">root@10.42.0.1</a> 密码:1313144</li>
<li>加入了这些型号串口驱动ch341/ch342/ch343/ch344/ch347/ch9101/ch9102/ch9103/ch9143</li>
<li>各大网络文件系统全部编译上了如:NFS CIFS SMB AFS等等能编译的全编译了能不能用就不知道了</li>
<li>删除热点连wifi:<code>nmtui</code> &gt; 编译连接 &gt; 删除wifi热点 &gt;返回 &gt; 启用连接(里面连wifi)</li>
<li>usb和热点不需要桥接如要重新开启热点看上面网络配置模板</li>
<li>usb有线网卡驱动能编译的都编译了自己看上面图片</li>
<li><strong>系统是带adb的需要更新adb驱动才能usb网络共享如何更新看作者项目地址：<a href="https://www.kancloud.cn/handsomehacker/openstick/2636506">查看链接 (kancloud.cn)</a></strong></li>
<li>修正了一下以前超频版的频率表(16v3的设备树不知道能用不不能用刷001c的)</li>
</ul>
<h2 id="一些命令-优化">一些命令&amp;优化</h2>
<h3 id="命令">命令</h3>
<ul>
<li>
<p>Debian的看emmc寿命<br>
<code>cat /sys/class/mmc_host/mmc0/mmc0\:0001/life_time</code><br>
或<code>apt install mmc-utilsmmc extcsd read /dev/mmcblk0</code></p>
<blockquote>
<p>0x01 表示设备使用的寿命约为 10% 到 20%（0x02 表示 20% 到 30% 等）</p>
</blockquote>
</li>
<li>
<p>启用btrfs：<code>btrfs filesystem defragment -r -v -czstd /</code></p>
</li>
<li>
<p>连接WiFi和更改主机名：<code>nmtui</code></p>
</li>
<li>
<p>更改密码：<code>passwd</code></p>
</li>
<li>
<p>关机：<code>poweroff</code></p>
</li>
</ul>
<h3 id="优化">优化</h3>
<blockquote>
<p>参考：<a href="https://www.coolapk.com/feed/46239516?shareKey=ZWQ4YWI4M2IwZDYyNjU1ODQzOGM~&amp;shareUid=3683525&amp;shareFrom=com.coolapk.market_13.3.6">随身WIFI &amp; Debian个人折腾优化 来自 XK先生 - 酷安 (coolapk.com)</a></p>
</blockquote>
<h2 id="我的记录">我的记录</h2>
<p>首先我有三个随身WiFi</p>
<ul>
<li>新讯003            —&gt;          btrfs版的Debian</li>
<li>先机103s          —&gt;          btrfs版的Debian</li>
<li>小讯003            —&gt;          普通的超频版（我这个刷btrfs版有问题，所以用的普通的超频版）</li>
</ul>
<h3 id="过程">过程</h3>
<h4 id="备份">备份</h4>
<h5 id="miko-service-tool-pro">miko_service_tool_pro</h5>
<p>让板子进入9008模式，打开miko_service_tool_pro，</p>
<ul>
<li>
<p>备份<br>
点<code>read</code> —&gt; <code>partition backup</code>，双击下面<code>double click to open save folder</code>，选好救砖包生成的路径，点<code>load partition structure</code>，点<code>read full image</code>就能制作刷机救砖包，大概5分钟以内，保存好这个名为<code>.bin</code>的文件。</p>
</li>
<li>
<p>刷机/救砖<br>
点<code>flash</code> —&gt; <code>emmc block0 flasher</code> —&gt; <code>double click.....</code> —&gt;<code> flash！</code></p>
</li>
</ul>
<h5 id="Qualcomm-Premium-Tool">Qualcomm Premium Tool</h5>
<p>备份全部分区文件，打开它的文件夹，有个提示先注册的程序，注意要把电脑音量调低！然后点开它后可能会提示安装一些东西，同意就行了，没有的话不用管，弹出窗口点击Generate Key，生成的key放在你知道的文件夹内</p>
<p>打开Qualcomm Premium Tool程序，左上菜单栏找到help—active，选择刚才生成的key就能激活这个软件了</p>
<ul>
<li>备份<br>
使板子进入9008模式，在Qualcomm Premium Tool，找<code>qualcomm</code>和<code>partition</code>，在下面点<code>scan</code>，<code>Do job</code>，它会识别显示板子的内部分区，点<code>backup</code>（正常会自动跳到这一项），右边<code>backup all</code>，最后<code>do job</code>，等待就行了，备份的文件保存好，里面的有些文件后面会用到。<br>
如果需要刷写某些分区，点击<code>scan</code>识别分区后，点<code>write</code>，再选要刷的分区，点<code>Do job</code>后选择分区文件，就能完成刷写该分区。</li>
</ul>
<h5 id="星海svip">星海svip</h5>
<p>需要先进行root，简单点的办法就是安装magisk，修补一下boot文件，在刷入。</p>
<blockquote>
<p>我没额外安装ardc，直接使用的<font color="#ff0000">随身WiFi助手</font>里面的ardc</p>
</blockquote>
<p><font color="#ff0000">ardc</font>，这是一个投屏软件，解决板子没有屏幕无法操作的问题，它的操作逻辑是鼠标左键为点击功能，右键为返回。安装完ardc后先别打开，检查一下任务管理器中，有<code>adb</code>或者<code>android debug bridge</code>程序在后台的话记得停掉，再把板子插到电脑上正常启动，打开ardc等待画面变化，成功后会停在深蓝色界面，然后把鼠标箭头移到此界面，右键点击两下，如果没有出现桌面，需要安装一个第三方桌面启动器，把我提供的apk文件里的launcher从电脑直接托到ardc界面就会自动给板子安装</p>
<ol>
<li>
<p>root</p>
<ul>
<li>
<p>备份<code>magiskboot.img</code></p>
<p>导出magiskboot.img，先将magisk修补好的boot文件名长按后重命名为magiskboot.img，输入下面命令：<br>
<code>adb pull /sdcard/Download/magiskboot.img D:/xxx</code></p>
<p>这里<code>D:/xxx</code>换成你自己的路径（斜杠朝左还是朝右都可以），接着按回车就会把magiskboot.img导出到你的电脑上</p>
</li>
<li>
<p>刷入magiskboot.img，实现root</p>
<p>①<code>adb reboot bootloader</code>  —&gt;  将板子重启到fastboot模式<br>
②<code>fastboot flash boot &quot;H:\Download\magiskboot.img&quot;</code>  —&gt;  将magiskboot.img刷入板子，实现root，注意将后面的路径更换为实际路径<br>
③<code>fastboot reboot</code>  —&gt;  重启板子，打开magisk（可能得多等会），查看是否成功root</p>
</li>
</ul>
</li>
<li>
<p>备份qcn</p>
<p>①<code>adb shell su</code>  —&gt;  桌面会显示shell申请权限，点永久就行了，接着在magisk的超级用户里看看shell授权成功与否</p>
<p>②关掉ardc，同时在任务管理器里<font color="#ff0000">如果发现adb还在后台也要关掉</font>。然后打开星海svip这个软件（免安装）。选择高通，再点联机会出现设备信息，找到高通强开1，点一键执行，在设备管理器上查看是否有端口<code>901D</code></p>
<p>③接着备份qcn，一键执行，选择qcn文件生成路径，正常情况就能备份qcn成功，如果不行就检查901d端口或者重启电脑，备份的qcn一般在<font color="#ff0000">500多k</font>，远小于这个大小的应该是备份失败了，建议再来一次。</p>
</li>
</ol>
<h4 id="刷入Debian">刷入Debian</h4>
<p>刷机包中有一件刷入</p>
<p>由于我不需要插卡，仅当linux服务器使用，所以我全选的释放内存版</p>
<h2 id="参考文章">参考文章</h2>
<ul>
<li><a href="https://www.coolapk.com/feed/36942430?shareKey=NmZjZWEwMjQ2ZTljNjQzYTk1NDg~&amp;shareUid=3683525&amp;shareFrom=com.coolapk.market_13.1.1">410随身WiFi刷openwrt和debian概述 来自 jsbsbxjxh66 - 酷安 (coolapk.com)</a></li>
<li><a href="https://www.coolapk.com/feed/37487947?shareKey=MGQwMWZmMDZlMjhhNjQzYTk1YTc~&amp;shareUid=3683525&amp;shareFrom=com.coolapk.market_13.1.1">关于Debian后的特需功能操作命令指南 来自 LCSSDWL - 酷安 (coolapk.com)</a></li>
<li><a href="https://www.coolapk.com/feed/45045253?shareKey=MDVjOTZlNjBlMGQ2NjQzYTk1YmY~&amp;shareUid=3683525&amp;shareFrom=com.coolapk.market_13.1.1">来自 yanhy - 酷安 (coolapk.com)</a></li>
<li><a href="https://yanhy.top/">yanhy’s 学习记录匣 - 记录学习的点点滴滴</a></li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
        <category>折腾</category>
      </categories>
      <tags>
        <tag>折腾</tag>
        <tag>随身WiFi</tag>
      </tags>
  </entry>
</search>
